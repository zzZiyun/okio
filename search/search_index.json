{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Okio \u00b6 Okio is a library that complements java.io and java.nio to make it much easier to access, store, and process your data. It started as a component of OkHttp , the capable HTTP client included in Android. It\u2019s well-exercised and ready to solve new problems. ByteStrings and Buffers \u00b6 Okio is built around two types that pack a lot of capability into a straightforward API: ByteString is an immutable sequence of bytes. For character data, String is fundamental. ByteString is String\u2019s long-lost brother, making it easy to treat binary data as a value. This class is ergonomic: it knows how to encode and decode itself as hex, base64, and UTF-8. Buffer is a mutable sequence of bytes. Like ArrayList , you don\u2019t need to size your buffer in advance. You read and write buffers as a queue: write data to the end and read it from the front. There\u2019s no obligation to manage positions, limits, or capacities. Internally, ByteString and Buffer do some clever things to save CPU and memory. If you encode a UTF-8 string as a ByteString , it caches a reference to that string so that if you decode it later, there\u2019s no work to do. Buffer is implemented as a linked list of segments. When you move data from one buffer to another, it reassigns ownership of the segments rather than copying the data across. This approach is particularly helpful for multithreaded programs: a thread that talks to the network can exchange data with a worker thread without any copying or ceremony. Sources and Sinks \u00b6 An elegant part of the java.io design is how streams can be layered for transformations like encryption and compression. Okio includes its own stream types called Source and Sink that work like InputStream and OutputStream , but with some key differences: Timeouts. The streams provide access to the timeouts of the underlying I/O mechanism. Unlike the java.io socket streams, both read() and write() calls honor timeouts. Easy to implement. Source declares three methods: read() , close() , and timeout() . There are no hazards like available() or single-byte reads that cause correctness and performance surprises. Easy to use. Although implementations of Source and Sink have only three methods to write, callers are given a rich API with the BufferedSource and BufferedSink interfaces. These interfaces give you everything you need in one place. No artificial distinction between byte streams and char streams. It\u2019s all data. Read and write it as bytes, UTF-8 strings, big-endian 32-bit integers, little-endian shorts; whatever you want. No more InputStreamReader ! Easy to test. The Buffer class implements both BufferedSource and BufferedSink so your test code is simple and clear. Sources and sinks interoperate with InputStream and OutputStream . You can view any Source as an InputStream , and you can view any InputStream as a Source . Similarly for Sink and OutputStream . Presentations \u00b6 A Few \u201cOk\u201d Libraries ( slides ): An introduction to Okio and three libraries written with it. Decoding the Secrets of Binary Data ( slides ): How data encoding works and how Okio does it. Ok Multiplatform! ( slides ): How we changed Okio\u2019s implementation language from Java to Kotlin. Recipes \u00b6 We\u2019ve written some recipes that demonstrate how to solve common problems with Okio. Read through them to learn about how everything works together. Cut-and-paste these examples freely; that\u2019s what they\u2019re for. Read a text file line-by-line ( Java / Kotlin ) \u00b6 Use Okio.source(File) to open a source stream to read a file. The returned Source interface is very small and has limited uses. Instead we wrap the source with a buffer. This has two benefits: It makes the API more powerful. Instead of the basic methods offered by Source , BufferedSource has dozens of methods to address most common problems concisely. It makes your program run faster. Buffering allows Okio to get more done with fewer I/O operations. Each Source that is opened needs to be closed. The code that opens the stream is responsible for making sure it is closed. Java Here we use Java\u2019s try blocks to close our sources automatically. public void readLines ( File file ) throws IOException { try ( Source fileSource = Okio . source ( file ); BufferedSource bufferedSource = Okio . buffer ( fileSource )) { while ( true ) { String line = bufferedSource . readUtf8Line (); if ( line == null ) break ; if ( line . contains ( \"square\" )) { System . out . println ( line ); } } } } Kotlin Note that static Okio methods become extension functions ( Okio.source(file) => file.source() ), and use is used to automatically close the streams: @Throws ( IOException :: class ) fun readLines ( file : File ) { file . source (). use { fileSource -> fileSource . buffer (). use { bufferedFileSource -> while ( true ) { val line = bufferedFileSource . readUtf8Line () ?: break if ( \"square\" in line ) { println ( line ) } } } } } The readUtf8Line() API reads all of the data until the next line delimiter \u2013 either \\n , \\r\\n , or the end of the file. It returns that data as a string, omitting the delimiter at the end. When it encounters empty lines the method will return an empty string. If there isn\u2019t any more data to read it will return null. The above program can be written more compactly by inlining the fileSource variable and by using a fancy for loop instead of a while : public void readLines ( File file ) throws IOException { try ( BufferedSource source = Okio . buffer ( Okio . source ( file ))) { for ( String line ; ( line = source . readUtf8Line ()) != null ; ) { if ( line . contains ( \"square\" )) { System . out . println ( line ); } } } } In Kotlin, we can wrap invocations of source.readUtf8Line() into the generateSequence builder to create a sequence of lines that will end once null is returned. Plus, transforming streams is easy thanks to the extension functions: @Throws ( IOException :: class ) fun readLines ( file : File ) { file . source (). buffer (). use { source -> generateSequence { source . readUtf8Line () } . filter { line -> \"square\" in line } . forEach ( :: println ) } } The readUtf8Line() method is suitable for parsing most files. For certain use-cases you may also consider readUtf8LineStrict() . It is similar but it requires that each line is terminated by \\n or \\r\\n . If it encounters the end of the file before that it will throw an EOFException . The strict variant also permits a byte limit to defend against malformed input. public void readLines ( File file ) throws IOException { try ( BufferedSource source = Okio . buffer ( Okio . source ( file ))) { while ( ! source . exhausted ()) { String line = source . readUtf8LineStrict ( 1024L ); if ( line . contains ( \"square\" )) { System . out . println ( line ); } } } } Here\u2019s a similar example written in Kotlin: @Throws ( IOException :: class ) fun readLines ( file : File ) { file . source (). buffer (). use { source -> while (! source . exhausted ()) { val line = source . readUtf8LineStrict ( 1024 ) if ( \"square\" in line ) { println ( line ) } } } } Write a text file ( Java / Kotlin ) \u00b6 Above we used a Source and a BufferedSource to read a file. To write, we use a Sink and a BufferedSink . The advantages of buffering are the same: a more capable API and better performance. public void writeEnv ( File file ) throws IOException { try ( Sink fileSink = Okio . sink ( file ); BufferedSink bufferedSink = Okio . buffer ( fileSink )) { for ( Map . Entry < String , String > entry : System . getenv (). entrySet ()) { bufferedSink . writeUtf8 ( entry . getKey ()); bufferedSink . writeUtf8 ( \"=\" ); bufferedSink . writeUtf8 ( entry . getValue ()); bufferedSink . writeUtf8 ( \"\\n\" ); } } } There isn\u2019t an API to write a line of input; instead we manually insert our own newline character. Most programs should hardcode \"\\n\" as the newline character. In rare situations you may use System.lineSeparator() instead of \"\\n\" : it returns \"\\r\\n\" on Windows and \"\\n\" everywhere else. We can write the above program more compactly by inlining the fileSink variable and by taking advantage of method chaining: Java public void writeEnv ( File file ) throws IOException { try ( BufferedSink sink = Okio . buffer ( Okio . sink ( file ))) { for ( Map . Entry < String , String > entry : System . getenv (). entrySet ()) { sink . writeUtf8 ( entry . getKey ()) . writeUtf8 ( \"=\" ) . writeUtf8 ( entry . getValue ()) . writeUtf8 ( \"\\n\" ); } } } Kotlin @Throws ( IOException :: class ) fun writeEnv ( file : File ) { file . sink (). buffer (). use { sink -> for (( key , value ) in System . getenv ()) { sink . writeUtf8 ( key ) sink . writeUtf8 ( \"=\" ) sink . writeUtf8 ( value ) sink . writeUtf8 ( \"\\n\" ) } } } In the above code we make four calls to writeUtf8() . Making four calls is more efficient than the code below because the VM doesn\u2019t have to create and garbage collect a temporary string. sink . writeUtf8 ( entry . getKey () + \"=\" + entry . getValue () + \"\\n\" ); // Slower! UTF-8 ( Java / Kotlin ) \u00b6 In the above APIs you can see that Okio really likes UTF-8. Early computer systems suffered many incompatible character encodings: ISO-8859-1, ShiftJIS, ASCII, EBCDIC, etc. Writing software to support multiple character sets was awful and we didn\u2019t even have emoji! Today we\u2019re lucky that the world has standardized on UTF-8 everywhere, with some rare uses of other charsets in legacy systems. If you need another character set, readString() and writeString() are there for you. These methods require that you specify a character set. Otherwise you may accidentally create data that is only readable by the local computer. Most programs should use the UTF-8 methods only. When encoding strings you need to be mindful of the different ways that strings are represented and encoded. When a glyph has an accent or another adornment it may be represented as a single complex code point ( \u00e9 ) or as a simple code point ( e ) followed by its modifiers ( \u00b4 ). When the entire glyph is a single code point that\u2019s called NFC ; when it\u2019s multiple it\u2019s NFD . Though we use UTF-8 whenever we read or write strings in I/O, when they are in memory Java Strings use an obsolete character encoding called UTF-16. It is a bad encoding because it uses a 16-bit char for most characters, but some don\u2019t fit. In particular, most emoji use two Java chars. This is problematic because String.length() returns a surprising result: the number of UTF-16 chars and not the natural number of glyphs. Caf\u00e9 \ud83c\udf69 Cafe\u0301 \ud83c\udf69 Form NFC NFD Code Points c a f \u00e9 \u2423 \ud83c\udf69 c a f e \u00b4 \u2423 \ud83c\udf69 UTF-8 bytes 43 61 66 c3a9 20 f09f8da9 43 61 66 65 cc81 20 f09f8da9 String.codePointCount 6 7 String.length 7 8 Utf8.size 10 11 For the most part Okio lets you ignore these problems and focus on your data. But when you need them, there are convenient APIs for dealing with low-level UTF-8 strings. Use Utf8.size() to count the number of bytes required to encode a string as UTF-8 without actually encoding it. This is handy in length-prefixed encodings like protocol buffers. Use BufferedSource.readUtf8CodePoint() to read a single variable-length code point, and BufferedSink.writeUtf8CodePoint() to write one. Golden Values ( Java / Kotlin ) \u00b6 Okio likes testing. The library itself is heavily tested, and it has features that are often helpful when testing application code. One pattern we\u2019ve found to be quite useful is \u201cgolden value\u201d testing. The goal of such tests is to confirm that data encoded with earlier versions of a program can safely be decoded by the current program. We\u2019ll illustrate this by encoding a value using Java Serialization. Though we must disclaim that Java Serialization is an awful encoding system and most programs should prefer other formats like JSON or protobuf! In any case, here\u2019s a method that takes an object, serializes it, and returns the result as a ByteString : Java private ByteString serialize ( Object o ) throws IOException { Buffer buffer = new Buffer (); try ( ObjectOutputStream objectOut = new ObjectOutputStream ( buffer . outputStream ())) { objectOut . writeObject ( o ); } return buffer . readByteString (); } Kotlin @Throws ( IOException :: class ) private fun serialize ( o : Any ?): ByteString { val buffer = Buffer () ObjectOutputStream ( buffer . outputStream ()). use { objectOut -> objectOut . writeObject ( o ) } return buffer . readByteString () } There\u2019s a lot going on here. We create a buffer as a holding space for our serialized data. It\u2019s a convenient replacement for ByteArrayOutputStream . We ask the buffer for its output stream. Writes to a buffer or its output stream always append data to the end of the buffer. We create an ObjectOutputStream (the encoding API for Java serialization) and write our object. The try block takes care of closing the stream for us. Note that closing a buffer has no effect. Finally we read a byte string from the buffer. The readByteString() method allows us to specify how many bytes to read; here we don\u2019t specify a count in order to read the entire thing. Reads from a buffer always consume data from the front of the buffer. With our serialize() method handy we are ready to compute and print a golden value. Java Point point = new Point ( 8.0 , 15.0 ); ByteString pointBytes = serialize ( point ); System . out . println ( pointBytes . base64 ()); Kotlin val point = Point ( 8.0 , 15.0 ) val pointBytes = serialize ( point ) println ( pointBytes . base64 ()) We print the ByteString as base64 because it\u2019s a compact format that\u2019s suitable for embedding in a test case. The program prints this: rO0ABXNyAB5va2lvLnNhbXBsZXMuR29sZGVuVmFsdWUkUG9pbnTdUW8rMji1IwIAAkQAAXhEAAF5eHBAIAAAAAAAAEAuAAAAAAAA That\u2019s our golden value! We can embed it in our test case using base64 again to convert it back into a ByteString : Java ByteString goldenBytes = ByteString . decodeBase64 ( \"rO0ABXNyAB5va2lvLnNhbXBsZ\" + \"XMuR29sZGVuVmFsdWUkUG9pbnTdUW8rMji1IwIAAkQAAXhEAAF5eHBAIAAAAAAAAEAuA\" + \"AAAAAAA\" ); Kotlin val goldenBytes = ( \"rO0ABXNyACRva2lvLnNhbXBsZXMuS290bGluR29sZGVuVmFsdWUkUG9pbnRF9yaY7cJ9EwIAA\" + \"kQAAXhEAAF5eHBAIAAAAAAAAEAuAAAAAAAA\" ). decodeBase64 () The next step is to deserialize the ByteString back into our value class. This method reverses the serialize() method above: we append a byte string to a buffer then consume it using an ObjectInputStream : Java private Object deserialize ( ByteString byteString ) throws IOException , ClassNotFoundException { Buffer buffer = new Buffer (); buffer . write ( byteString ); try ( ObjectInputStream objectIn = new ObjectInputStream ( buffer . inputStream ())) { return objectIn . readObject (); } } Kotlin @Throws ( IOException :: class , ClassNotFoundException :: class ) private fun deserialize ( byteString : ByteString ): Any ? { val buffer = Buffer () buffer . write ( byteString ) ObjectInputStream ( buffer . inputStream ()). use { objectIn -> return objectIn . readObject () } } Now we can test the decoder against the golden value: Java ByteString goldenBytes = ByteString . decodeBase64 ( \"rO0ABXNyAB5va2lvLnNhbXBsZ\" + \"XMuR29sZGVuVmFsdWUkUG9pbnTdUW8rMji1IwIAAkQAAXhEAAF5eHBAIAAAAAAAAEAuA\" + \"AAAAAAA\" ); Point decoded = ( Point ) deserialize ( goldenBytes ); assertEquals ( new Point ( 8.0 , 15.0 ), decoded ); Kotlin val goldenBytes = ( \"rO0ABXNyACRva2lvLnNhbXBsZXMuS290bGluR29sZGVuVmFsdWUkUG9pbnRF9yaY7cJ9EwIAA\" + \"kQAAXhEAAF5eHBAIAAAAAAAAEAuAAAAAAAA\" ). decodeBase64 () !! val decoded = deserialize ( goldenBytes ) as Point assertEquals ( point , decoded ) With this test we can change the serialization of the Point class without breaking compatibility. Write a binary file ( Java / Kotlin ) \u00b6 Encoding a binary file is not unlike encoding a text file. Okio uses the same BufferedSink and BufferedSource bytes for both. This is handy for binary formats that include both byte and character data. Writing binary data is more hazardous than text because if you make a mistake it is often quite difficult to diagnose. Avoid such mistakes by being careful around these traps: The width of each field. This is the number of bytes used. Okio doesn\u2019t include a mechanism to emit partial bytes. If you need that, you\u2019ll need to do your own bit shifting and masking before writing. The endianness of each field. All fields that have more than one byte have endianness : whether the bytes are ordered most-significant to least (big endian) or least-significant to most (little endian). Okio uses the Le suffix for little-endian methods; methods without a suffix are big-endian. Signed vs. Unsigned. Java doesn\u2019t have unsigned primitive types (except for char !) so coping with this is often something that happens at the application layer. To make this a little easier Okio accepts int types for writeByte() and writeShort() . You can pass an \u201cunsigned\u201d byte like 255 and Okio will do the right thing. Method Width Endianness Value Encoded Value writeByte 1 3 03 writeShort 2 big 3 00 03 writeInt 4 big 3 00 00 00 03 writeLong 8 big 3 00 00 00 00 00 00 00 03 writeShortLe 2 little 3 03 00 writeIntLe 4 little 3 03 00 00 00 writeLongLe 8 little 3 03 00 00 00 00 00 00 00 writeByte 1 Byte.MAX_VALUE 7f writeShort 2 big Short.MAX_VALUE 7f ff writeInt 4 big Int.MAX_VALUE 7f ff ff ff writeLong 8 big Long.MAX_VALUE 7f ff ff ff ff ff ff ff writeShortLe 2 little Short.MAX_VALUE ff 7f writeIntLe 4 little Int.MAX_VALUE ff ff ff 7f writeLongLe 8 little Long.MAX_VALUE ff ff ff ff ff ff ff 7f This code encodes a bitmap following the BMP file format . Java void encode ( Bitmap bitmap , BufferedSink sink ) throws IOException { int height = bitmap . height (); int width = bitmap . width (); int bytesPerPixel = 3 ; int rowByteCountWithoutPadding = ( bytesPerPixel * width ); int rowByteCount = (( rowByteCountWithoutPadding + 3 ) / 4 ) * 4 ; int pixelDataSize = rowByteCount * height ; int bmpHeaderSize = 14 ; int dibHeaderSize = 40 ; // BMP Header sink . writeUtf8 ( \"BM\" ); // ID. sink . writeIntLe ( bmpHeaderSize + dibHeaderSize + pixelDataSize ); // File size. sink . writeShortLe ( 0 ); // Unused. sink . writeShortLe ( 0 ); // Unused. sink . writeIntLe ( bmpHeaderSize + dibHeaderSize ); // Offset of pixel data. // DIB Header sink . writeIntLe ( dibHeaderSize ); sink . writeIntLe ( width ); sink . writeIntLe ( height ); sink . writeShortLe ( 1 ); // Color plane count. sink . writeShortLe ( bytesPerPixel * Byte . SIZE ); sink . writeIntLe ( 0 ); // No compression. sink . writeIntLe ( 16 ); // Size of bitmap data including padding. sink . writeIntLe ( 2835 ); // Horizontal print resolution in pixels/meter. (72 dpi). sink . writeIntLe ( 2835 ); // Vertical print resolution in pixels/meter. (72 dpi). sink . writeIntLe ( 0 ); // Palette color count. sink . writeIntLe ( 0 ); // 0 important colors. // Pixel data. for ( int y = height - 1 ; y >= 0 ; y -- ) { for ( int x = 0 ; x < width ; x ++ ) { sink . writeByte ( bitmap . blue ( x , y )); sink . writeByte ( bitmap . green ( x , y )); sink . writeByte ( bitmap . red ( x , y )); } // Padding for 4-byte alignment. for ( int p = rowByteCountWithoutPadding ; p < rowByteCount ; p ++ ) { sink . writeByte ( 0 ); } } } Kotlin @Throws ( IOException :: class ) fun encode ( bitmap : Bitmap , sink : BufferedSink ) { val height = bitmap . height val width = bitmap . width val bytesPerPixel = 3 val rowByteCountWithoutPadding = bytesPerPixel * width val rowByteCount = ( rowByteCountWithoutPadding + 3 ) / 4 * 4 val pixelDataSize = rowByteCount * height val bmpHeaderSize = 14 val dibHeaderSize = 40 // BMP Header sink . writeUtf8 ( \"BM\" ) // ID. sink . writeIntLe ( bmpHeaderSize + dibHeaderSize + pixelDataSize ) // File size. sink . writeShortLe ( 0 ) // Unused. sink . writeShortLe ( 0 ) // Unused. sink . writeIntLe ( bmpHeaderSize + dibHeaderSize ) // Offset of pixel data. // DIB Header sink . writeIntLe ( dibHeaderSize ) sink . writeIntLe ( width ) sink . writeIntLe ( height ) sink . writeShortLe ( 1 ) // Color plane count. sink . writeShortLe ( bytesPerPixel * Byte . SIZE_BITS ) sink . writeIntLe ( 0 ) // No compression. sink . writeIntLe ( 16 ) // Size of bitmap data including padding. sink . writeIntLe ( 2835 ) // Horizontal print resolution in pixels/meter. (72 dpi). sink . writeIntLe ( 2835 ) // Vertical print resolution in pixels/meter. (72 dpi). sink . writeIntLe ( 0 ) // Palette color count. sink . writeIntLe ( 0 ) // 0 important colors. // Pixel data. for ( y in height - 1 downTo 0 ) { for ( x in 0 until width ) { sink . writeByte ( bitmap . blue ( x , y )) sink . writeByte ( bitmap . green ( x , y )) sink . writeByte ( bitmap . red ( x , y )) } // Padding for 4-byte alignment. for ( p in rowByteCountWithoutPadding until rowByteCount ) { sink . writeByte ( 0 ) } } } The trickiest part of this program is the format\u2019s required padding. The BMP format expects each row to begin on a 4-byte boundary so it is necessary to add zeros to maintain the alignment. Encoding other binary formats is usually quite similar. Some tips: Write tests with golden values! Confirming that your program emits the expected result can make debugging easier. Use Utf8.size() to compute the number of bytes of an encoded string. This is essential for length-prefixed formats. Use Float.floatToIntBits() and Double.doubleToLongBits() to encode floating point values. Communicate on a Socket ( Java / Kotlin ) \u00b6 Sending and receiving data over the network is a bit like writing and reading files. We use BufferedSink to encode output and BufferedSource to decode input. Like files, network protocols can be text, binary, or a mix of both. But there are also some substantial differences between the network and the filesystem. With a file you\u2019re either reading or writing but with the network you can do both! Some protocols handle this by taking turns: write a request, read a response, repeat. You can implement this kind of protocol with a single thread. In other protocols you may read and write simultaneously. Typically you\u2019ll want one dedicated thread for reading. For writing you can use either a dedicated thread or use synchronized so that multiple threads can share a sink. Okio\u2019s streams are not safe for concurrent use. Sinks buffer outbound data to minimize I/O operations. This is efficient but it means you must manually call flush() to transmit data. Typically message-oriented protocols flush after each message. Note that Okio will automatically flush when the buffered data exceeds some threshold. This is intended to save memory and you shouldn\u2019t rely on it for interactive protocols. Okio builds on java.io.Socket for connectivity. Create your socket as a server or as a client, then use Okio.source(Socket) to read and Okio.sink(Socket) to write. These APIs also work with SSLSocket . You should use SSL unless you have a very good reason not to! Cancel a socket from any thread by calling Socket.close() ; this will cause its sources and sinks to immediately fail with an IOException . You can also configure timeouts for all socket operations. You don\u2019t need a reference to the socket to adjust timeouts: Source and Sink expose timeouts directly. This API works even if the streams are decorated. As a complete example of networking with Okio we wrote a basic SOCKS proxy server. Some highlights: Java Socket fromSocket = ... BufferedSource fromSource = Okio . buffer ( Okio . source ( fromSocket )); BufferedSink fromSink = Okio . buffer ( Okio . sink ( fromSocket )); Kotlin val fromSocket : Socket = ... val fromSource = fromSocket . source (). buffer () val fromSink = fromSocket . sink (). buffer () Creating sources and sinks for sockets is the same as creating them for files. Once you create a Source or Sink for a socket you must not use its InputStream or OutputStream , respectively. Java Buffer buffer = new Buffer (); for ( long byteCount ; ( byteCount = source . read ( buffer , 8192L )) != - 1 ; ) { sink . write ( buffer , byteCount ); sink . flush (); } Kotlin val buffer = Buffer () var byteCount : Long while ( source . read ( buffer , 8192L ). also { byteCount = it } != - 1L ) { sink . write ( buffer , byteCount ) sink . flush () } The above loop copies data from the source to the sink, flushing after each read. If we didn\u2019t need the flushing we could replace this loop with a single call to BufferedSink.writeAll(Source) . The 8192 argument to read() is the maximum number of bytes to read before returning. We could have passed any value here, but we like 8 KiB because that\u2019s the largest value Okio can do in a single system call. Most of the time application code doesn\u2019t need to deal with such limits! Java int addressType = fromSource . readByte () & 0xff ; int port = fromSource . readShort () & 0xffff ; Kotlin val addressType = fromSource . readByte (). toInt () and 0 xff val port = fromSource . readShort (). toInt () and 0 xffff Okio uses signed types like byte and short , but often protocols want unsigned values. The bitwise & operator is Java\u2019s preferred idiom to convert a signed value into an unsigned value. Here\u2019s a cheat sheet for bytes, shorts, and ints: Type Signed Range Unsigned Range Signed to Unsigned byte -128..127 0..255 int u = s & 0xff; short -32,768..32,767 0..65,535 int u = s & 0xffff; int -2,147,483,648..2,147,483,647 0..4,294,967,295 long u = s & 0xffffffffL; Java has no primitive type that can represent unsigned longs. Hashing ( Java / Kotlin ) \u00b6 We\u2019re bombarded by hashing in our lives as Java programmers. Early on we\u2019re introduced to the hashCode() method, something we know we need to override otherwise unforeseen bad things happen. Later we\u2019re shown LinkedHashMap and its friends. These build on that hashCode() method to organize data for fast retrieval. Elsewhere we have cryptographic hash functions. These get used all over the place. HTTPS certificates, Git commits, BitTorrent integrity checking, and Blockchain blocks all use cryptographic hashes. Good use of hashes can improve the performance, privacy, security, and simplicity of an application. Each cryptographic hash function accepts a variable-length stream of input bytes and produces a fixed-length byte string value called the \u201chash\u201d. Hash functions have these important qualities: Deterministic: each input always produces the same output. Uniform: each output byte string is equally likely. It is very difficult to find or create pairs of different inputs that yield the same output. This is called a \u201ccollision\u201d. Non-reversible: knowing an output doesn\u2019t help you to find the input. Note that if you know some possible inputs you can hash them to see if their hashes match. Well-known: the hash is implemented everywhere and rigorously understood. Good hash functions are very cheap to compute (dozens of microseconds) and expensive to reverse (quintillions of millenia). Steady advances in computing and mathematics have caused once-great hash functions to become inexpensive to reverse. When choosing a hash function, beware that not all are created equal! Okio supports these well-known cryptographic hash functions: MD5 : a 128-bit (16 byte) cryptographic hash. It is both insecure and obsolete because it is inexpensive to reverse! This hash is offered because it is popular and convenient for use in legacy systems that are not security-sensitive. SHA-1 : a 160-bit (20 byte) cryptographic hash. It was recently demonstrated that it is feasible to create SHA-1 collisions. Consider upgrading from SHA-1 to SHA-256. SHA-256 : a 256-bit (32 byte) cryptographic hash. SHA-256 is widely understood and expensive to reverse. This is the hash most systems should use. SHA-512 : a 512-bit (64 byte) cryptographic hash. It is expensive to reverse. Each hash creates a ByteString of the specified length. Use hex() to get the conventional human-readable form. Or leave it as a ByteString because that\u2019s a convenient model type! Okio can produce cryptographic hashes from byte strings: Java ByteString byteString = readByteString ( new File ( \"README.md\" )); System . out . println ( \" md5: \" + byteString . md5 (). hex ()); System . out . println ( \" sha1: \" + byteString . sha1 (). hex ()); System . out . println ( \"sha256: \" + byteString . sha256 (). hex ()); System . out . println ( \"sha512: \" + byteString . sha512 (). hex ()); Kotlin val byteString = readByteString ( File ( \"README.md\" )) println ( \" md5: \" + byteString . md5 (). hex ()) println ( \" sha1: \" + byteString . sha1 (). hex ()) println ( \" sha256: \" + byteString . sha256 (). hex ()) println ( \" sha512: \" + byteString . sha512 (). hex ()) From buffers: Java Buffer buffer = readBuffer ( new File ( \"README.md\" )); System . out . println ( \" md5: \" + buffer . md5 (). hex ()); System . out . println ( \" sha1: \" + buffer . sha1 (). hex ()); System . out . println ( \"sha256: \" + buffer . sha256 (). hex ()); System . out . println ( \"sha512: \" + buffer . sha512 (). hex ()); Kotlin val buffer = readBuffer ( File ( \"README.md\" )) println ( \" md5: \" + buffer . md5 (). hex ()) println ( \" sha1: \" + buffer . sha1 (). hex ()) println ( \" sha256: \" + buffer . sha256 (). hex ()) println ( \" sha512: \" + buffer . sha512 (). hex ()) While streaming from a source: Java try ( HashingSink hashingSink = HashingSink . sha256 ( Okio . blackhole ()); BufferedSource source = Okio . buffer ( Okio . source ( file ))) { source . readAll ( hashingSink ); System . out . println ( \"sha256: \" + hashingSink . hash (). hex ()); } Kotlin sha256 ( blackholeSink ()). use { hashingSink -> file . source (). buffer (). use { source -> source . readAll ( hashingSink ) println ( \" sha256: \" + hashingSink . hash . hex ()) } } While streaming to a sink: Java try ( HashingSink hashingSink = HashingSink . sha256 ( Okio . blackhole ()); BufferedSink sink = Okio . buffer ( hashingSink ); Source source = Okio . source ( file )) { sink . writeAll ( source ); sink . close (); // Emit anything buffered. System . out . println ( \"sha256: \" + hashingSink . hash (). hex ()); } Kotlin sha256 ( blackholeSink ()). use { hashingSink -> hashingSink . buffer (). use { sink -> file . source (). use { source -> sink . writeAll ( source ) sink . close () // Emit anything buffered. println ( \" sha256: \" + hashingSink . hash . hex ()) } } } Okio also supports HMAC (Hash Message Authentication Code) which combines a secret and a hash. Applications use HMAC for data integrity and authentication. Java ByteString secret = ByteString . decodeHex ( \"7065616e7574627574746572\" ); System . out . println ( \"hmacSha256: \" + byteString . hmacSha256 ( secret ). hex ()); Kotlin val secret = \"7065616e7574627574746572\" . decodeHex () println ( \"hmacSha256: \" + byteString . hmacSha256 ( secret ). hex ()) As with hashing, you can generate an HMAC from a ByteString , Buffer , HashingSource , and HashingSink . Note that Okio doesn\u2019t implement HMAC for MD5. Okio uses Java\u2019s java.security.MessageDigest for cryptographic hashes and javax.crypto.Mac for HMAC. Releases \u00b6 Our change log has release history. implementation ( \"com.squareup.okio:okio:2.8.0\" ) Snapshot builds are also available repositories { maven { url = uri ( \"https://oss.sonatype.org/content/repositories/snapshots/\" ) } } dependencies { implementation ( \"com.squareup.okio:okio:2.8.0\" ) } R8 / ProGuard \u00b6 If you are using R8 or ProGuard add the options from this file . License \u00b6 Copyright 2013 Square, Inc. Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.","title":"Overview"},{"location":"#okio","text":"Okio is a library that complements java.io and java.nio to make it much easier to access, store, and process your data. It started as a component of OkHttp , the capable HTTP client included in Android. It\u2019s well-exercised and ready to solve new problems.","title":"Okio"},{"location":"#bytestrings-and-buffers","text":"Okio is built around two types that pack a lot of capability into a straightforward API: ByteString is an immutable sequence of bytes. For character data, String is fundamental. ByteString is String\u2019s long-lost brother, making it easy to treat binary data as a value. This class is ergonomic: it knows how to encode and decode itself as hex, base64, and UTF-8. Buffer is a mutable sequence of bytes. Like ArrayList , you don\u2019t need to size your buffer in advance. You read and write buffers as a queue: write data to the end and read it from the front. There\u2019s no obligation to manage positions, limits, or capacities. Internally, ByteString and Buffer do some clever things to save CPU and memory. If you encode a UTF-8 string as a ByteString , it caches a reference to that string so that if you decode it later, there\u2019s no work to do. Buffer is implemented as a linked list of segments. When you move data from one buffer to another, it reassigns ownership of the segments rather than copying the data across. This approach is particularly helpful for multithreaded programs: a thread that talks to the network can exchange data with a worker thread without any copying or ceremony.","title":"ByteStrings and Buffers"},{"location":"#sources-and-sinks","text":"An elegant part of the java.io design is how streams can be layered for transformations like encryption and compression. Okio includes its own stream types called Source and Sink that work like InputStream and OutputStream , but with some key differences: Timeouts. The streams provide access to the timeouts of the underlying I/O mechanism. Unlike the java.io socket streams, both read() and write() calls honor timeouts. Easy to implement. Source declares three methods: read() , close() , and timeout() . There are no hazards like available() or single-byte reads that cause correctness and performance surprises. Easy to use. Although implementations of Source and Sink have only three methods to write, callers are given a rich API with the BufferedSource and BufferedSink interfaces. These interfaces give you everything you need in one place. No artificial distinction between byte streams and char streams. It\u2019s all data. Read and write it as bytes, UTF-8 strings, big-endian 32-bit integers, little-endian shorts; whatever you want. No more InputStreamReader ! Easy to test. The Buffer class implements both BufferedSource and BufferedSink so your test code is simple and clear. Sources and sinks interoperate with InputStream and OutputStream . You can view any Source as an InputStream , and you can view any InputStream as a Source . Similarly for Sink and OutputStream .","title":"Sources and Sinks"},{"location":"#presentations","text":"A Few \u201cOk\u201d Libraries ( slides ): An introduction to Okio and three libraries written with it. Decoding the Secrets of Binary Data ( slides ): How data encoding works and how Okio does it. Ok Multiplatform! ( slides ): How we changed Okio\u2019s implementation language from Java to Kotlin.","title":"Presentations"},{"location":"#recipes","text":"We\u2019ve written some recipes that demonstrate how to solve common problems with Okio. Read through them to learn about how everything works together. Cut-and-paste these examples freely; that\u2019s what they\u2019re for.","title":"Recipes"},{"location":"#read-a-text-file-line-by-line-javakotlin","text":"Use Okio.source(File) to open a source stream to read a file. The returned Source interface is very small and has limited uses. Instead we wrap the source with a buffer. This has two benefits: It makes the API more powerful. Instead of the basic methods offered by Source , BufferedSource has dozens of methods to address most common problems concisely. It makes your program run faster. Buffering allows Okio to get more done with fewer I/O operations. Each Source that is opened needs to be closed. The code that opens the stream is responsible for making sure it is closed. Java Here we use Java\u2019s try blocks to close our sources automatically. public void readLines ( File file ) throws IOException { try ( Source fileSource = Okio . source ( file ); BufferedSource bufferedSource = Okio . buffer ( fileSource )) { while ( true ) { String line = bufferedSource . readUtf8Line (); if ( line == null ) break ; if ( line . contains ( \"square\" )) { System . out . println ( line ); } } } } Kotlin Note that static Okio methods become extension functions ( Okio.source(file) => file.source() ), and use is used to automatically close the streams: @Throws ( IOException :: class ) fun readLines ( file : File ) { file . source (). use { fileSource -> fileSource . buffer (). use { bufferedFileSource -> while ( true ) { val line = bufferedFileSource . readUtf8Line () ?: break if ( \"square\" in line ) { println ( line ) } } } } } The readUtf8Line() API reads all of the data until the next line delimiter \u2013 either \\n , \\r\\n , or the end of the file. It returns that data as a string, omitting the delimiter at the end. When it encounters empty lines the method will return an empty string. If there isn\u2019t any more data to read it will return null. The above program can be written more compactly by inlining the fileSource variable and by using a fancy for loop instead of a while : public void readLines ( File file ) throws IOException { try ( BufferedSource source = Okio . buffer ( Okio . source ( file ))) { for ( String line ; ( line = source . readUtf8Line ()) != null ; ) { if ( line . contains ( \"square\" )) { System . out . println ( line ); } } } } In Kotlin, we can wrap invocations of source.readUtf8Line() into the generateSequence builder to create a sequence of lines that will end once null is returned. Plus, transforming streams is easy thanks to the extension functions: @Throws ( IOException :: class ) fun readLines ( file : File ) { file . source (). buffer (). use { source -> generateSequence { source . readUtf8Line () } . filter { line -> \"square\" in line } . forEach ( :: println ) } } The readUtf8Line() method is suitable for parsing most files. For certain use-cases you may also consider readUtf8LineStrict() . It is similar but it requires that each line is terminated by \\n or \\r\\n . If it encounters the end of the file before that it will throw an EOFException . The strict variant also permits a byte limit to defend against malformed input. public void readLines ( File file ) throws IOException { try ( BufferedSource source = Okio . buffer ( Okio . source ( file ))) { while ( ! source . exhausted ()) { String line = source . readUtf8LineStrict ( 1024L ); if ( line . contains ( \"square\" )) { System . out . println ( line ); } } } } Here\u2019s a similar example written in Kotlin: @Throws ( IOException :: class ) fun readLines ( file : File ) { file . source (). buffer (). use { source -> while (! source . exhausted ()) { val line = source . readUtf8LineStrict ( 1024 ) if ( \"square\" in line ) { println ( line ) } } } }","title":"Read a text file line-by-line (Java/Kotlin)"},{"location":"#write-a-text-file-javakotlin","text":"Above we used a Source and a BufferedSource to read a file. To write, we use a Sink and a BufferedSink . The advantages of buffering are the same: a more capable API and better performance. public void writeEnv ( File file ) throws IOException { try ( Sink fileSink = Okio . sink ( file ); BufferedSink bufferedSink = Okio . buffer ( fileSink )) { for ( Map . Entry < String , String > entry : System . getenv (). entrySet ()) { bufferedSink . writeUtf8 ( entry . getKey ()); bufferedSink . writeUtf8 ( \"=\" ); bufferedSink . writeUtf8 ( entry . getValue ()); bufferedSink . writeUtf8 ( \"\\n\" ); } } } There isn\u2019t an API to write a line of input; instead we manually insert our own newline character. Most programs should hardcode \"\\n\" as the newline character. In rare situations you may use System.lineSeparator() instead of \"\\n\" : it returns \"\\r\\n\" on Windows and \"\\n\" everywhere else. We can write the above program more compactly by inlining the fileSink variable and by taking advantage of method chaining: Java public void writeEnv ( File file ) throws IOException { try ( BufferedSink sink = Okio . buffer ( Okio . sink ( file ))) { for ( Map . Entry < String , String > entry : System . getenv (). entrySet ()) { sink . writeUtf8 ( entry . getKey ()) . writeUtf8 ( \"=\" ) . writeUtf8 ( entry . getValue ()) . writeUtf8 ( \"\\n\" ); } } } Kotlin @Throws ( IOException :: class ) fun writeEnv ( file : File ) { file . sink (). buffer (). use { sink -> for (( key , value ) in System . getenv ()) { sink . writeUtf8 ( key ) sink . writeUtf8 ( \"=\" ) sink . writeUtf8 ( value ) sink . writeUtf8 ( \"\\n\" ) } } } In the above code we make four calls to writeUtf8() . Making four calls is more efficient than the code below because the VM doesn\u2019t have to create and garbage collect a temporary string. sink . writeUtf8 ( entry . getKey () + \"=\" + entry . getValue () + \"\\n\" ); // Slower!","title":"Write a text file (Java/Kotlin)"},{"location":"#utf-8-javakotlin","text":"In the above APIs you can see that Okio really likes UTF-8. Early computer systems suffered many incompatible character encodings: ISO-8859-1, ShiftJIS, ASCII, EBCDIC, etc. Writing software to support multiple character sets was awful and we didn\u2019t even have emoji! Today we\u2019re lucky that the world has standardized on UTF-8 everywhere, with some rare uses of other charsets in legacy systems. If you need another character set, readString() and writeString() are there for you. These methods require that you specify a character set. Otherwise you may accidentally create data that is only readable by the local computer. Most programs should use the UTF-8 methods only. When encoding strings you need to be mindful of the different ways that strings are represented and encoded. When a glyph has an accent or another adornment it may be represented as a single complex code point ( \u00e9 ) or as a simple code point ( e ) followed by its modifiers ( \u00b4 ). When the entire glyph is a single code point that\u2019s called NFC ; when it\u2019s multiple it\u2019s NFD . Though we use UTF-8 whenever we read or write strings in I/O, when they are in memory Java Strings use an obsolete character encoding called UTF-16. It is a bad encoding because it uses a 16-bit char for most characters, but some don\u2019t fit. In particular, most emoji use two Java chars. This is problematic because String.length() returns a surprising result: the number of UTF-16 chars and not the natural number of glyphs. Caf\u00e9 \ud83c\udf69 Cafe\u0301 \ud83c\udf69 Form NFC NFD Code Points c a f \u00e9 \u2423 \ud83c\udf69 c a f e \u00b4 \u2423 \ud83c\udf69 UTF-8 bytes 43 61 66 c3a9 20 f09f8da9 43 61 66 65 cc81 20 f09f8da9 String.codePointCount 6 7 String.length 7 8 Utf8.size 10 11 For the most part Okio lets you ignore these problems and focus on your data. But when you need them, there are convenient APIs for dealing with low-level UTF-8 strings. Use Utf8.size() to count the number of bytes required to encode a string as UTF-8 without actually encoding it. This is handy in length-prefixed encodings like protocol buffers. Use BufferedSource.readUtf8CodePoint() to read a single variable-length code point, and BufferedSink.writeUtf8CodePoint() to write one.","title":"UTF-8 (Java/Kotlin)"},{"location":"#golden-values-javakotlin","text":"Okio likes testing. The library itself is heavily tested, and it has features that are often helpful when testing application code. One pattern we\u2019ve found to be quite useful is \u201cgolden value\u201d testing. The goal of such tests is to confirm that data encoded with earlier versions of a program can safely be decoded by the current program. We\u2019ll illustrate this by encoding a value using Java Serialization. Though we must disclaim that Java Serialization is an awful encoding system and most programs should prefer other formats like JSON or protobuf! In any case, here\u2019s a method that takes an object, serializes it, and returns the result as a ByteString : Java private ByteString serialize ( Object o ) throws IOException { Buffer buffer = new Buffer (); try ( ObjectOutputStream objectOut = new ObjectOutputStream ( buffer . outputStream ())) { objectOut . writeObject ( o ); } return buffer . readByteString (); } Kotlin @Throws ( IOException :: class ) private fun serialize ( o : Any ?): ByteString { val buffer = Buffer () ObjectOutputStream ( buffer . outputStream ()). use { objectOut -> objectOut . writeObject ( o ) } return buffer . readByteString () } There\u2019s a lot going on here. We create a buffer as a holding space for our serialized data. It\u2019s a convenient replacement for ByteArrayOutputStream . We ask the buffer for its output stream. Writes to a buffer or its output stream always append data to the end of the buffer. We create an ObjectOutputStream (the encoding API for Java serialization) and write our object. The try block takes care of closing the stream for us. Note that closing a buffer has no effect. Finally we read a byte string from the buffer. The readByteString() method allows us to specify how many bytes to read; here we don\u2019t specify a count in order to read the entire thing. Reads from a buffer always consume data from the front of the buffer. With our serialize() method handy we are ready to compute and print a golden value. Java Point point = new Point ( 8.0 , 15.0 ); ByteString pointBytes = serialize ( point ); System . out . println ( pointBytes . base64 ()); Kotlin val point = Point ( 8.0 , 15.0 ) val pointBytes = serialize ( point ) println ( pointBytes . base64 ()) We print the ByteString as base64 because it\u2019s a compact format that\u2019s suitable for embedding in a test case. The program prints this: rO0ABXNyAB5va2lvLnNhbXBsZXMuR29sZGVuVmFsdWUkUG9pbnTdUW8rMji1IwIAAkQAAXhEAAF5eHBAIAAAAAAAAEAuAAAAAAAA That\u2019s our golden value! We can embed it in our test case using base64 again to convert it back into a ByteString : Java ByteString goldenBytes = ByteString . decodeBase64 ( \"rO0ABXNyAB5va2lvLnNhbXBsZ\" + \"XMuR29sZGVuVmFsdWUkUG9pbnTdUW8rMji1IwIAAkQAAXhEAAF5eHBAIAAAAAAAAEAuA\" + \"AAAAAAA\" ); Kotlin val goldenBytes = ( \"rO0ABXNyACRva2lvLnNhbXBsZXMuS290bGluR29sZGVuVmFsdWUkUG9pbnRF9yaY7cJ9EwIAA\" + \"kQAAXhEAAF5eHBAIAAAAAAAAEAuAAAAAAAA\" ). decodeBase64 () The next step is to deserialize the ByteString back into our value class. This method reverses the serialize() method above: we append a byte string to a buffer then consume it using an ObjectInputStream : Java private Object deserialize ( ByteString byteString ) throws IOException , ClassNotFoundException { Buffer buffer = new Buffer (); buffer . write ( byteString ); try ( ObjectInputStream objectIn = new ObjectInputStream ( buffer . inputStream ())) { return objectIn . readObject (); } } Kotlin @Throws ( IOException :: class , ClassNotFoundException :: class ) private fun deserialize ( byteString : ByteString ): Any ? { val buffer = Buffer () buffer . write ( byteString ) ObjectInputStream ( buffer . inputStream ()). use { objectIn -> return objectIn . readObject () } } Now we can test the decoder against the golden value: Java ByteString goldenBytes = ByteString . decodeBase64 ( \"rO0ABXNyAB5va2lvLnNhbXBsZ\" + \"XMuR29sZGVuVmFsdWUkUG9pbnTdUW8rMji1IwIAAkQAAXhEAAF5eHBAIAAAAAAAAEAuA\" + \"AAAAAAA\" ); Point decoded = ( Point ) deserialize ( goldenBytes ); assertEquals ( new Point ( 8.0 , 15.0 ), decoded ); Kotlin val goldenBytes = ( \"rO0ABXNyACRva2lvLnNhbXBsZXMuS290bGluR29sZGVuVmFsdWUkUG9pbnRF9yaY7cJ9EwIAA\" + \"kQAAXhEAAF5eHBAIAAAAAAAAEAuAAAAAAAA\" ). decodeBase64 () !! val decoded = deserialize ( goldenBytes ) as Point assertEquals ( point , decoded ) With this test we can change the serialization of the Point class without breaking compatibility.","title":"Golden Values (Java/Kotlin)"},{"location":"#write-a-binary-file-javakotlin","text":"Encoding a binary file is not unlike encoding a text file. Okio uses the same BufferedSink and BufferedSource bytes for both. This is handy for binary formats that include both byte and character data. Writing binary data is more hazardous than text because if you make a mistake it is often quite difficult to diagnose. Avoid such mistakes by being careful around these traps: The width of each field. This is the number of bytes used. Okio doesn\u2019t include a mechanism to emit partial bytes. If you need that, you\u2019ll need to do your own bit shifting and masking before writing. The endianness of each field. All fields that have more than one byte have endianness : whether the bytes are ordered most-significant to least (big endian) or least-significant to most (little endian). Okio uses the Le suffix for little-endian methods; methods without a suffix are big-endian. Signed vs. Unsigned. Java doesn\u2019t have unsigned primitive types (except for char !) so coping with this is often something that happens at the application layer. To make this a little easier Okio accepts int types for writeByte() and writeShort() . You can pass an \u201cunsigned\u201d byte like 255 and Okio will do the right thing. Method Width Endianness Value Encoded Value writeByte 1 3 03 writeShort 2 big 3 00 03 writeInt 4 big 3 00 00 00 03 writeLong 8 big 3 00 00 00 00 00 00 00 03 writeShortLe 2 little 3 03 00 writeIntLe 4 little 3 03 00 00 00 writeLongLe 8 little 3 03 00 00 00 00 00 00 00 writeByte 1 Byte.MAX_VALUE 7f writeShort 2 big Short.MAX_VALUE 7f ff writeInt 4 big Int.MAX_VALUE 7f ff ff ff writeLong 8 big Long.MAX_VALUE 7f ff ff ff ff ff ff ff writeShortLe 2 little Short.MAX_VALUE ff 7f writeIntLe 4 little Int.MAX_VALUE ff ff ff 7f writeLongLe 8 little Long.MAX_VALUE ff ff ff ff ff ff ff 7f This code encodes a bitmap following the BMP file format . Java void encode ( Bitmap bitmap , BufferedSink sink ) throws IOException { int height = bitmap . height (); int width = bitmap . width (); int bytesPerPixel = 3 ; int rowByteCountWithoutPadding = ( bytesPerPixel * width ); int rowByteCount = (( rowByteCountWithoutPadding + 3 ) / 4 ) * 4 ; int pixelDataSize = rowByteCount * height ; int bmpHeaderSize = 14 ; int dibHeaderSize = 40 ; // BMP Header sink . writeUtf8 ( \"BM\" ); // ID. sink . writeIntLe ( bmpHeaderSize + dibHeaderSize + pixelDataSize ); // File size. sink . writeShortLe ( 0 ); // Unused. sink . writeShortLe ( 0 ); // Unused. sink . writeIntLe ( bmpHeaderSize + dibHeaderSize ); // Offset of pixel data. // DIB Header sink . writeIntLe ( dibHeaderSize ); sink . writeIntLe ( width ); sink . writeIntLe ( height ); sink . writeShortLe ( 1 ); // Color plane count. sink . writeShortLe ( bytesPerPixel * Byte . SIZE ); sink . writeIntLe ( 0 ); // No compression. sink . writeIntLe ( 16 ); // Size of bitmap data including padding. sink . writeIntLe ( 2835 ); // Horizontal print resolution in pixels/meter. (72 dpi). sink . writeIntLe ( 2835 ); // Vertical print resolution in pixels/meter. (72 dpi). sink . writeIntLe ( 0 ); // Palette color count. sink . writeIntLe ( 0 ); // 0 important colors. // Pixel data. for ( int y = height - 1 ; y >= 0 ; y -- ) { for ( int x = 0 ; x < width ; x ++ ) { sink . writeByte ( bitmap . blue ( x , y )); sink . writeByte ( bitmap . green ( x , y )); sink . writeByte ( bitmap . red ( x , y )); } // Padding for 4-byte alignment. for ( int p = rowByteCountWithoutPadding ; p < rowByteCount ; p ++ ) { sink . writeByte ( 0 ); } } } Kotlin @Throws ( IOException :: class ) fun encode ( bitmap : Bitmap , sink : BufferedSink ) { val height = bitmap . height val width = bitmap . width val bytesPerPixel = 3 val rowByteCountWithoutPadding = bytesPerPixel * width val rowByteCount = ( rowByteCountWithoutPadding + 3 ) / 4 * 4 val pixelDataSize = rowByteCount * height val bmpHeaderSize = 14 val dibHeaderSize = 40 // BMP Header sink . writeUtf8 ( \"BM\" ) // ID. sink . writeIntLe ( bmpHeaderSize + dibHeaderSize + pixelDataSize ) // File size. sink . writeShortLe ( 0 ) // Unused. sink . writeShortLe ( 0 ) // Unused. sink . writeIntLe ( bmpHeaderSize + dibHeaderSize ) // Offset of pixel data. // DIB Header sink . writeIntLe ( dibHeaderSize ) sink . writeIntLe ( width ) sink . writeIntLe ( height ) sink . writeShortLe ( 1 ) // Color plane count. sink . writeShortLe ( bytesPerPixel * Byte . SIZE_BITS ) sink . writeIntLe ( 0 ) // No compression. sink . writeIntLe ( 16 ) // Size of bitmap data including padding. sink . writeIntLe ( 2835 ) // Horizontal print resolution in pixels/meter. (72 dpi). sink . writeIntLe ( 2835 ) // Vertical print resolution in pixels/meter. (72 dpi). sink . writeIntLe ( 0 ) // Palette color count. sink . writeIntLe ( 0 ) // 0 important colors. // Pixel data. for ( y in height - 1 downTo 0 ) { for ( x in 0 until width ) { sink . writeByte ( bitmap . blue ( x , y )) sink . writeByte ( bitmap . green ( x , y )) sink . writeByte ( bitmap . red ( x , y )) } // Padding for 4-byte alignment. for ( p in rowByteCountWithoutPadding until rowByteCount ) { sink . writeByte ( 0 ) } } } The trickiest part of this program is the format\u2019s required padding. The BMP format expects each row to begin on a 4-byte boundary so it is necessary to add zeros to maintain the alignment. Encoding other binary formats is usually quite similar. Some tips: Write tests with golden values! Confirming that your program emits the expected result can make debugging easier. Use Utf8.size() to compute the number of bytes of an encoded string. This is essential for length-prefixed formats. Use Float.floatToIntBits() and Double.doubleToLongBits() to encode floating point values.","title":"Write a binary file (Java/Kotlin)"},{"location":"#communicate-on-a-socket-javakotlin","text":"Sending and receiving data over the network is a bit like writing and reading files. We use BufferedSink to encode output and BufferedSource to decode input. Like files, network protocols can be text, binary, or a mix of both. But there are also some substantial differences between the network and the filesystem. With a file you\u2019re either reading or writing but with the network you can do both! Some protocols handle this by taking turns: write a request, read a response, repeat. You can implement this kind of protocol with a single thread. In other protocols you may read and write simultaneously. Typically you\u2019ll want one dedicated thread for reading. For writing you can use either a dedicated thread or use synchronized so that multiple threads can share a sink. Okio\u2019s streams are not safe for concurrent use. Sinks buffer outbound data to minimize I/O operations. This is efficient but it means you must manually call flush() to transmit data. Typically message-oriented protocols flush after each message. Note that Okio will automatically flush when the buffered data exceeds some threshold. This is intended to save memory and you shouldn\u2019t rely on it for interactive protocols. Okio builds on java.io.Socket for connectivity. Create your socket as a server or as a client, then use Okio.source(Socket) to read and Okio.sink(Socket) to write. These APIs also work with SSLSocket . You should use SSL unless you have a very good reason not to! Cancel a socket from any thread by calling Socket.close() ; this will cause its sources and sinks to immediately fail with an IOException . You can also configure timeouts for all socket operations. You don\u2019t need a reference to the socket to adjust timeouts: Source and Sink expose timeouts directly. This API works even if the streams are decorated. As a complete example of networking with Okio we wrote a basic SOCKS proxy server. Some highlights: Java Socket fromSocket = ... BufferedSource fromSource = Okio . buffer ( Okio . source ( fromSocket )); BufferedSink fromSink = Okio . buffer ( Okio . sink ( fromSocket )); Kotlin val fromSocket : Socket = ... val fromSource = fromSocket . source (). buffer () val fromSink = fromSocket . sink (). buffer () Creating sources and sinks for sockets is the same as creating them for files. Once you create a Source or Sink for a socket you must not use its InputStream or OutputStream , respectively. Java Buffer buffer = new Buffer (); for ( long byteCount ; ( byteCount = source . read ( buffer , 8192L )) != - 1 ; ) { sink . write ( buffer , byteCount ); sink . flush (); } Kotlin val buffer = Buffer () var byteCount : Long while ( source . read ( buffer , 8192L ). also { byteCount = it } != - 1L ) { sink . write ( buffer , byteCount ) sink . flush () } The above loop copies data from the source to the sink, flushing after each read. If we didn\u2019t need the flushing we could replace this loop with a single call to BufferedSink.writeAll(Source) . The 8192 argument to read() is the maximum number of bytes to read before returning. We could have passed any value here, but we like 8 KiB because that\u2019s the largest value Okio can do in a single system call. Most of the time application code doesn\u2019t need to deal with such limits! Java int addressType = fromSource . readByte () & 0xff ; int port = fromSource . readShort () & 0xffff ; Kotlin val addressType = fromSource . readByte (). toInt () and 0 xff val port = fromSource . readShort (). toInt () and 0 xffff Okio uses signed types like byte and short , but often protocols want unsigned values. The bitwise & operator is Java\u2019s preferred idiom to convert a signed value into an unsigned value. Here\u2019s a cheat sheet for bytes, shorts, and ints: Type Signed Range Unsigned Range Signed to Unsigned byte -128..127 0..255 int u = s & 0xff; short -32,768..32,767 0..65,535 int u = s & 0xffff; int -2,147,483,648..2,147,483,647 0..4,294,967,295 long u = s & 0xffffffffL; Java has no primitive type that can represent unsigned longs.","title":"Communicate on a Socket (Java/Kotlin)"},{"location":"#hashing-javakotlin","text":"We\u2019re bombarded by hashing in our lives as Java programmers. Early on we\u2019re introduced to the hashCode() method, something we know we need to override otherwise unforeseen bad things happen. Later we\u2019re shown LinkedHashMap and its friends. These build on that hashCode() method to organize data for fast retrieval. Elsewhere we have cryptographic hash functions. These get used all over the place. HTTPS certificates, Git commits, BitTorrent integrity checking, and Blockchain blocks all use cryptographic hashes. Good use of hashes can improve the performance, privacy, security, and simplicity of an application. Each cryptographic hash function accepts a variable-length stream of input bytes and produces a fixed-length byte string value called the \u201chash\u201d. Hash functions have these important qualities: Deterministic: each input always produces the same output. Uniform: each output byte string is equally likely. It is very difficult to find or create pairs of different inputs that yield the same output. This is called a \u201ccollision\u201d. Non-reversible: knowing an output doesn\u2019t help you to find the input. Note that if you know some possible inputs you can hash them to see if their hashes match. Well-known: the hash is implemented everywhere and rigorously understood. Good hash functions are very cheap to compute (dozens of microseconds) and expensive to reverse (quintillions of millenia). Steady advances in computing and mathematics have caused once-great hash functions to become inexpensive to reverse. When choosing a hash function, beware that not all are created equal! Okio supports these well-known cryptographic hash functions: MD5 : a 128-bit (16 byte) cryptographic hash. It is both insecure and obsolete because it is inexpensive to reverse! This hash is offered because it is popular and convenient for use in legacy systems that are not security-sensitive. SHA-1 : a 160-bit (20 byte) cryptographic hash. It was recently demonstrated that it is feasible to create SHA-1 collisions. Consider upgrading from SHA-1 to SHA-256. SHA-256 : a 256-bit (32 byte) cryptographic hash. SHA-256 is widely understood and expensive to reverse. This is the hash most systems should use. SHA-512 : a 512-bit (64 byte) cryptographic hash. It is expensive to reverse. Each hash creates a ByteString of the specified length. Use hex() to get the conventional human-readable form. Or leave it as a ByteString because that\u2019s a convenient model type! Okio can produce cryptographic hashes from byte strings: Java ByteString byteString = readByteString ( new File ( \"README.md\" )); System . out . println ( \" md5: \" + byteString . md5 (). hex ()); System . out . println ( \" sha1: \" + byteString . sha1 (). hex ()); System . out . println ( \"sha256: \" + byteString . sha256 (). hex ()); System . out . println ( \"sha512: \" + byteString . sha512 (). hex ()); Kotlin val byteString = readByteString ( File ( \"README.md\" )) println ( \" md5: \" + byteString . md5 (). hex ()) println ( \" sha1: \" + byteString . sha1 (). hex ()) println ( \" sha256: \" + byteString . sha256 (). hex ()) println ( \" sha512: \" + byteString . sha512 (). hex ()) From buffers: Java Buffer buffer = readBuffer ( new File ( \"README.md\" )); System . out . println ( \" md5: \" + buffer . md5 (). hex ()); System . out . println ( \" sha1: \" + buffer . sha1 (). hex ()); System . out . println ( \"sha256: \" + buffer . sha256 (). hex ()); System . out . println ( \"sha512: \" + buffer . sha512 (). hex ()); Kotlin val buffer = readBuffer ( File ( \"README.md\" )) println ( \" md5: \" + buffer . md5 (). hex ()) println ( \" sha1: \" + buffer . sha1 (). hex ()) println ( \" sha256: \" + buffer . sha256 (). hex ()) println ( \" sha512: \" + buffer . sha512 (). hex ()) While streaming from a source: Java try ( HashingSink hashingSink = HashingSink . sha256 ( Okio . blackhole ()); BufferedSource source = Okio . buffer ( Okio . source ( file ))) { source . readAll ( hashingSink ); System . out . println ( \"sha256: \" + hashingSink . hash (). hex ()); } Kotlin sha256 ( blackholeSink ()). use { hashingSink -> file . source (). buffer (). use { source -> source . readAll ( hashingSink ) println ( \" sha256: \" + hashingSink . hash . hex ()) } } While streaming to a sink: Java try ( HashingSink hashingSink = HashingSink . sha256 ( Okio . blackhole ()); BufferedSink sink = Okio . buffer ( hashingSink ); Source source = Okio . source ( file )) { sink . writeAll ( source ); sink . close (); // Emit anything buffered. System . out . println ( \"sha256: \" + hashingSink . hash (). hex ()); } Kotlin sha256 ( blackholeSink ()). use { hashingSink -> hashingSink . buffer (). use { sink -> file . source (). use { source -> sink . writeAll ( source ) sink . close () // Emit anything buffered. println ( \" sha256: \" + hashingSink . hash . hex ()) } } } Okio also supports HMAC (Hash Message Authentication Code) which combines a secret and a hash. Applications use HMAC for data integrity and authentication. Java ByteString secret = ByteString . decodeHex ( \"7065616e7574627574746572\" ); System . out . println ( \"hmacSha256: \" + byteString . hmacSha256 ( secret ). hex ()); Kotlin val secret = \"7065616e7574627574746572\" . decodeHex () println ( \"hmacSha256: \" + byteString . hmacSha256 ( secret ). hex ()) As with hashing, you can generate an HMAC from a ByteString , Buffer , HashingSource , and HashingSink . Note that Okio doesn\u2019t implement HMAC for MD5. Okio uses Java\u2019s java.security.MessageDigest for cryptographic hashes and javax.crypto.Mac for HMAC.","title":"Hashing (Java/Kotlin)"},{"location":"#releases","text":"Our change log has release history. implementation ( \"com.squareup.okio:okio:2.8.0\" ) Snapshot builds are also available repositories { maven { url = uri ( \"https://oss.sonatype.org/content/repositories/snapshots/\" ) } } dependencies { implementation ( \"com.squareup.okio:okio:2.8.0\" ) }","title":"Releases"},{"location":"#r8-proguard","text":"If you are using R8 or ProGuard add the options from this file .","title":"R8 / ProGuard"},{"location":"#license","text":"Copyright 2013 Square, Inc. Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.","title":"License"},{"location":"changelog/","text":"Change Log \u00b6 Version 2.8.0 \u00b6 2020-08-17 New: Upgrade to Kotlin 1.4.0. Version 2.7.0 \u00b6 2020-07-07 New: Pipe.cancel() causes in-progress and future reads and writes on the pipe to immediately fail with an IOException . The streams may still be canceled normally. New: Enlarge Okio\u2019s internal segment pool from a fixed 64 KiB total to 64 KiB per processor. For example, on an Intel i9 8-core/16-thread machine the segment pool now uses up to 1 MiB of memory. New: Migrate from synchronized to lock-free when accessing the segment pool. Combined with the change above we saw throughput increase 3x on a synthetic benchmark designed to create contention. Version 2.6.0 \u00b6 2020-04-22 New: InflaterSource.readOrInflate() is like InflaterSource.read() , except it will return 0 if consuming deflated bytes from the underlying stream did not produce new inflated bytes. Version 2.5.0 \u00b6 2020-03-20 New: Upgrade to Kotlin 1.3.70. Version 2.4.3 \u00b6 2019-12-20 New: Upgrade to Kotlin 1.3.61. Version 2.4.2 \u00b6 2019-12-11 Fix: Don\u2019t crash when an InputStream source is exhausted exactly at a buffer segment boundary. We had a bug where a sequence of reads could violate a buffer\u2019s invariants, and this could result in a crash when subsequent reads encountered an unexpected empty segment. Version 1.17.5 \u00b6 2019-12-11 Fix: Don\u2019t crash when an InputStream source is exhausted exactly at a buffer segment boundary. We had a bug where a sequence of reads could violate a buffer\u2019s invariants, and this could result in a crash when subsequent reads encountered an unexpected empty segment. Version 2.4.1 \u00b6 2019-10-04 Fix: Don\u2019t cache hash code and UTF-8 string in ByteString on Kotlin/Native which prevented freezing. Version 2.4.0 \u00b6 2019-08-26 New: Upgrade to Kotlin 1.3.50. Version 2.3.0 \u00b6 2019-07-29 This release changes our build from Kotlin-JVM to Kotlin-multiplatform (which includes JVM). Both native and JavaScript platforms are unstable preview releases and subject to backwards-incompatible changes in forthcoming releases. To try Okio in a multiplatform project use this Maven coordinate: api ( ' com . squareup . okio : okio - multiplatform : 2.3 . 0 ' ) You\u2019ll also need to enable Gradle metadata in your project\u2019s settings. The artifact name for JVM projects has not changed. New: Upgrade to Kotlin 1.3.40. Fix: Use Gradle api instead of implementation for the kotlin-stdlib dependency. Fix: Don\u2019t block unless strictly necessary in BufferedSource.peek() . Version 1.17.4 \u00b6 2019-04-29 Fix: Don\u2019t block unless strictly necessary in BufferedSource.peek() . Version 2.2.2 \u00b6 2019-01-28 Fix: Make Pipe.fold() close the underlying sink when necessary. Version 1.17.3 \u00b6 2019-01-28 Fix: Make Pipe.fold() close the underlying sink when necessary. Version 1.17.2 \u00b6 2019-01-17 Fix: Make Pipe.fold() flush the underlying sink. Version 2.2.1 \u00b6 2019-01-17 Fix: Make Pipe.fold() flush the underlying sink. Version 2.2.0 \u00b6 2019-01-16 New: Throttler limits sources and sinks to a maximum desired throughput. Multiple sources and sinks can be attached to the same throttler and their combined throughput will not exceed the desired throughput. Multiple throttlers can also be used on the same source or sink and they will all be honored. New: Pipe.fold() replaces the actively-readable Source with a passively-writable Sink . This can be used to forward one sink to a target that is initially undetermined. New: Optimize performance of ByteStrings created with Buffer.snapshot() . Version 1.17.1 \u00b6 2019-01-16 Fix: Make the newly-backported Pipe.fold() public. Version 1.17.0 \u00b6 2019-01-16 New: Backport Pipe.fold() to Okio 1.x. Version 1.16.0 \u00b6 2018-10-08 New: Backport BufferedSource.peek() and BufferedSource.getBuffer() to Okio 1.x. Fix: Enforce timeouts when closing AsyncTimeout sources. Version 2.1.0 \u00b6 2018-09-22 New: BufferedSource.peek() returns another BufferedSource that reads ahead on the current source. Use this to process the same data multiple times. New: Deprecate BufferedSource.buffer() , replacing it with either BufferedSource.getBuffer() (in Java) or BufferedSource.buffer (in Kotlin). We have done likewise for BufferedSink . When we introduced the new extension method Source.buffer() in Okio 2.0 we inadvertently collided with an existing method. This fixes that. New: Improve performance of Buffer.writeUtf8() . This comes alongside initial implementation of UTF-8 encoding and decoding in JavaScript which uses XOR masks for great performance. Version 2.0.0 \u00b6 2018-08-27 This release commits to a stable 2.0 API. Read the 2.0.0-RC1 changes for advice on upgrading from 1.x to 2.x. We\u2019ve also added APIs to ease migration for Kotlin users. They use Kotlin\u2019s @Deprecated annotation to help you change call sites from the 1.x style to the 2.x style. Version 2.0.0-RC1 \u00b6 2018-07-26 Okio 2 is a major release that upgrades the library\u2019s implementation language from Java to Kotlin. Okio 2.x is binary-compatible with Okio 1.x and does not change any behavior. Classes and .jar files compiled against 1.x can be used with 2.x without recompiling. Okio 2.x is .java source compatible with Okio 1.x in all but one corner case. In Okio 1.x Buffer would throw an unchecked IllegalStateException when attempting to read more bytes than available. Okio 2.x now throws a checked EOFException in this case. This is now consistent with the behavior of its BufferedSource interface. Java callers that don\u2019t already catch IOException will now need to. Okio 2.x is .kt source-incompatible with Okio 1.x. This release adopts Kotlin idioms where they are available. Java Kotlin Idiom Buffer.getByte() operator fun Buffer.get() operator function Buffer.size() val Buffer.size val ByteString.decodeBase64(String) fun String.decodeBase64() extension function ByteString.decodeHex(String) fun String.decodeHex() extension function ByteString.encodeString(String, Charset) fun String.encode(Charset) extension function ByteString.encodeUtf8(String) fun String.encodeUtf8() extension function ByteString.getByte() operator fun ByteString.get() operator function ByteString.of(ByteBuffer) fun ByteBuffer.toByteString() extension function ByteString.of(byte[], int, int) fun ByteArray.toByteString() extension function ByteString.read(InputStream, int) fun InputStream.readByteString(Int) extension function ByteString.size() val ByteString.size val DeflaterSink(Sink) fun Sink.deflater() extension function ForwardingSink.delegate() val ForwardingSink.delegate val ForwardingSource.delegate() val ForwardingSource.delegate val GzipSink(Sink, Deflater) fun Sink.gzip() extension function GzipSink.deflater() val GzipSink.deflater val GzipSource(Source) fun Source.gzip() extension function HashingSink.hash() val HashingSink.hash val HashingSource.hash() val HashingSource.hash val InflaterSink(Source) fun Source.inflater() extension function Okio.appendingSink(File) fun File.appendingSink() extension function Okio.blackhole() fun blackholeSink() top level function Okio.buffer(Sink) fun Sink.buffer() extension function Okio.buffer(Source) fun Source.buffer() extension function Okio.sink(File) fun File.sink() extension function Okio.sink(OutputStream) fun OutputStream.sink() extension function Okio.sink(Path) fun Path.sink() extension function Okio.sink(Socket) fun Socket.sink() extension function Okio.source(File) fun File.source() extension function Okio.source(InputStream) fun InputStream.source() extension function Okio.source(Path) fun Path.source() extension function Okio.source(Socket) fun Socket.source() extension function Pipe.sink() val Pipe.sink val Pipe.source() val Pipe.source val Utf8.size(String) fun String.utf8Size() extension function Okio 2.x has similar performance to Okio 1.x. We benchmarked both versions to find potential performance regressions. We found one regression and fixed it: we were using == instead of === . Other changes in this release: New: Add a dependency on kotlin-stdlib. Okio\u2019s transitive dependencies grow from none in 1.x to three in 2.x. These are kotlin-stdlib (939 KiB), kotlin-stdlib-common (104 KiB), and JetBrains\u2019 annotations (17 KiB). New: Change Okio to build with Gradle instead of Maven. Version 1.15.0 \u00b6 2018-07-18 New: Trie-based Buffer.select() . This improves performance when selecting among large lists of options. Fix: Retain interrupted state when throwing InterruptedIOException . Version 1.14.0 \u00b6 2018-02-11 New: Buffer.UnsafeCursor provides direct access to Okio internals. This API is like Okio\u2019s version of Java reflection: it\u2019s a very powerful API that can be used for great things and dangerous things alike. The documentation is extensive and anyone using it should review it carefully before proceeding! New: Change BufferedSource to implement java.nio.ReadableByteChannel and BufferedSink to implement java.nio.WritableByteChannel . Now it\u2019s a little easier to interop between Okio and NIO. New: Automatic module name of okio for use with the Java Platform Module System. New: Optimize Buffer.getByte() to search backwards when doing so will be more efficient. Fix: Honor the requested byte count in InflaterSource . Previously this class could return more bytes than requested. Fix: Improve a performance bug in AsyncTimeout.sink().write() . Version 1.13.0 \u00b6 2017-05-12 Okio now uses @Nullable to annotate all possibly-null values. We\u2019ve added a compile-time dependency on the JSR 305 annotations. This is a provided dependency and does not need to be included in your build configuration, .jar file, or .apk . We use @ParametersAreNonnullByDefault and all parameters and return types are never null unless explicitly annotated @Nullable . Warning: this release is source-incompatible for Kotlin users. Nullability was previously ambiguous and lenient but now the compiler will enforce strict null checks. Version 1.12.0 \u00b6 2017-04-11 Fix: Change Pipe\u2019s sink.flush() to not block. Previously closing a pipe\u2019s sink would block until the source had been exhausted. In practice this blocked the caller for no benefit. Fix: Change writeUtf8CodePoint() to emit ? for partial surrogates. The previous behavior was inconsistent: given a malformed string with a partial surrogate, writeUtf8() emitted ? but writeUtf8CodePoint() threw an IllegalArgumentException . Most applications will never encounter partial surrogates, but for those that do this behavior was unexpected. New: Allow length of readUtf8LineStrict() to be limited. New: Utf8.size() method to get the number of bytes required to encode a string as UTF-8. This may be useful for length-prefixed encodings. New: SHA-512 hash and HMAC APIs. Version 1.11.0 \u00b6 2016-10-11 Fix: The four-argument overload of Buffer.writeString() had a major bug where it didn\u2019t respect offsets if the specified charset was UTF-8. This was because our short-circuit optimization omitted necessary offset parameters. New: HMAC support in HashingSource , HashingSink , ByteString , and Buffer . This makes it easy to create a keyed-hash message authentication code (HMAC) wherever your data is. Unlike the other hashes, HMAC uses a ByteString secret key for authentication. New: ByteString.of(ByteBuffer) makes it easier to mix NIO with Okio. Version 1.10.0 \u00b6 2016-08-28 Fix: Support reading files larger than 2 GiB with GzipSource . Previously attempting to decompress such files would fail due to an overflow when validating the total length. Fix: Exit the watchdog thread after being idle for 60 seconds. This should make it possible for class unloaders to fully unload Okio. New: Okio.blackhole() returns a sink where all bytes written are discarded. This is Okio\u2019s equivalent of /dev/null . New: Encode a string with any charset using ByteString.encodeString() and decode strings in any charset using ByteString.string() . Most applications should prefer ByteString.encodeUtf8() and ByteString.utf8() unless it\u2019s necessary to support a legacy charset. New: GzipSink.deflater() makes it possible to configure the compression level. Version 1.9.0 \u00b6 2016-07-01 New: Pipe makes it easy to connect a producer thread to a consumer thread. Reads block until data is available to read. Writes block if the pipe\u2019s is full. Both sources and sinks support timeouts. New: BufferedSource.rangeEquals() makes it easy to compare a range in a stream to an expected value. This does the right thing: it blocks to load the data required return a definitive result. But it won\u2019t block unnecessarily. New: Timeout.waitUntilNotified() makes it possible to use nice timeout abstractions on Java\u2019s built-in wait/notify primitives. Fix: Don\u2019t return incorrect results when HashingSource does large reads. There was a bug where it wasn\u2019t traversing through the segments of the buffer being hashed. This means that HashingSource was returning incorrect answers for any writes that spanned multiple segment boundaries. Version 1.8.0 \u00b6 2016-05-02 New: BufferedSource.select(Options) API for reading one of a set of expected values. New: Make ByteString.toString() and Buffer.toString() friendlier. These methods return text if the byte string is valid UTF-8. New: APIs to match byte strings: indexOf() , startsWith() , and endsWith() . Version 1.7.0 \u00b6 2016-04-10 New: Change the segment size to 8 KiB. This has been reported to dramatically improve performance in some applications. New: md5() , sha1() , and sha256() methods on Buffer . Also add a sha1() method on ByteString for symmetry. New: HashingSource and HashingSink . These classes are Okio\u2019s equivalent to the JDK\u2019s DigestInputStream and DigestOutputStream . They offer convenient md5() , sha1() , and sha256() factory methods to avoid an impossible NoSuchAlgorithmException . New: ByteString.asByteBuffer() . Fix: Limit snapshot byte strings to requested size. Fix: Change write timeouts to have a maximum write size. Previously large writes could easly suffer timeouts because the entire write was subject to a single timeout. Fix: Recover from EBADF failures, which could be triggered by asynchronously closing a stream on older versions of Android. Fix: Don\u2019t share segments if doing so only saves a small copy. This should improve performance for all applications. Fix: Optimize BufferedSource.indexOfElement() and indexOf(ByteString) . Previously this method had a bug that caused it to be very slow on large buffers. Version 1.6.0 \u00b6 2015-08-25 New: BufferedSource.indexOf(ByteString) searches a source for the next occurrence of a byte string. Fix: Recover from unexpected AssertionError thrown on Android 4.2.2 and earlier when asynchronously closing a socket. Version 1.5.0 \u00b6 2015-06-19 Sockets streams now throw SocketTimeoutException . This builds on new extension point in AsyncTimeout to customize the exception when a timeout occurs. New: ByteString now implements Comparable . The comparison sorts bytes as unsigned: {@code ff} sorts after {@code 00}. Version 1.4.0 \u00b6 2015-05-16 Timeout exception changed. Previously Timeout.throwIfReached() would throw InterruptedIOException on thread interruption, and IOException if the deadline was reached. Now it throws InterruptedIOException in both cases. Fix: throw EOFException when attempting to read digits from an empty source. Previously this would crash with an unchecked exception. New: APIs to read and write UTF-8 code points without allocating strings. New: BufferedSink can now write substrings directly, potentially saving an allocation for some callers. New: ForwardingTimeout class. Version 1.3.0 \u00b6 2015-03-16 New: Read and write signed decimal and unsigned hexadecimal values in BufferedSource and BufferedSink . Unlike the alternatives, these methods don\u2019t do any memory allocations! New: Segment sharing. This improves the runtime of operations like Buffer.clone() and Buffer.copyTo() by sharing underlying segments between buffers. New: Buffer.snapshot() returns an immutable snapshot of a buffer as a ByteString . This builds on segment sharing so that snapshots are shallow, immutable copies. New: ByteString.rangeEquals() . New: ByteString.md5() and ByteString.sha256() . New: ByteString.base64Url() returns URL-safe Base64. The existing decoding method has been extended to support URL-safe Base64 input. New: ByteString.substring() returns a prefix, infix, or suffix. New: Sink now implements java.io.Flushable . Fix: Buffer.write(Source, long) now always writes fully. The previous behavior would return as soon as any data had been written; this was inconsistent with all other write() methods in the API. Fix: don\u2019t leak empty segments in DeflaterSink and InflaterSource. (This was unlikely to cause problems in practice.) Version 1.2.0 \u00b6 2014-12-30 Fix: Okio.buffer() always buffers for better predictability. Fix: Provide context when readUtf8LineStrict() throws. Fix: Buffers do not call through the Source on zero-byte writes. Version 1.1.0 \u00b6 2014-12-11 Do UTF-8 encoding natively for a performance increase, particularly on Android. New APIs: BufferedSink.emit() , BufferedSource.request() and BufferedSink.indexOfElement() . Fixed a performance bug in Buffer.indexOf() Version 1.0.1 \u00b6 2014-08-08 Added read(byte[]) , read(byte[], offset, byteCount) , and void readFully(byte[]) to BufferedSource . Refined declared checked exceptions on Buffer methods. Version 1.0.0 \u00b6 2014-05-23 Bumped release version. No other changes! Version 0.9.0 \u00b6 2014-05-03 Use 0 as a sentinel for no timeout. Make AsyncTimeout public. Remove checked exception from Buffer.readByteArray. Version 0.8.0 \u00b6 2014-04-24 Eagerly verify preconditions on public APIs. Quick return on Buffer instance equivalence. Add delegate types for Sink and Source. Small changes to the way deadlines are managed. Add append variant of Okio.sink for File. Methods to exhaust BufferedSource to byte[] and ByteString. Version 0.7.0 \u00b6 2014-04-18 Don\u2019t use getters in timeout. Use the watchdog to interrupt sockets that have reached deadlines. Add java.io and java.nio file source/sink helpers. Version 0.6.1 \u00b6 2014-04-17 Methods to read a buffered source fully in UTF-8 or supplied charset. API to read a byte[] directly. New methods to move all data from a source to a sink. Fix a bug on input stream exhaustion. Version 0.6.0 \u00b6 2014-04-15 Make ByteString serializable. New API: ByteString.of(byte[] data, int offset, int byteCount) New API: stream-based copy, write, and read helpers. Version 0.5.0 \u00b6 2014-04-08 Initial public release. Imported from OkHttp.","title":"Change Log"},{"location":"changelog/#change-log","text":"","title":"Change Log"},{"location":"changelog/#version-280","text":"2020-08-17 New: Upgrade to Kotlin 1.4.0.","title":"Version 2.8.0"},{"location":"changelog/#version-270","text":"2020-07-07 New: Pipe.cancel() causes in-progress and future reads and writes on the pipe to immediately fail with an IOException . The streams may still be canceled normally. New: Enlarge Okio\u2019s internal segment pool from a fixed 64 KiB total to 64 KiB per processor. For example, on an Intel i9 8-core/16-thread machine the segment pool now uses up to 1 MiB of memory. New: Migrate from synchronized to lock-free when accessing the segment pool. Combined with the change above we saw throughput increase 3x on a synthetic benchmark designed to create contention.","title":"Version 2.7.0"},{"location":"changelog/#version-260","text":"2020-04-22 New: InflaterSource.readOrInflate() is like InflaterSource.read() , except it will return 0 if consuming deflated bytes from the underlying stream did not produce new inflated bytes.","title":"Version 2.6.0"},{"location":"changelog/#version-250","text":"2020-03-20 New: Upgrade to Kotlin 1.3.70.","title":"Version 2.5.0"},{"location":"changelog/#version-243","text":"2019-12-20 New: Upgrade to Kotlin 1.3.61.","title":"Version 2.4.3"},{"location":"changelog/#version-242","text":"2019-12-11 Fix: Don\u2019t crash when an InputStream source is exhausted exactly at a buffer segment boundary. We had a bug where a sequence of reads could violate a buffer\u2019s invariants, and this could result in a crash when subsequent reads encountered an unexpected empty segment.","title":"Version 2.4.2"},{"location":"changelog/#version-1175","text":"2019-12-11 Fix: Don\u2019t crash when an InputStream source is exhausted exactly at a buffer segment boundary. We had a bug where a sequence of reads could violate a buffer\u2019s invariants, and this could result in a crash when subsequent reads encountered an unexpected empty segment.","title":"Version 1.17.5"},{"location":"changelog/#version-241","text":"2019-10-04 Fix: Don\u2019t cache hash code and UTF-8 string in ByteString on Kotlin/Native which prevented freezing.","title":"Version 2.4.1"},{"location":"changelog/#version-240","text":"2019-08-26 New: Upgrade to Kotlin 1.3.50.","title":"Version 2.4.0"},{"location":"changelog/#version-230","text":"2019-07-29 This release changes our build from Kotlin-JVM to Kotlin-multiplatform (which includes JVM). Both native and JavaScript platforms are unstable preview releases and subject to backwards-incompatible changes in forthcoming releases. To try Okio in a multiplatform project use this Maven coordinate: api ( ' com . squareup . okio : okio - multiplatform : 2.3 . 0 ' ) You\u2019ll also need to enable Gradle metadata in your project\u2019s settings. The artifact name for JVM projects has not changed. New: Upgrade to Kotlin 1.3.40. Fix: Use Gradle api instead of implementation for the kotlin-stdlib dependency. Fix: Don\u2019t block unless strictly necessary in BufferedSource.peek() .","title":"Version 2.3.0"},{"location":"changelog/#version-1174","text":"2019-04-29 Fix: Don\u2019t block unless strictly necessary in BufferedSource.peek() .","title":"Version 1.17.4"},{"location":"changelog/#version-222","text":"2019-01-28 Fix: Make Pipe.fold() close the underlying sink when necessary.","title":"Version 2.2.2"},{"location":"changelog/#version-1173","text":"2019-01-28 Fix: Make Pipe.fold() close the underlying sink when necessary.","title":"Version 1.17.3"},{"location":"changelog/#version-1172","text":"2019-01-17 Fix: Make Pipe.fold() flush the underlying sink.","title":"Version 1.17.2"},{"location":"changelog/#version-221","text":"2019-01-17 Fix: Make Pipe.fold() flush the underlying sink.","title":"Version 2.2.1"},{"location":"changelog/#version-220","text":"2019-01-16 New: Throttler limits sources and sinks to a maximum desired throughput. Multiple sources and sinks can be attached to the same throttler and their combined throughput will not exceed the desired throughput. Multiple throttlers can also be used on the same source or sink and they will all be honored. New: Pipe.fold() replaces the actively-readable Source with a passively-writable Sink . This can be used to forward one sink to a target that is initially undetermined. New: Optimize performance of ByteStrings created with Buffer.snapshot() .","title":"Version 2.2.0"},{"location":"changelog/#version-1171","text":"2019-01-16 Fix: Make the newly-backported Pipe.fold() public.","title":"Version 1.17.1"},{"location":"changelog/#version-1170","text":"2019-01-16 New: Backport Pipe.fold() to Okio 1.x.","title":"Version 1.17.0"},{"location":"changelog/#version-1160","text":"2018-10-08 New: Backport BufferedSource.peek() and BufferedSource.getBuffer() to Okio 1.x. Fix: Enforce timeouts when closing AsyncTimeout sources.","title":"Version 1.16.0"},{"location":"changelog/#version-210","text":"2018-09-22 New: BufferedSource.peek() returns another BufferedSource that reads ahead on the current source. Use this to process the same data multiple times. New: Deprecate BufferedSource.buffer() , replacing it with either BufferedSource.getBuffer() (in Java) or BufferedSource.buffer (in Kotlin). We have done likewise for BufferedSink . When we introduced the new extension method Source.buffer() in Okio 2.0 we inadvertently collided with an existing method. This fixes that. New: Improve performance of Buffer.writeUtf8() . This comes alongside initial implementation of UTF-8 encoding and decoding in JavaScript which uses XOR masks for great performance.","title":"Version 2.1.0"},{"location":"changelog/#version-200","text":"2018-08-27 This release commits to a stable 2.0 API. Read the 2.0.0-RC1 changes for advice on upgrading from 1.x to 2.x. We\u2019ve also added APIs to ease migration for Kotlin users. They use Kotlin\u2019s @Deprecated annotation to help you change call sites from the 1.x style to the 2.x style.","title":"Version 2.0.0"},{"location":"changelog/#version-200-rc1","text":"2018-07-26 Okio 2 is a major release that upgrades the library\u2019s implementation language from Java to Kotlin. Okio 2.x is binary-compatible with Okio 1.x and does not change any behavior. Classes and .jar files compiled against 1.x can be used with 2.x without recompiling. Okio 2.x is .java source compatible with Okio 1.x in all but one corner case. In Okio 1.x Buffer would throw an unchecked IllegalStateException when attempting to read more bytes than available. Okio 2.x now throws a checked EOFException in this case. This is now consistent with the behavior of its BufferedSource interface. Java callers that don\u2019t already catch IOException will now need to. Okio 2.x is .kt source-incompatible with Okio 1.x. This release adopts Kotlin idioms where they are available. Java Kotlin Idiom Buffer.getByte() operator fun Buffer.get() operator function Buffer.size() val Buffer.size val ByteString.decodeBase64(String) fun String.decodeBase64() extension function ByteString.decodeHex(String) fun String.decodeHex() extension function ByteString.encodeString(String, Charset) fun String.encode(Charset) extension function ByteString.encodeUtf8(String) fun String.encodeUtf8() extension function ByteString.getByte() operator fun ByteString.get() operator function ByteString.of(ByteBuffer) fun ByteBuffer.toByteString() extension function ByteString.of(byte[], int, int) fun ByteArray.toByteString() extension function ByteString.read(InputStream, int) fun InputStream.readByteString(Int) extension function ByteString.size() val ByteString.size val DeflaterSink(Sink) fun Sink.deflater() extension function ForwardingSink.delegate() val ForwardingSink.delegate val ForwardingSource.delegate() val ForwardingSource.delegate val GzipSink(Sink, Deflater) fun Sink.gzip() extension function GzipSink.deflater() val GzipSink.deflater val GzipSource(Source) fun Source.gzip() extension function HashingSink.hash() val HashingSink.hash val HashingSource.hash() val HashingSource.hash val InflaterSink(Source) fun Source.inflater() extension function Okio.appendingSink(File) fun File.appendingSink() extension function Okio.blackhole() fun blackholeSink() top level function Okio.buffer(Sink) fun Sink.buffer() extension function Okio.buffer(Source) fun Source.buffer() extension function Okio.sink(File) fun File.sink() extension function Okio.sink(OutputStream) fun OutputStream.sink() extension function Okio.sink(Path) fun Path.sink() extension function Okio.sink(Socket) fun Socket.sink() extension function Okio.source(File) fun File.source() extension function Okio.source(InputStream) fun InputStream.source() extension function Okio.source(Path) fun Path.source() extension function Okio.source(Socket) fun Socket.source() extension function Pipe.sink() val Pipe.sink val Pipe.source() val Pipe.source val Utf8.size(String) fun String.utf8Size() extension function Okio 2.x has similar performance to Okio 1.x. We benchmarked both versions to find potential performance regressions. We found one regression and fixed it: we were using == instead of === . Other changes in this release: New: Add a dependency on kotlin-stdlib. Okio\u2019s transitive dependencies grow from none in 1.x to three in 2.x. These are kotlin-stdlib (939 KiB), kotlin-stdlib-common (104 KiB), and JetBrains\u2019 annotations (17 KiB). New: Change Okio to build with Gradle instead of Maven.","title":"Version 2.0.0-RC1"},{"location":"changelog/#version-1150","text":"2018-07-18 New: Trie-based Buffer.select() . This improves performance when selecting among large lists of options. Fix: Retain interrupted state when throwing InterruptedIOException .","title":"Version 1.15.0"},{"location":"changelog/#version-1140","text":"2018-02-11 New: Buffer.UnsafeCursor provides direct access to Okio internals. This API is like Okio\u2019s version of Java reflection: it\u2019s a very powerful API that can be used for great things and dangerous things alike. The documentation is extensive and anyone using it should review it carefully before proceeding! New: Change BufferedSource to implement java.nio.ReadableByteChannel and BufferedSink to implement java.nio.WritableByteChannel . Now it\u2019s a little easier to interop between Okio and NIO. New: Automatic module name of okio for use with the Java Platform Module System. New: Optimize Buffer.getByte() to search backwards when doing so will be more efficient. Fix: Honor the requested byte count in InflaterSource . Previously this class could return more bytes than requested. Fix: Improve a performance bug in AsyncTimeout.sink().write() .","title":"Version 1.14.0"},{"location":"changelog/#version-1130","text":"2017-05-12 Okio now uses @Nullable to annotate all possibly-null values. We\u2019ve added a compile-time dependency on the JSR 305 annotations. This is a provided dependency and does not need to be included in your build configuration, .jar file, or .apk . We use @ParametersAreNonnullByDefault and all parameters and return types are never null unless explicitly annotated @Nullable . Warning: this release is source-incompatible for Kotlin users. Nullability was previously ambiguous and lenient but now the compiler will enforce strict null checks.","title":"Version 1.13.0"},{"location":"changelog/#version-1120","text":"2017-04-11 Fix: Change Pipe\u2019s sink.flush() to not block. Previously closing a pipe\u2019s sink would block until the source had been exhausted. In practice this blocked the caller for no benefit. Fix: Change writeUtf8CodePoint() to emit ? for partial surrogates. The previous behavior was inconsistent: given a malformed string with a partial surrogate, writeUtf8() emitted ? but writeUtf8CodePoint() threw an IllegalArgumentException . Most applications will never encounter partial surrogates, but for those that do this behavior was unexpected. New: Allow length of readUtf8LineStrict() to be limited. New: Utf8.size() method to get the number of bytes required to encode a string as UTF-8. This may be useful for length-prefixed encodings. New: SHA-512 hash and HMAC APIs.","title":"Version 1.12.0"},{"location":"changelog/#version-1110","text":"2016-10-11 Fix: The four-argument overload of Buffer.writeString() had a major bug where it didn\u2019t respect offsets if the specified charset was UTF-8. This was because our short-circuit optimization omitted necessary offset parameters. New: HMAC support in HashingSource , HashingSink , ByteString , and Buffer . This makes it easy to create a keyed-hash message authentication code (HMAC) wherever your data is. Unlike the other hashes, HMAC uses a ByteString secret key for authentication. New: ByteString.of(ByteBuffer) makes it easier to mix NIO with Okio.","title":"Version 1.11.0"},{"location":"changelog/#version-1100","text":"2016-08-28 Fix: Support reading files larger than 2 GiB with GzipSource . Previously attempting to decompress such files would fail due to an overflow when validating the total length. Fix: Exit the watchdog thread after being idle for 60 seconds. This should make it possible for class unloaders to fully unload Okio. New: Okio.blackhole() returns a sink where all bytes written are discarded. This is Okio\u2019s equivalent of /dev/null . New: Encode a string with any charset using ByteString.encodeString() and decode strings in any charset using ByteString.string() . Most applications should prefer ByteString.encodeUtf8() and ByteString.utf8() unless it\u2019s necessary to support a legacy charset. New: GzipSink.deflater() makes it possible to configure the compression level.","title":"Version 1.10.0"},{"location":"changelog/#version-190","text":"2016-07-01 New: Pipe makes it easy to connect a producer thread to a consumer thread. Reads block until data is available to read. Writes block if the pipe\u2019s is full. Both sources and sinks support timeouts. New: BufferedSource.rangeEquals() makes it easy to compare a range in a stream to an expected value. This does the right thing: it blocks to load the data required return a definitive result. But it won\u2019t block unnecessarily. New: Timeout.waitUntilNotified() makes it possible to use nice timeout abstractions on Java\u2019s built-in wait/notify primitives. Fix: Don\u2019t return incorrect results when HashingSource does large reads. There was a bug where it wasn\u2019t traversing through the segments of the buffer being hashed. This means that HashingSource was returning incorrect answers for any writes that spanned multiple segment boundaries.","title":"Version 1.9.0"},{"location":"changelog/#version-180","text":"2016-05-02 New: BufferedSource.select(Options) API for reading one of a set of expected values. New: Make ByteString.toString() and Buffer.toString() friendlier. These methods return text if the byte string is valid UTF-8. New: APIs to match byte strings: indexOf() , startsWith() , and endsWith() .","title":"Version 1.8.0"},{"location":"changelog/#version-170","text":"2016-04-10 New: Change the segment size to 8 KiB. This has been reported to dramatically improve performance in some applications. New: md5() , sha1() , and sha256() methods on Buffer . Also add a sha1() method on ByteString for symmetry. New: HashingSource and HashingSink . These classes are Okio\u2019s equivalent to the JDK\u2019s DigestInputStream and DigestOutputStream . They offer convenient md5() , sha1() , and sha256() factory methods to avoid an impossible NoSuchAlgorithmException . New: ByteString.asByteBuffer() . Fix: Limit snapshot byte strings to requested size. Fix: Change write timeouts to have a maximum write size. Previously large writes could easly suffer timeouts because the entire write was subject to a single timeout. Fix: Recover from EBADF failures, which could be triggered by asynchronously closing a stream on older versions of Android. Fix: Don\u2019t share segments if doing so only saves a small copy. This should improve performance for all applications. Fix: Optimize BufferedSource.indexOfElement() and indexOf(ByteString) . Previously this method had a bug that caused it to be very slow on large buffers.","title":"Version 1.7.0"},{"location":"changelog/#version-160","text":"2015-08-25 New: BufferedSource.indexOf(ByteString) searches a source for the next occurrence of a byte string. Fix: Recover from unexpected AssertionError thrown on Android 4.2.2 and earlier when asynchronously closing a socket.","title":"Version 1.6.0"},{"location":"changelog/#version-150","text":"2015-06-19 Sockets streams now throw SocketTimeoutException . This builds on new extension point in AsyncTimeout to customize the exception when a timeout occurs. New: ByteString now implements Comparable . The comparison sorts bytes as unsigned: {@code ff} sorts after {@code 00}.","title":"Version 1.5.0"},{"location":"changelog/#version-140","text":"2015-05-16 Timeout exception changed. Previously Timeout.throwIfReached() would throw InterruptedIOException on thread interruption, and IOException if the deadline was reached. Now it throws InterruptedIOException in both cases. Fix: throw EOFException when attempting to read digits from an empty source. Previously this would crash with an unchecked exception. New: APIs to read and write UTF-8 code points without allocating strings. New: BufferedSink can now write substrings directly, potentially saving an allocation for some callers. New: ForwardingTimeout class.","title":"Version 1.4.0"},{"location":"changelog/#version-130","text":"2015-03-16 New: Read and write signed decimal and unsigned hexadecimal values in BufferedSource and BufferedSink . Unlike the alternatives, these methods don\u2019t do any memory allocations! New: Segment sharing. This improves the runtime of operations like Buffer.clone() and Buffer.copyTo() by sharing underlying segments between buffers. New: Buffer.snapshot() returns an immutable snapshot of a buffer as a ByteString . This builds on segment sharing so that snapshots are shallow, immutable copies. New: ByteString.rangeEquals() . New: ByteString.md5() and ByteString.sha256() . New: ByteString.base64Url() returns URL-safe Base64. The existing decoding method has been extended to support URL-safe Base64 input. New: ByteString.substring() returns a prefix, infix, or suffix. New: Sink now implements java.io.Flushable . Fix: Buffer.write(Source, long) now always writes fully. The previous behavior would return as soon as any data had been written; this was inconsistent with all other write() methods in the API. Fix: don\u2019t leak empty segments in DeflaterSink and InflaterSource. (This was unlikely to cause problems in practice.)","title":"Version 1.3.0"},{"location":"changelog/#version-120","text":"2014-12-30 Fix: Okio.buffer() always buffers for better predictability. Fix: Provide context when readUtf8LineStrict() throws. Fix: Buffers do not call through the Source on zero-byte writes.","title":"Version 1.2.0"},{"location":"changelog/#version-110","text":"2014-12-11 Do UTF-8 encoding natively for a performance increase, particularly on Android. New APIs: BufferedSink.emit() , BufferedSource.request() and BufferedSink.indexOfElement() . Fixed a performance bug in Buffer.indexOf()","title":"Version 1.1.0"},{"location":"changelog/#version-101","text":"2014-08-08 Added read(byte[]) , read(byte[], offset, byteCount) , and void readFully(byte[]) to BufferedSource . Refined declared checked exceptions on Buffer methods.","title":"Version 1.0.1"},{"location":"changelog/#version-100","text":"2014-05-23 Bumped release version. No other changes!","title":"Version 1.0.0"},{"location":"changelog/#version-090","text":"2014-05-03 Use 0 as a sentinel for no timeout. Make AsyncTimeout public. Remove checked exception from Buffer.readByteArray.","title":"Version 0.9.0"},{"location":"changelog/#version-080","text":"2014-04-24 Eagerly verify preconditions on public APIs. Quick return on Buffer instance equivalence. Add delegate types for Sink and Source. Small changes to the way deadlines are managed. Add append variant of Okio.sink for File. Methods to exhaust BufferedSource to byte[] and ByteString.","title":"Version 0.8.0"},{"location":"changelog/#version-070","text":"2014-04-18 Don\u2019t use getters in timeout. Use the watchdog to interrupt sockets that have reached deadlines. Add java.io and java.nio file source/sink helpers.","title":"Version 0.7.0"},{"location":"changelog/#version-061","text":"2014-04-17 Methods to read a buffered source fully in UTF-8 or supplied charset. API to read a byte[] directly. New methods to move all data from a source to a sink. Fix a bug on input stream exhaustion.","title":"Version 0.6.1"},{"location":"changelog/#version-060","text":"2014-04-15 Make ByteString serializable. New API: ByteString.of(byte[] data, int offset, int byteCount) New API: stream-based copy, write, and read helpers.","title":"Version 0.6.0"},{"location":"changelog/#version-050","text":"2014-04-08 Initial public release. Imported from OkHttp.","title":"Version 0.5.0"},{"location":"code_of_conduct/","text":"Open Source Code of Conduct \u00b6 At Square, we are committed to contributing to the open source community and simplifying the process of releasing and managing open source software. We\u2019ve seen incredible support and enthusiasm from thousands of people who have already contributed to our projects\u200a\u2014\u200aand we want to ensure our community continues to be truly open for everyone. This code of conduct outlines our expectations for participants, as well as steps to reporting unacceptable behavior. We are committed to providing a welcoming and inspiring community for all and expect our code of conduct to be honored. Square\u2019s open source community strives to: Be open : We invite anyone to participate in any aspect of our projects. Our community is open, and any responsibility can be carried by a contributor who demonstrates the required capacity and competence. Be considerate : People use our work, and we depend on the work of others. Consider users and colleagues before taking action. For example, changes to code, infrastructure, policy, and documentation may negatively impact others. Be respectful : We expect people to work together to resolve conflict, assume good intentions, and act with empathy. Do not turn disagreements into personal attacks. Be collaborative : Collaboration reduces redundancy and improves the quality of our work. We strive for transparency within our open source community, and we work closely with upstream developers and others in the free software community to coordinate our efforts. Be pragmatic : Questions are encouraged and should be asked early in the process to avoid problems later. Be thoughtful and considerate when seeking out the appropriate forum for your questions. Those who are asked should be responsive and helpful. Step down considerately : Members of every project come and go. When somebody leaves or disengages from the project, they should make it known and take the proper steps to ensure that others can pick up where they left off. This code is not exhaustive or complete. It serves to distill our common understanding of a collaborative, shared environment, and goals. We expect it to be followed in spirit as much as in the letter. Diversity Statement \u00b6 We encourage everyone to participate and are committed to building a community for all. Although we may not be able to satisfy everyone, we all agree that everyone is equal. Whenever a participant has made a mistake, we expect them to take responsibility for it. If someone has been harmed or offended, it is our responsibility to listen carefully and respectfully, and do our best to right the wrong. Although this list cannot be exhaustive, we explicitly honor diversity in age, culture, ethnicity, gender identity or expression, language, national origin, political beliefs, profession, race, religion, sexual orientation, socioeconomic status, and technical ability. We will not tolerate discrimination based on any of the protected characteristics above, including participants with disabilities. Reporting Issues \u00b6 If you experience or witness unacceptable behavior\u200a\u2014\u200aor have any other concerns\u200a\u2014\u200aplease report it by emailing codeofconduct@squareup.com . For more details, please see our Reporting Guidelines below. Thanks \u00b6 Some of the ideas and wording for the statements and guidelines above were based on work by the Twitter , Ubuntu , GDC , and Django communities. We are thankful for their work. Reporting Guide \u00b6 If you experience or witness unacceptable behavior\u200a\u2014\u200aor have any other concerns\u200a\u2014\u200aplease report it by emailing codeofconduct@squareup.com . All reports will be handled with discretion. In your report please include: Your contact information. Names (real, nicknames, or pseudonyms) of any individuals involved. If there are additional witnesses, please include them as well. Your account of what occurred, and if you believe the incident is ongoing. If there is a publicly available record (e.g. a mailing list archive or a public IRC logger), please include a link. Any additional information that may be helpful. After filing a report, a representative from the Square Code of Conduct committee will contact you personally. The committee will then review the incident, follow up with any additional questions, and make a decision as to how to respond. Anyone asked to stop unacceptable behavior is expected to comply immediately. If an individual engages in unacceptable behavior, the Square Code of Conduct committee may take any action they deem appropriate, up to and including a permanent ban from all of Square spaces without warning.","title":"Code of Conduct"},{"location":"code_of_conduct/#open-source-code-of-conduct","text":"At Square, we are committed to contributing to the open source community and simplifying the process of releasing and managing open source software. We\u2019ve seen incredible support and enthusiasm from thousands of people who have already contributed to our projects\u200a\u2014\u200aand we want to ensure our community continues to be truly open for everyone. This code of conduct outlines our expectations for participants, as well as steps to reporting unacceptable behavior. We are committed to providing a welcoming and inspiring community for all and expect our code of conduct to be honored. Square\u2019s open source community strives to: Be open : We invite anyone to participate in any aspect of our projects. Our community is open, and any responsibility can be carried by a contributor who demonstrates the required capacity and competence. Be considerate : People use our work, and we depend on the work of others. Consider users and colleagues before taking action. For example, changes to code, infrastructure, policy, and documentation may negatively impact others. Be respectful : We expect people to work together to resolve conflict, assume good intentions, and act with empathy. Do not turn disagreements into personal attacks. Be collaborative : Collaboration reduces redundancy and improves the quality of our work. We strive for transparency within our open source community, and we work closely with upstream developers and others in the free software community to coordinate our efforts. Be pragmatic : Questions are encouraged and should be asked early in the process to avoid problems later. Be thoughtful and considerate when seeking out the appropriate forum for your questions. Those who are asked should be responsive and helpful. Step down considerately : Members of every project come and go. When somebody leaves or disengages from the project, they should make it known and take the proper steps to ensure that others can pick up where they left off. This code is not exhaustive or complete. It serves to distill our common understanding of a collaborative, shared environment, and goals. We expect it to be followed in spirit as much as in the letter.","title":"Open Source Code of Conduct"},{"location":"code_of_conduct/#diversity-statement","text":"We encourage everyone to participate and are committed to building a community for all. Although we may not be able to satisfy everyone, we all agree that everyone is equal. Whenever a participant has made a mistake, we expect them to take responsibility for it. If someone has been harmed or offended, it is our responsibility to listen carefully and respectfully, and do our best to right the wrong. Although this list cannot be exhaustive, we explicitly honor diversity in age, culture, ethnicity, gender identity or expression, language, national origin, political beliefs, profession, race, religion, sexual orientation, socioeconomic status, and technical ability. We will not tolerate discrimination based on any of the protected characteristics above, including participants with disabilities.","title":"Diversity Statement"},{"location":"code_of_conduct/#reporting-issues","text":"If you experience or witness unacceptable behavior\u200a\u2014\u200aor have any other concerns\u200a\u2014\u200aplease report it by emailing codeofconduct@squareup.com . For more details, please see our Reporting Guidelines below.","title":"Reporting Issues"},{"location":"code_of_conduct/#thanks","text":"Some of the ideas and wording for the statements and guidelines above were based on work by the Twitter , Ubuntu , GDC , and Django communities. We are thankful for their work.","title":"Thanks"},{"location":"code_of_conduct/#reporting-guide","text":"If you experience or witness unacceptable behavior\u200a\u2014\u200aor have any other concerns\u200a\u2014\u200aplease report it by emailing codeofconduct@squareup.com . All reports will be handled with discretion. In your report please include: Your contact information. Names (real, nicknames, or pseudonyms) of any individuals involved. If there are additional witnesses, please include them as well. Your account of what occurred, and if you believe the incident is ongoing. If there is a publicly available record (e.g. a mailing list archive or a public IRC logger), please include a link. Any additional information that may be helpful. After filing a report, a representative from the Square Code of Conduct committee will contact you personally. The committee will then review the incident, follow up with any additional questions, and make a decision as to how to respond. Anyone asked to stop unacceptable behavior is expected to comply immediately. If an individual engages in unacceptable behavior, the Square Code of Conduct committee may take any action they deem appropriate, up to and including a permanent ban from all of Square spaces without warning.","title":"Reporting Guide"},{"location":"contributing/","text":"Contributing \u00b6 Keeping the project small and stable limits our ability to accept new contributors. We are not seeking new committers at this time, but some small contributions are welcome. If you\u2019ve found a security problem, please follow our bug bounty program. If you\u2019ve found a bug, please contribute a failing test case so we can study and fix it. Before code can be accepted all contributors must complete our Individual Contributor License Agreement (CLA) . Code Contributions \u00b6 Get working code on a personal branch with tests passing before you submit a PR: ./gradlew clean check Please make every effort to follow existing conventions and style in order to keep the code as readable as possible. Contribute code changes through GitHub by forking the repository and sending a pull request. We squash all pull requests on merge. Committer\u2019s Guides \u00b6 Releasing","title":"Contributing"},{"location":"contributing/#contributing","text":"Keeping the project small and stable limits our ability to accept new contributors. We are not seeking new committers at this time, but some small contributions are welcome. If you\u2019ve found a security problem, please follow our bug bounty program. If you\u2019ve found a bug, please contribute a failing test case so we can study and fix it. Before code can be accepted all contributors must complete our Individual Contributor License Agreement (CLA) .","title":"Contributing"},{"location":"contributing/#code-contributions","text":"Get working code on a personal branch with tests passing before you submit a PR: ./gradlew clean check Please make every effort to follow existing conventions and style in order to keep the code as readable as possible. Contribute code changes through GitHub by forking the repository and sending a pull request. We squash all pull requests on merge.","title":"Code Contributions"},{"location":"contributing/#committers-guides","text":"Releasing","title":"Committer's Guides"},{"location":"releasing/","text":"Releasing \u00b6 Prerequisite: Sonatype (Maven Central) Account \u00b6 Create an account on the Sonatype issues site . Ask an existing publisher to open an issue requesting publishing permissions for com.squareup projects. Prerequisite: GPG Keys \u00b6 Generate a GPG key (RSA, 4096 bit, 3650 day) expiry, or use an existing one. You should leave the password empty for this key. $ gpg --full-generate-key Upload the GPG keys to public servers: $ gpg --list-keys --keyid-format LONG /Users/johnbarber/.gnupg/pubring.kbx ------------------------------ pub rsa4096/XXXXXXXXXXXXXXXX 2019-07-16 [SC] [expires: 2029-07-13] YYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYY uid [ultimate] John Barber <jbarber@squareup.com> sub rsa4096/ZZZZZZZZZZZZZZZZ 2019-07-16 [E] [expires: 2029-07-13] $ gpg --send-keys --keyserver keyserver.ubuntu.com XXXXXXXXXXXXXXXX Prerequisite: Gradle Properties \u00b6 Define publishing properties in ~/.gradle/gradle.properties : signing.keyId=1A2345F8 signing.password= signing.secretKeyRingFile=/Users/jbarber/.gnupg/secring.gpg signing.keyId is the GPG key\u2019s ID. Get it with this: $ gpg --list-keys --keyid-format SHORT signing.password is the password for this key. This might be empty! signing.secretKeyRingFile is the absolute path for secring.gpg . You may need to export this file manually with the following command where XXXXXXXX is the keyId above: $ gpg --keyring secring.gpg --export-secret-key XXXXXXXX > ~/.gnupg/secring.gpg Cutting a Release \u00b6 Update CHANGELOG.md . Set versions: export RELEASE_VERSION=X.Y.Z export NEXT_VERSION=X.Y.Z-SNAPSHOT Set environment variables with your Sonatype credentials . export SONATYPE_NEXUS_USERNAME=johnbarber export SONATYPE_NEXUS_PASSWORD=`pbpaste` Update, build, and upload: sed -i \"\" \\ \"s/VERSION_NAME=.*/VERSION_NAME=$RELEASE_VERSION/g\" \\ gradle.properties sed -i \"\" \\ \"s/\\\"com.squareup.okio:\\([^\\:]*\\):[^\\\"]*\\\"/\\\"com.squareup.okio:\\1:$RELEASE_VERSION\\\"/g\" \\ `find . -name \"README.md\"` ./gradlew clean publish Visit Sonatype Nexus to promote (close then release) the artifact. Or drop it if there is a problem! Tag the release, prepare for the next one, and push to GitHub. git commit -am \"Prepare for release $RELEASE_VERSION.\" git tag -a parent-$RELEASE_VERSION -m \"Version $RELEASE_VERSION\" sed -i \"\" \\ \"s/VERSION_NAME=.*/VERSION_NAME=$NEXT_VERSION/g\" \\ gradle.properties git commit -am \"Prepare next development version.\" git push && git push --tags","title":"Releasing"},{"location":"releasing/#releasing","text":"","title":"Releasing"},{"location":"releasing/#prerequisite-sonatype-maven-central-account","text":"Create an account on the Sonatype issues site . Ask an existing publisher to open an issue requesting publishing permissions for com.squareup projects.","title":"Prerequisite: Sonatype (Maven Central) Account"},{"location":"releasing/#prerequisite-gpg-keys","text":"Generate a GPG key (RSA, 4096 bit, 3650 day) expiry, or use an existing one. You should leave the password empty for this key. $ gpg --full-generate-key Upload the GPG keys to public servers: $ gpg --list-keys --keyid-format LONG /Users/johnbarber/.gnupg/pubring.kbx ------------------------------ pub rsa4096/XXXXXXXXXXXXXXXX 2019-07-16 [SC] [expires: 2029-07-13] YYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYY uid [ultimate] John Barber <jbarber@squareup.com> sub rsa4096/ZZZZZZZZZZZZZZZZ 2019-07-16 [E] [expires: 2029-07-13] $ gpg --send-keys --keyserver keyserver.ubuntu.com XXXXXXXXXXXXXXXX","title":"Prerequisite: GPG Keys"},{"location":"releasing/#prerequisite-gradle-properties","text":"Define publishing properties in ~/.gradle/gradle.properties : signing.keyId=1A2345F8 signing.password= signing.secretKeyRingFile=/Users/jbarber/.gnupg/secring.gpg signing.keyId is the GPG key\u2019s ID. Get it with this: $ gpg --list-keys --keyid-format SHORT signing.password is the password for this key. This might be empty! signing.secretKeyRingFile is the absolute path for secring.gpg . You may need to export this file manually with the following command where XXXXXXXX is the keyId above: $ gpg --keyring secring.gpg --export-secret-key XXXXXXXX > ~/.gnupg/secring.gpg","title":"Prerequisite: Gradle Properties"},{"location":"releasing/#cutting-a-release","text":"Update CHANGELOG.md . Set versions: export RELEASE_VERSION=X.Y.Z export NEXT_VERSION=X.Y.Z-SNAPSHOT Set environment variables with your Sonatype credentials . export SONATYPE_NEXUS_USERNAME=johnbarber export SONATYPE_NEXUS_PASSWORD=`pbpaste` Update, build, and upload: sed -i \"\" \\ \"s/VERSION_NAME=.*/VERSION_NAME=$RELEASE_VERSION/g\" \\ gradle.properties sed -i \"\" \\ \"s/\\\"com.squareup.okio:\\([^\\:]*\\):[^\\\"]*\\\"/\\\"com.squareup.okio:\\1:$RELEASE_VERSION\\\"/g\" \\ `find . -name \"README.md\"` ./gradlew clean publish Visit Sonatype Nexus to promote (close then release) the artifact. Or drop it if there is a problem! Tag the release, prepare for the next one, and push to GitHub. git commit -am \"Prepare for release $RELEASE_VERSION.\" git tag -a parent-$RELEASE_VERSION -m \"Version $RELEASE_VERSION\" sed -i \"\" \\ \"s/VERSION_NAME=.*/VERSION_NAME=$NEXT_VERSION/g\" \\ gradle.properties git commit -am \"Prepare next development version.\" git push && git push --tags","title":"Cutting a Release"},{"location":"security/","text":"Security Policy \u00b6 Supported Versions \u00b6 Version Supported 2.x \u2705 1.x \u2705 Reporting a Vulnerability \u00b6 Square recognizes the important contributions the security research community can make. We therefore encourage reporting security issues with the code contained in this repository. If you believe you have discovered a security vulnerability, please follow the guidelines at https://bugcrowd.com/squareopensource","title":"Security"},{"location":"security/#security-policy","text":"","title":"Security Policy"},{"location":"security/#supported-versions","text":"Version Supported 2.x \u2705 1.x \u2705","title":"Supported Versions"},{"location":"security/#reporting-a-vulnerability","text":"Square recognizes the important contributions the security research community can make. We therefore encourage reporting security issues with the code contained in this repository. If you believe you have discovered a security vulnerability, please follow the guidelines at https://bugcrowd.com/squareopensource","title":"Reporting a Vulnerability"},{"location":"2.x/okio/","text":"// okio okio \u00b6 Packages \u00b6 Name Summary okio","title":"okio   - Okio"},{"location":"2.x/okio/#okio","text":"","title":"okio"},{"location":"2.x/okio/#packages","text":"Name Summary okio","title":"Packages"},{"location":"2.x/okio/okio/","text":"// okio / okio Package okio \u00b6 Types \u00b6 Name Summary ArrayIndexOutOfBoundsException [js] Content open class ArrayIndexOutOfBoundsException ( message : String ?) : IndexOutOfBoundsException AsyncTimeout [jvm] Brief description This timeout uses a background thread to take action exactly when the timeout occurs. Use this to implement timeouts where they aren\u2019t supported natively, such as to sockets that are blocked on writing.Subclasses should override timedOut to take action when a timeout occurs. This method will be invoked by the shared watchdog thread so it should not do any long-running operations. Otherwise we risk starving other timeouts from being triggered.Use sink and source to apply this timeout to a stream. The returned value will apply the timeout to each operation on the wrapped stream.Callers should call enter before doing work that is subject to timeouts, and exit afterwards. The return value of exit indicates whether a timeout was triggered. Note that the call to timedOut is asynchronous, and may be called after exit . Content open class AsyncTimeout : Timeout Buffer [js, jvm, native] Content [js, native] class Buffer : BufferedSource , BufferedSink [jvm] class Buffer : BufferedSource , BufferedSink , Cloneable , ByteChannel BufferedSink [js, jvm, native] Content [js, native] interface BufferedSink : Sink [jvm] interface BufferedSink : Sink , WritableByteChannel BufferedSource [js, jvm, native] Content [js, native] interface BufferedSource : Source [jvm] interface BufferedSource : Source , ReadableByteChannel ByteString [js, jvm, native] Content [js, native] open class ByteString : Comparable [jvm] open class ByteString : Serializable , Comparable DeflaterSink [jvm] Brief description A sink that uses DEFLATE to compress data written to another source. Sync flush Aggressive flushing of this stream may result in reduced compression. Each call to flush immediately compresses all currently-buffered data; this early compression may be less effective than compression performed without flushing.This is equivalent to using Deflater with the sync flush option. This class does not offer any partial flush mechanism. For best performance, only call flush when application behavior requires it. Content class DeflaterSink : Sink EOFException [js, native] Content [js, native] open class EOFException ( message : String ?) : IOException ForwardingSink [jvm] Brief description A Sink which forwards calls to another. Useful for subclassing. Content abstract class ForwardingSink ( delegate : Sink ) : Sink ForwardingSource [jvm] Brief description A Source which forwards calls to another. Useful for subclassing. Content abstract class ForwardingSource ( delegate : Source ) : Source ForwardingTimeout [jvm] Brief description A Timeout which forwards calls to another. Useful for subclassing. Content open class ForwardingTimeout ( delegate : Timeout ) : Timeout GzipSink [jvm] Brief description A sink that uses GZIP to compress written data to another sink. Sync flush Aggressive flushing of this stream may result in reduced compression. Each call to flush immediately compresses all currently-buffered data; this early compression may be less effective than compression performed without flushing.This is equivalent to using Deflater with the sync flush option. This class does not offer any partial flush mechanism. For best performance, only call flush when application behavior requires it. Content class GzipSink ( sink : Sink ) : Sink GzipSource [jvm] Brief description A source that uses GZIP to decompress data read from another source. Content class GzipSource ( source : Source ) : Source HashingSink [jvm] Brief description A sink that computes a hash of the full stream of bytes it has accepted. To use, create an instance with your preferred hash algorithm. Write all of the data to the sink and then call hash to compute the final hash value.In this example we use HashingSink with a BufferedSink to make writing to the sink easier.HashingSink hashingSink = HashingSink.sha256(s); BufferedSink bufferedSink = Okio.buffer(hashingSink); \u2026 // Write to bufferedSink and either flush or close it. ByteString hash = hashingSink.hash(); Content class HashingSink : ForwardingSink HashingSource [jvm] Brief description A source that computes a hash of the full stream of bytes it has supplied. To use, create an instance with your preferred hash algorithm. Exhaust the source by reading all of its bytes and then call hash to compute the final hash value.In this example we use HashingSource with a BufferedSource to make reading from the source easier.HashingSource hashingSource = HashingSource.sha256(rawSource); BufferedSource bufferedSource = Okio.buffer(hashingSource); \u2026 // Read all of bufferedSource. ByteString hash = hashingSource.hash(); Content class HashingSource : ForwardingSource InflaterSource [jvm] Brief description A source that uses DEFLATE to decompress data read from another source. Content class InflaterSource : Source IOException [js, native] Content [js] open class IOException ( message : String ?) : Exception [native] open class IOException ( message : String ?) Pipe [jvm] Brief description A source and a sink that are attached. The sink\u2019s output is the source\u2019s input. Typically each is accessed by its own thread: a producer thread writes data to the sink and a consumer thread reads data from the source.This class uses a buffer to decouple source and sink. This buffer has a user-specified maximum size. When a producer thread outruns its consumer the buffer fills up and eventually writes to the sink will block until the consumer has caught up. Symmetrically, if a consumer outruns its producer reads block until there is data to be read. Limits on the amount of time spent waiting for the other party can be configured with timeouts on the source and the sink.When the sink is closed, source reads will continue to complete normally until the buffer has been exhausted. At that point reads will return -1, indicating the end of the stream. But if the source is closed first, writes to the sink will immediately fail with an IOException .A pipe may be canceled to immediately fail writes to the sink and reads from the source. Content class Pipe ( maxBufferSize : Long ) Sink [js, jvm, native] Content [js, native] interface Sink [jvm] interface Sink : Closeable , Flushable Source [js, jvm, native] Content [js, native] interface Source [jvm] interface Source : Closeable Throttler [jvm] Brief description Enables limiting of Source and Sink throughput. Attach to this throttler via source and sink and set the desired throughput via bytesPerSecond . Multiple Sources and Sinks can be attached to a single Throttler and they will be throttled as a group, where their combined throughput will not exceed the desired throughput. The same Source or Sink can be attached to multiple Throttlers and its throughput will not exceed the desired throughput of any of the Throttlers.This class has these tuning parameters: bytesPerSecond: Maximum sustained throughput. Use 0 for no limit. waitByteCount: When the requested byte count is greater than this many bytes and isn\u2019t immediately available, only wait until we can allocate at least this many bytes. Use this to set the ideal byte count during sustained throughput. maxByteCount: Maximum number of bytes to allocate on any call. This is also the number of bytes that will be returned before any waiting. Content class Throttler Timeout [js, jvm, native] Content [js, jvm, native] open class Timeout Functions \u00b6 Name Summary appendingSink [jvm] Brief description Returns a sink that writes to file. Content fun File . appendingSink (): Sink deflate [jvm] Brief description Returns an DeflaterSink that DEFLATE-compresses data to this Sink while writing. Content inline fun Sink . deflate (deflater: Deflater ): DeflaterSink gzip [jvm] Brief description Returns a GzipSink that gzip-compresses to this Sink while writing. Content inline fun Sink . gzip (): GzipSink [jvm] Brief description Returns a GzipSource that gzip-decompresses this Source while reading. Content inline fun Source . gzip (): GzipSource inflate [jvm] Brief description Returns an InflaterSource that DEFLATE-decompresses this Source while reading. Content inline fun Source . inflate (inflater: Inflater ): InflaterSource sink [jvm] Brief description Returns a sink that writes to out. Content fun OutputStream . sink (): Sink [jvm] Brief description Returns a sink that writes to socket. Prefer this over sink because this method honors timeouts. When the socket write times out, the socket is asynchronously closed by a watchdog thread. Content fun Socket . sink (): Sink [jvm] Brief description Returns a sink that writes to file. Content @ JvmOverloads () fun File . sink (append: Boolean ): Sink [jvm] Brief description Returns a source that reads from path. Content @ IgnoreJRERequirement () fun Path . sink (vararg options: Array OpenOption >): Sink source [jvm] Brief description Returns a source that reads from in. Content fun InputStream . source (): Source [jvm] Brief description Returns a source that reads from socket. Prefer this over source because this method honors timeouts. When the socket read times out, the socket is asynchronously closed by a watchdog thread. Content fun Socket . source (): Source [jvm] Brief description Returns a source that reads from file. Content fun File . source (): Source [jvm] Brief description Returns a sink that writes to path. Content @ IgnoreJRERequirement () fun Path . source (vararg options: Array OpenOption >): Source Properties \u00b6 Name Summary Okio [jvm] val Okio : -DeprecatedOkio Utf8 [jvm] val Utf8 : -DeprecatedUtf8","title":"2.x API"},{"location":"2.x/okio/okio/#package-okio","text":"","title":"Package okio"},{"location":"2.x/okio/okio/#types","text":"Name Summary ArrayIndexOutOfBoundsException [js] Content open class ArrayIndexOutOfBoundsException ( message : String ?) : IndexOutOfBoundsException AsyncTimeout [jvm] Brief description This timeout uses a background thread to take action exactly when the timeout occurs. Use this to implement timeouts where they aren\u2019t supported natively, such as to sockets that are blocked on writing.Subclasses should override timedOut to take action when a timeout occurs. This method will be invoked by the shared watchdog thread so it should not do any long-running operations. Otherwise we risk starving other timeouts from being triggered.Use sink and source to apply this timeout to a stream. The returned value will apply the timeout to each operation on the wrapped stream.Callers should call enter before doing work that is subject to timeouts, and exit afterwards. The return value of exit indicates whether a timeout was triggered. Note that the call to timedOut is asynchronous, and may be called after exit . Content open class AsyncTimeout : Timeout Buffer [js, jvm, native] Content [js, native] class Buffer : BufferedSource , BufferedSink [jvm] class Buffer : BufferedSource , BufferedSink , Cloneable , ByteChannel BufferedSink [js, jvm, native] Content [js, native] interface BufferedSink : Sink [jvm] interface BufferedSink : Sink , WritableByteChannel BufferedSource [js, jvm, native] Content [js, native] interface BufferedSource : Source [jvm] interface BufferedSource : Source , ReadableByteChannel ByteString [js, jvm, native] Content [js, native] open class ByteString : Comparable [jvm] open class ByteString : Serializable , Comparable DeflaterSink [jvm] Brief description A sink that uses DEFLATE to compress data written to another source. Sync flush Aggressive flushing of this stream may result in reduced compression. Each call to flush immediately compresses all currently-buffered data; this early compression may be less effective than compression performed without flushing.This is equivalent to using Deflater with the sync flush option. This class does not offer any partial flush mechanism. For best performance, only call flush when application behavior requires it. Content class DeflaterSink : Sink EOFException [js, native] Content [js, native] open class EOFException ( message : String ?) : IOException ForwardingSink [jvm] Brief description A Sink which forwards calls to another. Useful for subclassing. Content abstract class ForwardingSink ( delegate : Sink ) : Sink ForwardingSource [jvm] Brief description A Source which forwards calls to another. Useful for subclassing. Content abstract class ForwardingSource ( delegate : Source ) : Source ForwardingTimeout [jvm] Brief description A Timeout which forwards calls to another. Useful for subclassing. Content open class ForwardingTimeout ( delegate : Timeout ) : Timeout GzipSink [jvm] Brief description A sink that uses GZIP to compress written data to another sink. Sync flush Aggressive flushing of this stream may result in reduced compression. Each call to flush immediately compresses all currently-buffered data; this early compression may be less effective than compression performed without flushing.This is equivalent to using Deflater with the sync flush option. This class does not offer any partial flush mechanism. For best performance, only call flush when application behavior requires it. Content class GzipSink ( sink : Sink ) : Sink GzipSource [jvm] Brief description A source that uses GZIP to decompress data read from another source. Content class GzipSource ( source : Source ) : Source HashingSink [jvm] Brief description A sink that computes a hash of the full stream of bytes it has accepted. To use, create an instance with your preferred hash algorithm. Write all of the data to the sink and then call hash to compute the final hash value.In this example we use HashingSink with a BufferedSink to make writing to the sink easier.HashingSink hashingSink = HashingSink.sha256(s); BufferedSink bufferedSink = Okio.buffer(hashingSink); \u2026 // Write to bufferedSink and either flush or close it. ByteString hash = hashingSink.hash(); Content class HashingSink : ForwardingSink HashingSource [jvm] Brief description A source that computes a hash of the full stream of bytes it has supplied. To use, create an instance with your preferred hash algorithm. Exhaust the source by reading all of its bytes and then call hash to compute the final hash value.In this example we use HashingSource with a BufferedSource to make reading from the source easier.HashingSource hashingSource = HashingSource.sha256(rawSource); BufferedSource bufferedSource = Okio.buffer(hashingSource); \u2026 // Read all of bufferedSource. ByteString hash = hashingSource.hash(); Content class HashingSource : ForwardingSource InflaterSource [jvm] Brief description A source that uses DEFLATE to decompress data read from another source. Content class InflaterSource : Source IOException [js, native] Content [js] open class IOException ( message : String ?) : Exception [native] open class IOException ( message : String ?) Pipe [jvm] Brief description A source and a sink that are attached. The sink\u2019s output is the source\u2019s input. Typically each is accessed by its own thread: a producer thread writes data to the sink and a consumer thread reads data from the source.This class uses a buffer to decouple source and sink. This buffer has a user-specified maximum size. When a producer thread outruns its consumer the buffer fills up and eventually writes to the sink will block until the consumer has caught up. Symmetrically, if a consumer outruns its producer reads block until there is data to be read. Limits on the amount of time spent waiting for the other party can be configured with timeouts on the source and the sink.When the sink is closed, source reads will continue to complete normally until the buffer has been exhausted. At that point reads will return -1, indicating the end of the stream. But if the source is closed first, writes to the sink will immediately fail with an IOException .A pipe may be canceled to immediately fail writes to the sink and reads from the source. Content class Pipe ( maxBufferSize : Long ) Sink [js, jvm, native] Content [js, native] interface Sink [jvm] interface Sink : Closeable , Flushable Source [js, jvm, native] Content [js, native] interface Source [jvm] interface Source : Closeable Throttler [jvm] Brief description Enables limiting of Source and Sink throughput. Attach to this throttler via source and sink and set the desired throughput via bytesPerSecond . Multiple Sources and Sinks can be attached to a single Throttler and they will be throttled as a group, where their combined throughput will not exceed the desired throughput. The same Source or Sink can be attached to multiple Throttlers and its throughput will not exceed the desired throughput of any of the Throttlers.This class has these tuning parameters: bytesPerSecond: Maximum sustained throughput. Use 0 for no limit. waitByteCount: When the requested byte count is greater than this many bytes and isn\u2019t immediately available, only wait until we can allocate at least this many bytes. Use this to set the ideal byte count during sustained throughput. maxByteCount: Maximum number of bytes to allocate on any call. This is also the number of bytes that will be returned before any waiting. Content class Throttler Timeout [js, jvm, native] Content [js, jvm, native] open class Timeout","title":"Types"},{"location":"2.x/okio/okio/#functions","text":"Name Summary appendingSink [jvm] Brief description Returns a sink that writes to file. Content fun File . appendingSink (): Sink deflate [jvm] Brief description Returns an DeflaterSink that DEFLATE-compresses data to this Sink while writing. Content inline fun Sink . deflate (deflater: Deflater ): DeflaterSink gzip [jvm] Brief description Returns a GzipSink that gzip-compresses to this Sink while writing. Content inline fun Sink . gzip (): GzipSink [jvm] Brief description Returns a GzipSource that gzip-decompresses this Source while reading. Content inline fun Source . gzip (): GzipSource inflate [jvm] Brief description Returns an InflaterSource that DEFLATE-decompresses this Source while reading. Content inline fun Source . inflate (inflater: Inflater ): InflaterSource sink [jvm] Brief description Returns a sink that writes to out. Content fun OutputStream . sink (): Sink [jvm] Brief description Returns a sink that writes to socket. Prefer this over sink because this method honors timeouts. When the socket write times out, the socket is asynchronously closed by a watchdog thread. Content fun Socket . sink (): Sink [jvm] Brief description Returns a sink that writes to file. Content @ JvmOverloads () fun File . sink (append: Boolean ): Sink [jvm] Brief description Returns a source that reads from path. Content @ IgnoreJRERequirement () fun Path . sink (vararg options: Array OpenOption >): Sink source [jvm] Brief description Returns a source that reads from in. Content fun InputStream . source (): Source [jvm] Brief description Returns a source that reads from socket. Prefer this over source because this method honors timeouts. When the socket read times out, the socket is asynchronously closed by a watchdog thread. Content fun Socket . source (): Source [jvm] Brief description Returns a source that reads from file. Content fun File . source (): Source [jvm] Brief description Returns a sink that writes to path. Content @ IgnoreJRERequirement () fun Path . source (vararg options: Array OpenOption >): Source","title":"Functions"},{"location":"2.x/okio/okio/#properties","text":"Name Summary Okio [jvm] val Okio : -DeprecatedOkio Utf8 [jvm] val Utf8 : -DeprecatedUtf8","title":"Properties"},{"location":"2.x/okio/okio/appending-sink/","text":"// okio / okio / appendingSink appendingSink \u00b6 [jvm] Brief description Returns a sink that writes to file. Content fun File . appendingSink (): Sink","title":"appendingSink   - Okio"},{"location":"2.x/okio/okio/appending-sink/#appendingsink","text":"[jvm] Brief description Returns a sink that writes to file. Content fun File . appendingSink (): Sink","title":"appendingSink"},{"location":"2.x/okio/okio/deflate/","text":"// okio / okio / deflate deflate \u00b6 [jvm] Brief description Returns an DeflaterSink that DEFLATE-compresses data to this Sink while writing. See also \u00b6 jvm Name Summary DeflaterSink Content inline fun Sink . deflate (deflater: Deflater ): DeflaterSink","title":"deflate   - Okio"},{"location":"2.x/okio/okio/deflate/#deflate","text":"[jvm] Brief description Returns an DeflaterSink that DEFLATE-compresses data to this Sink while writing.","title":"deflate"},{"location":"2.x/okio/okio/deflate/#see-also","text":"jvm Name Summary DeflaterSink Content inline fun Sink . deflate (deflater: Deflater ): DeflaterSink","title":"See also"},{"location":"2.x/okio/okio/gzip/","text":"// okio / okio / gzip gzip \u00b6 [jvm] Brief description Returns a GzipSink that gzip-compresses to this Sink while writing. See also \u00b6 jvm Name Summary GzipSource Content inline fun Sink . gzip (): GzipSink [jvm] Brief description Returns a GzipSource that gzip-decompresses this Source while reading. See also \u00b6 jvm Name Summary GzipSource Content inline fun Source . gzip (): GzipSource","title":"gzip   - Okio"},{"location":"2.x/okio/okio/gzip/#gzip","text":"[jvm] Brief description Returns a GzipSink that gzip-compresses to this Sink while writing.","title":"gzip"},{"location":"2.x/okio/okio/gzip/#see-also","text":"jvm Name Summary GzipSource Content inline fun Sink . gzip (): GzipSink [jvm] Brief description Returns a GzipSource that gzip-decompresses this Source while reading.","title":"See also"},{"location":"2.x/okio/okio/gzip/#see-also_1","text":"jvm Name Summary GzipSource Content inline fun Source . gzip (): GzipSource","title":"See also"},{"location":"2.x/okio/okio/inflate/","text":"// okio / okio / inflate inflate \u00b6 [jvm] Brief description Returns an InflaterSource that DEFLATE-decompresses this Source while reading. See also \u00b6 jvm Name Summary InflaterSource Content inline fun Source . inflate (inflater: Inflater ): InflaterSource","title":"inflate   - Okio"},{"location":"2.x/okio/okio/inflate/#inflate","text":"[jvm] Brief description Returns an InflaterSource that DEFLATE-decompresses this Source while reading.","title":"inflate"},{"location":"2.x/okio/okio/inflate/#see-also","text":"jvm Name Summary InflaterSource Content inline fun Source . inflate (inflater: Inflater ): InflaterSource","title":"See also"},{"location":"2.x/okio/okio/sink/","text":"// okio / okio / sink sink \u00b6 [jvm] Brief description Returns a sink that writes to out. Content fun OutputStream . sink (): Sink [jvm] Brief description Returns a sink that writes to socket. Prefer this over sink because this method honors timeouts. When the socket write times out, the socket is asynchronously closed by a watchdog thread. Content fun Socket . sink (): Sink [jvm] Brief description Returns a sink that writes to file. Content @ JvmOverloads () fun File . sink (append: Boolean ): Sink [jvm] Brief description Returns a source that reads from path. Content @ IgnoreJRERequirement () fun Path . sink (vararg options: Array OpenOption >): Sink","title":"sink   - Okio"},{"location":"2.x/okio/okio/sink/#sink","text":"[jvm] Brief description Returns a sink that writes to out. Content fun OutputStream . sink (): Sink [jvm] Brief description Returns a sink that writes to socket. Prefer this over sink because this method honors timeouts. When the socket write times out, the socket is asynchronously closed by a watchdog thread. Content fun Socket . sink (): Sink [jvm] Brief description Returns a sink that writes to file. Content @ JvmOverloads () fun File . sink (append: Boolean ): Sink [jvm] Brief description Returns a source that reads from path. Content @ IgnoreJRERequirement () fun Path . sink (vararg options: Array OpenOption >): Sink","title":"sink"},{"location":"2.x/okio/okio/source/","text":"// okio / okio / source source \u00b6 [jvm] Brief description Returns a source that reads from in. Content fun InputStream . source (): Source [jvm] Brief description Returns a source that reads from socket. Prefer this over source because this method honors timeouts. When the socket read times out, the socket is asynchronously closed by a watchdog thread. Content fun Socket . source (): Source [jvm] Brief description Returns a source that reads from file. Content fun File . source (): Source [jvm] Brief description Returns a sink that writes to path. Content @ IgnoreJRERequirement () fun Path . source (vararg options: Array OpenOption >): Source","title":"source   - Okio"},{"location":"2.x/okio/okio/source/#source","text":"[jvm] Brief description Returns a source that reads from in. Content fun InputStream . source (): Source [jvm] Brief description Returns a source that reads from socket. Prefer this over source because this method honors timeouts. When the socket read times out, the socket is asynchronously closed by a watchdog thread. Content fun Socket . source (): Source [jvm] Brief description Returns a source that reads from file. Content fun File . source (): Source [jvm] Brief description Returns a sink that writes to path. Content @ IgnoreJRERequirement () fun Path . source (vararg options: Array OpenOption >): Source","title":"source"},{"location":"2.x/okio/okio/-array-index-out-of-bounds-exception/","text":"// okio / okio / ArrayIndexOutOfBoundsException ArrayIndexOutOfBoundsException \u00b6 [js] open class ArrayIndexOutOfBoundsException ( message : String ?) : IndexOutOfBoundsException Functions \u00b6 Name Summary equals [js] Content open operator override fun equals (other: Any ?): Boolean hashCode [js] Content open override fun hashCode (): Int toString [js] Content open override fun toString (): String Properties \u00b6 Name Summary cause [js] open override val cause : Throwable ? message [js] open override val message : String ?","title":"ArrayIndexOutOfBoundsException   - Okio"},{"location":"2.x/okio/okio/-array-index-out-of-bounds-exception/#arrayindexoutofboundsexception","text":"[js] open class ArrayIndexOutOfBoundsException ( message : String ?) : IndexOutOfBoundsException","title":"ArrayIndexOutOfBoundsException"},{"location":"2.x/okio/okio/-array-index-out-of-bounds-exception/#functions","text":"Name Summary equals [js] Content open operator override fun equals (other: Any ?): Boolean hashCode [js] Content open override fun hashCode (): Int toString [js] Content open override fun toString (): String","title":"Functions"},{"location":"2.x/okio/okio/-array-index-out-of-bounds-exception/#properties","text":"Name Summary cause [js] open override val cause : Throwable ? message [js] open override val message : String ?","title":"Properties"},{"location":"2.x/okio/okio/-array-index-out-of-bounds-exception/-init-/","text":"// okio / okio / ArrayIndexOutOfBoundsException / \u00b6 [js] Content fun (message: String ?)","title":"<init>   - Okio"},{"location":"2.x/okio/okio/-array-index-out-of-bounds-exception/-init-/#_1","text":"[js] Content fun (message: String ?)","title":""},{"location":"2.x/okio/okio/-async-timeout/","text":"// okio / okio / AsyncTimeout AsyncTimeout \u00b6 [jvm] This timeout uses a background thread to take action exactly when the timeout occurs. Use this to implement timeouts where they aren\u2019t supported natively, such as to sockets that are blocked on writing.Subclasses should override timedOut to take action when a timeout occurs. This method will be invoked by the shared watchdog thread so it should not do any long-running operations. Otherwise we risk starving other timeouts from being triggered.Use sink and source to apply this timeout to a stream. The returned value will apply the timeout to each operation on the wrapped stream.Callers should call enter before doing work that is subject to timeouts, and exit afterwards. The return value of exit indicates whether a timeout was triggered. Note that the call to timedOut is asynchronous, and may be called after exit . open class AsyncTimeout : Timeout Constructors \u00b6 Name Summary [jvm] fun () Types \u00b6 Name Summary Companion [jvm] Content object Companion Functions \u00b6 Name Summary clearDeadline [jvm] Brief description Clears the deadline. Content open override fun clearDeadline (): Timeout clearTimeout [jvm] Brief description Clears the timeout. Operating system timeouts may still apply. Content open override fun clearTimeout (): Timeout deadline [jvm] Brief description Set a deadline of now plus duration time. Content override fun deadline (duration: Long , unit: TimeUnit ): Timeout deadlineNanoTime [jvm] Brief description Returns the nano time when the deadline will be reached. Content open override fun deadlineNanoTime (): Long [jvm] Brief description Sets the nano time when the deadline will be reached. All operations must complete before this time. Use a deadline to set a maximum bound on the time spent on a sequence of operations. Content open override fun deadlineNanoTime (deadlineNanoTime: Long ): Timeout enter [jvm] Content fun enter () equals [jvm] Content open operator override fun equals (other: Any ?): Boolean exit [jvm] Brief description Returns true if the timeout occurred. Content fun exit (): Boolean hasDeadline [jvm] Brief description Returns true if a deadline is enabled. Content open override fun hasDeadline (): Boolean hashCode [jvm] Content open override fun hashCode (): Int intersectWith [jvm] Brief description Applies the minimum intersection between this timeout and other, run block, then finally rollback this timeout\u2019s values. Content inline override fun intersectWith (other: Timeout , block: () -> Unit ) sink [jvm] Brief description Returns a new sink that delegates to sink , using this to implement timeouts. This works best if timedOut is overridden to interrupt sink \u2018s current operation. Content fun sink (sink: Sink ): Sink source [jvm] Brief description Returns a new source that delegates to source , using this to implement timeouts. This works best if timedOut is overridden to interrupt source \u2018s current operation. Content fun source (source: Source ): Source throwIfReached [jvm] Brief description Throws an InterruptedIOException if the deadline has been reached or if the current thread has been interrupted. This method doesn\u2019t detect timeouts; that should be implemented to asynchronously abort an in-progress operation. Content open override fun throwIfReached () timeout [jvm] Brief description Wait at most timeout time before aborting an operation. Using a per-operation timeout means that as long as forward progress is being made, no sequence of operations will fail.If timeout == 0, operations will run indefinitely. (Operating system timeouts may still apply.) Content open override fun timeout (timeout: Long , unit: TimeUnit ): Timeout timeoutNanos [jvm] Brief description Returns the timeout in nanoseconds, or 0 for no timeout. Content open override fun timeoutNanos (): Long toString [jvm] Content open override fun toString (): String waitUntilNotified [jvm] Brief description Waits on monitor until it is notified. Throws InterruptedIOException if either the thread is interrupted or if this timeout elapses before monitor is notified. The caller must be synchronized on monitor.Here\u2019s a sample class that uses waitUntilNotified() to await a specific state. Note that the call is made within a loop to avoid unnecessary waiting and to mitigate spurious notifications.class Dice { Random random = new Random(); int latestTotal; public synchronized void roll() { latestTotal = 2 + random.nextInt(6) + random.nextInt(6); System.out.println(\u201cRolled \u201d + latestTotal); notifyAll(); } public void rollAtFixedRate(int period, TimeUnit timeUnit) { Executors.newScheduledThreadPool(0).scheduleAtFixedRate(new Runnable() { public void run() { roll(); } }, 0, period, timeUnit); } public synchronized void awaitTotal(Timeout timeout, int total) throws InterruptedIOException { while (latestTotal != total) { timeout.waitUntilNotified(this); } } } Content override fun waitUntilNotified (monitor: Any ) withTimeout [jvm] Brief description Surrounds block with calls to enter and exit , throwing an exception from newTimeoutException if a timeout occurred. Content inline fun < T : Any ?> withTimeout (block: () -> T ): T Properties \u00b6 Name Summary deadlineNanoTime [jvm] override var deadlineNanoTime : Long hasDeadline [jvm] True if deadlineNanoTime is defined. There is no equivalent to null or 0 for System.nanoTime .override var hasDeadline : Boolean timeoutNanos [jvm] override var timeoutNanos : Long","title":"AsyncTimeout   - Okio"},{"location":"2.x/okio/okio/-async-timeout/#asynctimeout","text":"[jvm] This timeout uses a background thread to take action exactly when the timeout occurs. Use this to implement timeouts where they aren\u2019t supported natively, such as to sockets that are blocked on writing.Subclasses should override timedOut to take action when a timeout occurs. This method will be invoked by the shared watchdog thread so it should not do any long-running operations. Otherwise we risk starving other timeouts from being triggered.Use sink and source to apply this timeout to a stream. The returned value will apply the timeout to each operation on the wrapped stream.Callers should call enter before doing work that is subject to timeouts, and exit afterwards. The return value of exit indicates whether a timeout was triggered. Note that the call to timedOut is asynchronous, and may be called after exit . open class AsyncTimeout : Timeout","title":"AsyncTimeout"},{"location":"2.x/okio/okio/-async-timeout/#constructors","text":"Name Summary [jvm] fun ()","title":"Constructors"},{"location":"2.x/okio/okio/-async-timeout/#types","text":"Name Summary Companion [jvm] Content object Companion","title":"Types"},{"location":"2.x/okio/okio/-async-timeout/#functions","text":"Name Summary clearDeadline [jvm] Brief description Clears the deadline. Content open override fun clearDeadline (): Timeout clearTimeout [jvm] Brief description Clears the timeout. Operating system timeouts may still apply. Content open override fun clearTimeout (): Timeout deadline [jvm] Brief description Set a deadline of now plus duration time. Content override fun deadline (duration: Long , unit: TimeUnit ): Timeout deadlineNanoTime [jvm] Brief description Returns the nano time when the deadline will be reached. Content open override fun deadlineNanoTime (): Long [jvm] Brief description Sets the nano time when the deadline will be reached. All operations must complete before this time. Use a deadline to set a maximum bound on the time spent on a sequence of operations. Content open override fun deadlineNanoTime (deadlineNanoTime: Long ): Timeout enter [jvm] Content fun enter () equals [jvm] Content open operator override fun equals (other: Any ?): Boolean exit [jvm] Brief description Returns true if the timeout occurred. Content fun exit (): Boolean hasDeadline [jvm] Brief description Returns true if a deadline is enabled. Content open override fun hasDeadline (): Boolean hashCode [jvm] Content open override fun hashCode (): Int intersectWith [jvm] Brief description Applies the minimum intersection between this timeout and other, run block, then finally rollback this timeout\u2019s values. Content inline override fun intersectWith (other: Timeout , block: () -> Unit ) sink [jvm] Brief description Returns a new sink that delegates to sink , using this to implement timeouts. This works best if timedOut is overridden to interrupt sink \u2018s current operation. Content fun sink (sink: Sink ): Sink source [jvm] Brief description Returns a new source that delegates to source , using this to implement timeouts. This works best if timedOut is overridden to interrupt source \u2018s current operation. Content fun source (source: Source ): Source throwIfReached [jvm] Brief description Throws an InterruptedIOException if the deadline has been reached or if the current thread has been interrupted. This method doesn\u2019t detect timeouts; that should be implemented to asynchronously abort an in-progress operation. Content open override fun throwIfReached () timeout [jvm] Brief description Wait at most timeout time before aborting an operation. Using a per-operation timeout means that as long as forward progress is being made, no sequence of operations will fail.If timeout == 0, operations will run indefinitely. (Operating system timeouts may still apply.) Content open override fun timeout (timeout: Long , unit: TimeUnit ): Timeout timeoutNanos [jvm] Brief description Returns the timeout in nanoseconds, or 0 for no timeout. Content open override fun timeoutNanos (): Long toString [jvm] Content open override fun toString (): String waitUntilNotified [jvm] Brief description Waits on monitor until it is notified. Throws InterruptedIOException if either the thread is interrupted or if this timeout elapses before monitor is notified. The caller must be synchronized on monitor.Here\u2019s a sample class that uses waitUntilNotified() to await a specific state. Note that the call is made within a loop to avoid unnecessary waiting and to mitigate spurious notifications.class Dice { Random random = new Random(); int latestTotal; public synchronized void roll() { latestTotal = 2 + random.nextInt(6) + random.nextInt(6); System.out.println(\u201cRolled \u201d + latestTotal); notifyAll(); } public void rollAtFixedRate(int period, TimeUnit timeUnit) { Executors.newScheduledThreadPool(0).scheduleAtFixedRate(new Runnable() { public void run() { roll(); } }, 0, period, timeUnit); } public synchronized void awaitTotal(Timeout timeout, int total) throws InterruptedIOException { while (latestTotal != total) { timeout.waitUntilNotified(this); } } } Content override fun waitUntilNotified (monitor: Any ) withTimeout [jvm] Brief description Surrounds block with calls to enter and exit , throwing an exception from newTimeoutException if a timeout occurred. Content inline fun < T : Any ?> withTimeout (block: () -> T ): T","title":"Functions"},{"location":"2.x/okio/okio/-async-timeout/#properties","text":"Name Summary deadlineNanoTime [jvm] override var deadlineNanoTime : Long hasDeadline [jvm] True if deadlineNanoTime is defined. There is no equivalent to null or 0 for System.nanoTime .override var hasDeadline : Boolean timeoutNanos [jvm] override var timeoutNanos : Long","title":"Properties"},{"location":"2.x/okio/okio/-async-timeout/-init-/","text":"// okio / okio / AsyncTimeout / \u00b6 [jvm] Content fun ()","title":"<init>   - Okio"},{"location":"2.x/okio/okio/-async-timeout/-init-/#_1","text":"[jvm] Content fun ()","title":""},{"location":"2.x/okio/okio/-async-timeout/enter/","text":"// okio / okio / AsyncTimeout / enter enter \u00b6 [jvm] Content fun enter ()","title":"enter   - Okio"},{"location":"2.x/okio/okio/-async-timeout/enter/#enter","text":"[jvm] Content fun enter ()","title":"enter"},{"location":"2.x/okio/okio/-async-timeout/exit/","text":"// okio / okio / AsyncTimeout / exit exit \u00b6 [jvm] Brief description Returns true if the timeout occurred. Content fun exit (): Boolean","title":"exit   - Okio"},{"location":"2.x/okio/okio/-async-timeout/exit/#exit","text":"[jvm] Brief description Returns true if the timeout occurred. Content fun exit (): Boolean","title":"exit"},{"location":"2.x/okio/okio/-async-timeout/sink/","text":"// okio / okio / AsyncTimeout / sink sink \u00b6 [jvm] Brief description Returns a new sink that delegates to sink , using this to implement timeouts. This works best if timedOut is overridden to interrupt sink \u2018s current operation. Content fun sink (sink: Sink ): Sink","title":"sink   - Okio"},{"location":"2.x/okio/okio/-async-timeout/sink/#sink","text":"[jvm] Brief description Returns a new sink that delegates to sink , using this to implement timeouts. This works best if timedOut is overridden to interrupt sink \u2018s current operation. Content fun sink (sink: Sink ): Sink","title":"sink"},{"location":"2.x/okio/okio/-async-timeout/source/","text":"// okio / okio / AsyncTimeout / source source \u00b6 [jvm] Brief description Returns a new source that delegates to source , using this to implement timeouts. This works best if timedOut is overridden to interrupt source \u2018s current operation. Content fun source (source: Source ): Source","title":"source   - Okio"},{"location":"2.x/okio/okio/-async-timeout/source/#source","text":"[jvm] Brief description Returns a new source that delegates to source , using this to implement timeouts. This works best if timedOut is overridden to interrupt source \u2018s current operation. Content fun source (source: Source ): Source","title":"source"},{"location":"2.x/okio/okio/-async-timeout/with-timeout/","text":"// okio / okio / AsyncTimeout / withTimeout withTimeout \u00b6 [jvm] Brief description Surrounds block with calls to enter and exit , throwing an exception from newTimeoutException if a timeout occurred. Content inline fun < T : Any ?> withTimeout (block: () -> T ): T","title":"withTimeout   - Okio"},{"location":"2.x/okio/okio/-async-timeout/with-timeout/#withtimeout","text":"[jvm] Brief description Surrounds block with calls to enter and exit , throwing an exception from newTimeoutException if a timeout occurred. Content inline fun < T : Any ?> withTimeout (block: () -> T ): T","title":"withTimeout"},{"location":"2.x/okio/okio/-async-timeout/-companion/","text":"// okio / okio / AsyncTimeout / Companion Companion \u00b6 [jvm] object Companion Functions \u00b6 Name Summary equals [jvm] Content open operator override fun equals (other: Any ?): Boolean hashCode [jvm] Content open override fun hashCode (): Int toString [jvm] Content open override fun toString (): String","title":"Companion   - Okio"},{"location":"2.x/okio/okio/-async-timeout/-companion/#companion","text":"[jvm] object Companion","title":"Companion"},{"location":"2.x/okio/okio/-async-timeout/-companion/#functions","text":"Name Summary equals [jvm] Content open operator override fun equals (other: Any ?): Boolean hashCode [jvm] Content open override fun hashCode (): Int toString [jvm] Content open override fun toString (): String","title":"Functions"},{"location":"2.x/okio/okio/-buffer/","text":"// okio / okio / Buffer Buffer \u00b6 [js, native] class Buffer : BufferedSource , BufferedSink [jvm] class Buffer : BufferedSource , BufferedSink , Cloneable , ByteChannel Types \u00b6 Name Summary UnsafeCursor [jvm] Brief description A handle to the underlying data in a buffer. This handle is unsafe because it does not enforce its own invariants. Instead, it assumes a careful user who has studied Okio\u2019s implementation details and their consequences.Buffer Internals ----------------Most code should use Buffer as a black box: a class that holds 0 or more bytes of data with efficient APIs to append data to the end and to consume data from the front. Usually this is also the most efficient way to use buffers because it allows Okio to employ several optimizations, including: Buffers use a shared pool of memory that is not zero-filled before use. A buffer\u2019s capacity can change without copying its contents. Memory ownership can be reassigned from one buffer to another. Multiple buffers can share the same underlying memory. Common operations like UTF-8 encoding and decimal decoding do not require intermediate objects to be allocated. These optimizations all leverage the way Okio stores data internally. Okio Buffers are implemented using a doubly-linked list of segments. Each segment is a contiguous range within a 8 KiB ByteArray. Each segment has two indexes, start, the offset of the first byte of the array containing application data, and end, the offset of the first byte beyond start whose data is undefined.New buffers are empty and have no segments:val buffer = Buffer()We append 7 bytes of data to the end of our empty buffer. Internally, the buffer allocates a segment and writes its new data there. The lone segment has an 8 KiB byte array but only 7 bytes of data:buffer.writeUtf8(\u201csealion\u201d) // [ \u2018s\u2019, \u2018e\u2019, \u2018a\u2019, \u2018l\u2019, \u2018i\u2019, \u2018o\u2019, \u2018n\u2019, \u2018?\u2019, \u2018?\u2019, \u2018?\u2019, \u2026] // ^ ^ // start = 0 end = 7When we read 4 bytes of data from the buffer, it finds its first segment and returns that data to us. As bytes are read the data is consumed. The segment tracks this by adjusting its internal indices.buffer.readUtf8(4) // \u201cseal\u201d // [ \u2018s\u2019, \u2018e\u2019, \u2018a\u2019, \u2018l\u2019, \u2018i\u2019, \u2018o\u2019, \u2018n\u2019, \u2018?\u2019, \u2018?\u2019, \u2018?\u2019, \u2026] // ^ ^ // start = 4 end = 7As we write data into a buffer we fill up its internal segments. When a write doesn\u2019t fit into a buffer\u2019s last segment, additional segments are allocated and appended to the linked list of segments. Each segment has its own start and end indexes tracking where the user\u2019s data begins and ends.val xoxo = new Buffer() xoxo.writeUtf8(\u201cxo\u201d.repeat(5_000)) // [ \u2018x\u2019, \u2018o\u2019, \u2018x\u2019, \u2018o\u2019, \u2018x\u2019, \u2018o\u2019, \u2018x\u2019, \u2018o\u2019, \u2026, \u2018x\u2019, \u2018o\u2019, \u2018x\u2019, \u2018o\u2019] // ^ ^ // start = 0 end = 8192 // // [ \u2018x\u2019, \u2018o\u2019, \u2018x\u2019, \u2018o\u2019, \u2026, \u2018x\u2019, \u2018o\u2019, \u2018x\u2019, \u2018o\u2019, \u2018?\u2019, \u2018?\u2019, \u2018?\u2019, \u2026] // ^ ^ // start = 0 end = 1808The start index is always inclusive and the end index is always exclusive . The data preceding the start index is undefined, and the data at and following the end index is undefined.After the last byte of a segment has been read, that segment may be returned to an internal segment pool. In addition to reducing the need to do garbage collection, segment pooling also saves the JVM from needing to zero-fill byte arrays. Okio doesn\u2019t need to zero-fill its arrays because it always writes memory before it reads it. But if you look at a segment in a debugger you may see its effects. In this example, one of the \u201cxoxo\u201d segments above is reused in an unrelated buffer:val abc = new Buffer() abc.writeUtf8(\u201cabc\u201d) // [ \u2018a\u2019, \u2018b\u2019, \u2018c\u2019, \u2018o\u2019, \u2018x\u2019, \u2018o\u2019, \u2018x\u2019, \u2018o\u2019, \u2026] // ^ ^ // start = 0 end = 3There is an optimization in Buffer.clone() and other methods that allows two segments to share the same underlying byte array. Clones can\u2019t write to the shared byte array; instead they allocate a new (private) segment early.val nana = new Buffer() nana.writeUtf8(\u201cna\u201d.repeat(2_500)) nana.readUtf8(2) // \u201cna\u201d // [ \u2018n\u2019, \u2018a\u2019, \u2018n\u2019, \u2018a\u2019, \u2026, \u2018n\u2019, \u2018a\u2019, \u2018n\u2019, \u2018a\u2019, \u2018?\u2019, \u2018?\u2019, \u2018?\u2019, \u2026] // ^ ^ // start = 2 end = 5000 nana2 = nana.clone() nana2.writeUtf8(\u201cbatman\u201d) // [ \u2018n\u2019, \u2018a\u2019, \u2018n\u2019, \u2018a\u2019, \u2026, \u2018n\u2019, \u2018a\u2019, \u2018n\u2019, \u2018a\u2019, \u2018?\u2019, \u2018?\u2019, \u2018?\u2019, \u2026] // ^ ^ // start = 2 end = 5000 // // [ \u2018b\u2019, \u2018a\u2019, \u2018t\u2019, \u2018m\u2019, \u2018a\u2019, \u2018n\u2019, \u2018?\u2019, \u2018?\u2019, \u2018?\u2019, \u2026] // ^ ^ // start = 0 end = 6Segments are not shared when the shared region is small (ie. less than 1 KiB). This is intended to prevent fragmentation in sharing-heavy use cases.Unsafe Cursor API -----------------This class exposes privileged access to the internal byte arrays of a buffer. A cursor either references the data of a single segment, it is before the first segment (offset == -1), or it is after the last segment (offset == buffer.size).Call UnsafeCursor.seek to move the cursor to the segment that contains a specified offset. After seeking, UnsafeCursor.data references the segment\u2019s internal byte array, UnsafeCursor.start is the segment\u2019s start and UnsafeCursor.end is its end.Call UnsafeCursor.next to advance the cursor to the next segment. This returns -1 if there are no further segments in the buffer.Use Buffer.readUnsafe to create a cursor to read buffer data and Buffer.readAndWriteUnsafe to create a cursor to read and write buffer data. In either case, always call UnsafeCursor.close when done with a cursor. This is convenient with Kotlin\u2019s use extension function. In this example we read all of the bytes in a buffer into a byte array:val bufferBytes = ByteArray(buffer.size.toInt()) buffer.readUnsafe().use { cursor -> while (cursor.next() != -1) { System.arraycopy(cursor.data, cursor.start, bufferBytes, cursor.offset.toInt(), cursor.end - cursor.start); } }Change the capacity of a buffer with resizeBuffer . This is only permitted for read+write cursors. The buffer\u2019s size always changes from the end: shrinking it removes bytes from the end; growing it adds capacity to the end.Warnings --------Most application developers should avoid this API. Those that must use this API should respect these warnings. This class has public, non-final fields because that is convenient for low-level I/O frameworks. Never assign values to these fields; instead use the cursor API to adjust these. data You are on the honor system to never write the buffer in read-only mode. Read-only mode may be more efficient than read+write mode because it does not need to make private copies of shared segments. [start..end) Other data in the byte array is undefined! It may contain private or sensitive data from other parts of your process. Always fill the new capacity when you grow a buffer. New capacity is not zero-filled and may contain data from other parts of your process. Avoid leaking this information by always writing something to the newly-allocated capacity. Do not assume that new capacity will be filled with 0; it will not be. Do not access a buffer while is being accessed by a cursor. Even simple read-only operations like Buffer.clone are unsafe because they mark segments as shared. Do not hard-code the segment size in your application. It is possible that segment sizes will change with advances in hardware. Future versions of Okio may even have heterogeneous segment sizes.These warnings are intended to help you to use this API safely. It\u2019s here for developers that need absolutely the most throughput. Since that\u2019s you, here\u2019s one final performance tip. You can reuse instances of this class if you like. Use the overloads of Buffer.readUnsafe and Buffer.readAndWriteUnsafe that take a cursor and close it after use. Content class UnsafeCursor : Closeable Functions \u00b6 Name Summary buffer [jvm] Brief description Returns this source\u2019s internal buffer. Content open override fun buffer (): Buffer clear [js, jvm, native] Content [js, jvm, native] fun clear () clone [jvm] Brief description Returns a deep copy of this buffer. Content open override fun clone (): Buffer close [js, jvm, native] Content [js, jvm, native] open override fun close () completeSegmentByteCount [js, jvm, native] Content [js, jvm, native] fun completeSegmentByteCount (): Long copy [js, jvm, native] Content [js, jvm, native] fun copy (): Buffer copyTo [js, jvm, native] Content [js, jvm, native] fun copyTo (out: Buffer , offset: Long , byteCount: Long ): Buffer [js, jvm, native] fun copyTo (out: Buffer , offset: Long ): Buffer [jvm] Brief description Copy byteCount bytes from this, starting at offset, to out. Content @ JvmOverloads () fun copyTo (out: OutputStream , offset: Long , byteCount: Long ): Buffer emit [js, jvm, native] Content [js, jvm, native] open override fun emit (): Buffer emitCompleteSegments [js, jvm, native] Content [js, jvm, native] open override fun emitCompleteSegments (): Buffer equals [js, jvm, native] Content [js, jvm, native] open operator override fun equals (other: Any ?): Boolean exhausted [js, jvm, native] Content [js, jvm, native] open override fun exhausted (): Boolean flush [js, jvm, native] Content [js, jvm, native] open override fun flush () get [js, jvm, native] Content [js, native] operator fun get (pos: Long ): Byte [jvm] @ JvmName (name = \u201cgetByte\u201d) operator fun get (pos: Long ): Byte hashCode [js, jvm, native] Content [js, jvm, native] open override fun hashCode (): Int hmacSha1 [jvm] Brief description Returns the 160-bit SHA-1 HMAC of this buffer. Content fun hmacSha1 (key: ByteString ): ByteString hmacSha256 [jvm] Brief description Returns the 256-bit SHA-256 HMAC of this buffer. Content fun hmacSha256 (key: ByteString ): ByteString hmacSha512 [jvm] Brief description Returns the 512-bit SHA-512 HMAC of this buffer. Content fun hmacSha512 (key: ByteString ): ByteString indexOf [js, jvm, native] Content [js, jvm, native] open override fun indexOf (b: Byte ): Long [js, native] open override fun indexOf (b: Byte , fromIndex: Long ): Long [js, jvm, native] open override fun indexOf (b: Byte , fromIndex: Long , toIndex: Long ): Long [js, jvm, native] open override fun indexOf (bytes: ByteString ): Long [js, jvm, native] open override fun indexOf (bytes: ByteString , fromIndex: Long ): Long [jvm] Brief description Returns the index of b in this at or beyond fromIndex, or -1 if this buffer does not contain b in that range. Content open override fun indexOf (b: Byte , fromIndex: Long ): Long indexOfElement [js, jvm, native] Content [js, jvm, native] open override fun indexOfElement (targetBytes: ByteString ): Long [js, jvm, native] open override fun indexOfElement (targetBytes: ByteString , fromIndex: Long ): Long inputStream [jvm] Brief description Returns an input stream that reads from this source. Content open override fun inputStream (): InputStream isOpen [jvm] Content open override fun isOpen (): Boolean md5 [jvm] Brief description Returns the 128-bit MD5 hash of this buffer. Content fun md5 (): ByteString outputStream [jvm] Brief description Returns an output stream that writes to this sink. Content open override fun outputStream (): OutputStream peek [js, jvm, native] Content [js, jvm, native] open override fun peek (): BufferedSource rangeEquals [js, jvm, native] Content [js, jvm, native] open override fun rangeEquals (offset: Long , bytes: ByteString ): Boolean [js, jvm, native] open override fun rangeEquals (offset: Long , bytes: ByteString , bytesOffset: Int , byteCount: Int ): Boolean read [js, jvm, native] Content [js, jvm, native] open override fun read (sink: ByteArray ): Int [js, jvm, native] open override fun read (sink: ByteArray , offset: Int , byteCount: Int ): Int [js, jvm, native] open override fun read (sink: Buffer , byteCount: Long ): Long [jvm] open override fun read (sink: ByteBuffer ): Int readAll [js, jvm, native] Content [js, jvm, native] open override fun readAll (sink: Sink ): Long readAndWriteUnsafe [jvm] Content @ JvmOverloads () fun readAndWriteUnsafe (unsafeCursor: Buffer.UnsafeCursor ): Buffer.UnsafeCursor readByte [js, jvm, native] Content [js, jvm, native] open override fun readByte (): Byte readByteArray [js, jvm, native] Content [js, jvm, native] open override fun readByteArray (): ByteArray [js, jvm, native] open override fun readByteArray (byteCount: Long ): ByteArray readByteString [js, jvm, native] Content [js, jvm, native] open override fun readByteString (): ByteString [js, jvm, native] open override fun readByteString (byteCount: Long ): ByteString readDecimalLong [js, jvm, native] Content [js, jvm, native] open override fun readDecimalLong (): Long readFrom [jvm] Brief description Read and exhaust bytes from input into this. Content fun readFrom (input: InputStream ): Buffer [jvm] Brief description Read byteCount bytes from input into this. Content fun readFrom (input: InputStream , byteCount: Long ): Buffer readFully [js, jvm, native] Content [js, jvm, native] open override fun readFully (sink: Buffer , byteCount: Long ) [js, jvm, native] open override fun readFully (sink: ByteArray ) readHexadecimalUnsignedLong [js, jvm, native] Content [js, jvm, native] open override fun readHexadecimalUnsignedLong (): Long readInt [js, jvm, native] Content [js, jvm, native] open override fun readInt (): Int readIntLe [js, jvm, native] Content [js, jvm, native] open override fun readIntLe (): Int readLong [js, jvm, native] Content [js, jvm, native] open override fun readLong (): Long readLongLe [js, jvm, native] Content [js, jvm, native] open override fun readLongLe (): Long readShort [js, jvm, native] Content [js, jvm, native] open override fun readShort (): Short readShortLe [js, jvm, native] Content [js, jvm, native] open override fun readShortLe (): Short readString [jvm] Brief description Removes all bytes from this, decodes them as charset, and returns the string. Content open override fun readString (charset: Charset ): String [jvm] Brief description Removes byteCount bytes from this, decodes them as charset, and returns the string. Content open override fun readString (byteCount: Long , charset: Charset ): String readUnsafe [jvm] Content @ JvmOverloads () fun readUnsafe (unsafeCursor: Buffer.UnsafeCursor ): Buffer.UnsafeCursor readUtf8 [js, jvm, native] Content [js, jvm, native] open override fun readUtf8 (): String [js, jvm, native] open override fun readUtf8 (byteCount: Long ): String readUtf8CodePoint [js, jvm, native] Content [js, jvm, native] open override fun readUtf8CodePoint (): Int readUtf8Line [js, jvm, native] Content [js, jvm, native] open override fun readUtf8Line (): String ? readUtf8LineStrict [js, jvm, native] Content [js, jvm, native] open override fun readUtf8LineStrict (): String [js, jvm, native] open override fun readUtf8LineStrict (limit: Long ): String request [js, jvm, native] Content [js, jvm, native] open override fun request (byteCount: Long ): Boolean require [js, jvm, native] Content [js, jvm, native] open override fun require (byteCount: Long ) select [js, jvm, native] Content [js, jvm, native] open override fun select (options: ): Int sha1 [jvm] Brief description Returns the 160-bit SHA-1 hash of this buffer. Content fun sha1 (): ByteString sha256 [jvm] Brief description Returns the 256-bit SHA-256 hash of this buffer. Content fun sha256 (): ByteString sha512 [jvm] Brief description Returns the 512-bit SHA-512 hash of this buffer. Content fun sha512 (): ByteString skip [js, jvm, native] Content [js, jvm, native] open override fun skip (byteCount: Long ) snapshot [js, jvm, native] Content [js, jvm, native] fun snapshot (): ByteString [js, jvm, native] fun snapshot (byteCount: Int ): ByteString timeout [js, jvm, native] Content [js, jvm, native] open override fun timeout (): Timeout toString [js, jvm, native] Brief description Returns a human-readable string that describes the contents of this buffer. Typically this is a string like [text=Hello] or [hex=0000ffff]. Content [js, jvm, native] open override fun toString (): write [js, jvm, native] Content [js, jvm, native] open override fun write (byteString: ByteString ): Buffer [js, jvm, native] open override fun write (byteString: ByteString , offset: Int , byteCount: Int ): [js, jvm, native] open override fun write (source: ByteArray ): Buffer [js, jvm, native] open override fun write (source: ByteArray , offset: Int , byteCount: Int ): Buffer [js, jvm, native] open override fun write (source: Source , byteCount: Long ): Buffer [js, jvm, native] open override fun write (source: Buffer , byteCount: Long ) [jvm] open override fun write (source: ByteBuffer ): Int writeAll [js, jvm, native] Content [js, jvm, native] open override fun writeAll (source: Source ): Long writeByte [js, jvm, native] Content [js, jvm, native] open override fun writeByte (b: Int ): Buffer writeDecimalLong [js, jvm, native] Content [js, jvm, native] open override fun writeDecimalLong (v: Long ): Buffer writeHexadecimalUnsignedLong [js, jvm, native] Content [js, jvm, native] open override fun writeHexadecimalUnsignedLong (v: Long ): Buffer writeInt [js, jvm, native] Content [js, jvm, native] open override fun writeInt (i: Int ): Buffer writeIntLe [js, jvm, native] Content [js, jvm, native] open override fun writeIntLe (i: Int ): Buffer writeLong [js, jvm, native] Content [js, jvm, native] open override fun writeLong (v: Long ): Buffer writeLongLe [js, jvm, native] Content [js, jvm, native] open override fun writeLongLe (v: Long ): Buffer writeShort [js, jvm, native] Content [js, jvm, native] open override fun writeShort (s: Int ): Buffer writeShortLe [js, jvm, native] Content [js, jvm, native] open override fun writeShortLe (s: Int ): Buffer writeString [jvm] Content open override fun writeString (string: String , charset: Charset ): Buffer open override fun writeString (string: String , beginIndex: Int , endIndex: Int , charset: Charset ): Buffer writeTo [jvm] Brief description Write byteCount bytes from this to out. Content @ JvmOverloads () fun writeTo (out: OutputStream , byteCount: Long ): Buffer writeUtf8 [js, jvm, native] Content [js, jvm, native] open override fun writeUtf8 (string: String ): Buffer [js, jvm, native] open override fun writeUtf8 (string: String , beginIndex: Int , endIndex: Int ): Buffer writeUtf8CodePoint [js, jvm, native] Content [js, jvm, native] open override fun writeUtf8CodePoint (codePoint: Int ): Buffer Properties \u00b6 Name Summary buffer [js, jvm, native] open override val buffer : Buffer size [js, jvm, native] var size : Long","title":"Buffer   - Okio"},{"location":"2.x/okio/okio/-buffer/#buffer","text":"[js, native] class Buffer : BufferedSource , BufferedSink [jvm] class Buffer : BufferedSource , BufferedSink , Cloneable , ByteChannel","title":"Buffer"},{"location":"2.x/okio/okio/-buffer/#types","text":"Name Summary UnsafeCursor [jvm] Brief description A handle to the underlying data in a buffer. This handle is unsafe because it does not enforce its own invariants. Instead, it assumes a careful user who has studied Okio\u2019s implementation details and their consequences.Buffer Internals ----------------Most code should use Buffer as a black box: a class that holds 0 or more bytes of data with efficient APIs to append data to the end and to consume data from the front. Usually this is also the most efficient way to use buffers because it allows Okio to employ several optimizations, including: Buffers use a shared pool of memory that is not zero-filled before use. A buffer\u2019s capacity can change without copying its contents. Memory ownership can be reassigned from one buffer to another. Multiple buffers can share the same underlying memory. Common operations like UTF-8 encoding and decimal decoding do not require intermediate objects to be allocated. These optimizations all leverage the way Okio stores data internally. Okio Buffers are implemented using a doubly-linked list of segments. Each segment is a contiguous range within a 8 KiB ByteArray. Each segment has two indexes, start, the offset of the first byte of the array containing application data, and end, the offset of the first byte beyond start whose data is undefined.New buffers are empty and have no segments:val buffer = Buffer()We append 7 bytes of data to the end of our empty buffer. Internally, the buffer allocates a segment and writes its new data there. The lone segment has an 8 KiB byte array but only 7 bytes of data:buffer.writeUtf8(\u201csealion\u201d) // [ \u2018s\u2019, \u2018e\u2019, \u2018a\u2019, \u2018l\u2019, \u2018i\u2019, \u2018o\u2019, \u2018n\u2019, \u2018?\u2019, \u2018?\u2019, \u2018?\u2019, \u2026] // ^ ^ // start = 0 end = 7When we read 4 bytes of data from the buffer, it finds its first segment and returns that data to us. As bytes are read the data is consumed. The segment tracks this by adjusting its internal indices.buffer.readUtf8(4) // \u201cseal\u201d // [ \u2018s\u2019, \u2018e\u2019, \u2018a\u2019, \u2018l\u2019, \u2018i\u2019, \u2018o\u2019, \u2018n\u2019, \u2018?\u2019, \u2018?\u2019, \u2018?\u2019, \u2026] // ^ ^ // start = 4 end = 7As we write data into a buffer we fill up its internal segments. When a write doesn\u2019t fit into a buffer\u2019s last segment, additional segments are allocated and appended to the linked list of segments. Each segment has its own start and end indexes tracking where the user\u2019s data begins and ends.val xoxo = new Buffer() xoxo.writeUtf8(\u201cxo\u201d.repeat(5_000)) // [ \u2018x\u2019, \u2018o\u2019, \u2018x\u2019, \u2018o\u2019, \u2018x\u2019, \u2018o\u2019, \u2018x\u2019, \u2018o\u2019, \u2026, \u2018x\u2019, \u2018o\u2019, \u2018x\u2019, \u2018o\u2019] // ^ ^ // start = 0 end = 8192 // // [ \u2018x\u2019, \u2018o\u2019, \u2018x\u2019, \u2018o\u2019, \u2026, \u2018x\u2019, \u2018o\u2019, \u2018x\u2019, \u2018o\u2019, \u2018?\u2019, \u2018?\u2019, \u2018?\u2019, \u2026] // ^ ^ // start = 0 end = 1808The start index is always inclusive and the end index is always exclusive . The data preceding the start index is undefined, and the data at and following the end index is undefined.After the last byte of a segment has been read, that segment may be returned to an internal segment pool. In addition to reducing the need to do garbage collection, segment pooling also saves the JVM from needing to zero-fill byte arrays. Okio doesn\u2019t need to zero-fill its arrays because it always writes memory before it reads it. But if you look at a segment in a debugger you may see its effects. In this example, one of the \u201cxoxo\u201d segments above is reused in an unrelated buffer:val abc = new Buffer() abc.writeUtf8(\u201cabc\u201d) // [ \u2018a\u2019, \u2018b\u2019, \u2018c\u2019, \u2018o\u2019, \u2018x\u2019, \u2018o\u2019, \u2018x\u2019, \u2018o\u2019, \u2026] // ^ ^ // start = 0 end = 3There is an optimization in Buffer.clone() and other methods that allows two segments to share the same underlying byte array. Clones can\u2019t write to the shared byte array; instead they allocate a new (private) segment early.val nana = new Buffer() nana.writeUtf8(\u201cna\u201d.repeat(2_500)) nana.readUtf8(2) // \u201cna\u201d // [ \u2018n\u2019, \u2018a\u2019, \u2018n\u2019, \u2018a\u2019, \u2026, \u2018n\u2019, \u2018a\u2019, \u2018n\u2019, \u2018a\u2019, \u2018?\u2019, \u2018?\u2019, \u2018?\u2019, \u2026] // ^ ^ // start = 2 end = 5000 nana2 = nana.clone() nana2.writeUtf8(\u201cbatman\u201d) // [ \u2018n\u2019, \u2018a\u2019, \u2018n\u2019, \u2018a\u2019, \u2026, \u2018n\u2019, \u2018a\u2019, \u2018n\u2019, \u2018a\u2019, \u2018?\u2019, \u2018?\u2019, \u2018?\u2019, \u2026] // ^ ^ // start = 2 end = 5000 // // [ \u2018b\u2019, \u2018a\u2019, \u2018t\u2019, \u2018m\u2019, \u2018a\u2019, \u2018n\u2019, \u2018?\u2019, \u2018?\u2019, \u2018?\u2019, \u2026] // ^ ^ // start = 0 end = 6Segments are not shared when the shared region is small (ie. less than 1 KiB). This is intended to prevent fragmentation in sharing-heavy use cases.Unsafe Cursor API -----------------This class exposes privileged access to the internal byte arrays of a buffer. A cursor either references the data of a single segment, it is before the first segment (offset == -1), or it is after the last segment (offset == buffer.size).Call UnsafeCursor.seek to move the cursor to the segment that contains a specified offset. After seeking, UnsafeCursor.data references the segment\u2019s internal byte array, UnsafeCursor.start is the segment\u2019s start and UnsafeCursor.end is its end.Call UnsafeCursor.next to advance the cursor to the next segment. This returns -1 if there are no further segments in the buffer.Use Buffer.readUnsafe to create a cursor to read buffer data and Buffer.readAndWriteUnsafe to create a cursor to read and write buffer data. In either case, always call UnsafeCursor.close when done with a cursor. This is convenient with Kotlin\u2019s use extension function. In this example we read all of the bytes in a buffer into a byte array:val bufferBytes = ByteArray(buffer.size.toInt()) buffer.readUnsafe().use { cursor -> while (cursor.next() != -1) { System.arraycopy(cursor.data, cursor.start, bufferBytes, cursor.offset.toInt(), cursor.end - cursor.start); } }Change the capacity of a buffer with resizeBuffer . This is only permitted for read+write cursors. The buffer\u2019s size always changes from the end: shrinking it removes bytes from the end; growing it adds capacity to the end.Warnings --------Most application developers should avoid this API. Those that must use this API should respect these warnings. This class has public, non-final fields because that is convenient for low-level I/O frameworks. Never assign values to these fields; instead use the cursor API to adjust these. data You are on the honor system to never write the buffer in read-only mode. Read-only mode may be more efficient than read+write mode because it does not need to make private copies of shared segments. [start..end) Other data in the byte array is undefined! It may contain private or sensitive data from other parts of your process. Always fill the new capacity when you grow a buffer. New capacity is not zero-filled and may contain data from other parts of your process. Avoid leaking this information by always writing something to the newly-allocated capacity. Do not assume that new capacity will be filled with 0; it will not be. Do not access a buffer while is being accessed by a cursor. Even simple read-only operations like Buffer.clone are unsafe because they mark segments as shared. Do not hard-code the segment size in your application. It is possible that segment sizes will change with advances in hardware. Future versions of Okio may even have heterogeneous segment sizes.These warnings are intended to help you to use this API safely. It\u2019s here for developers that need absolutely the most throughput. Since that\u2019s you, here\u2019s one final performance tip. You can reuse instances of this class if you like. Use the overloads of Buffer.readUnsafe and Buffer.readAndWriteUnsafe that take a cursor and close it after use. Content class UnsafeCursor : Closeable","title":"Types"},{"location":"2.x/okio/okio/-buffer/#functions","text":"Name Summary buffer [jvm] Brief description Returns this source\u2019s internal buffer. Content open override fun buffer (): Buffer clear [js, jvm, native] Content [js, jvm, native] fun clear () clone [jvm] Brief description Returns a deep copy of this buffer. Content open override fun clone (): Buffer close [js, jvm, native] Content [js, jvm, native] open override fun close () completeSegmentByteCount [js, jvm, native] Content [js, jvm, native] fun completeSegmentByteCount (): Long copy [js, jvm, native] Content [js, jvm, native] fun copy (): Buffer copyTo [js, jvm, native] Content [js, jvm, native] fun copyTo (out: Buffer , offset: Long , byteCount: Long ): Buffer [js, jvm, native] fun copyTo (out: Buffer , offset: Long ): Buffer [jvm] Brief description Copy byteCount bytes from this, starting at offset, to out. Content @ JvmOverloads () fun copyTo (out: OutputStream , offset: Long , byteCount: Long ): Buffer emit [js, jvm, native] Content [js, jvm, native] open override fun emit (): Buffer emitCompleteSegments [js, jvm, native] Content [js, jvm, native] open override fun emitCompleteSegments (): Buffer equals [js, jvm, native] Content [js, jvm, native] open operator override fun equals (other: Any ?): Boolean exhausted [js, jvm, native] Content [js, jvm, native] open override fun exhausted (): Boolean flush [js, jvm, native] Content [js, jvm, native] open override fun flush () get [js, jvm, native] Content [js, native] operator fun get (pos: Long ): Byte [jvm] @ JvmName (name = \u201cgetByte\u201d) operator fun get (pos: Long ): Byte hashCode [js, jvm, native] Content [js, jvm, native] open override fun hashCode (): Int hmacSha1 [jvm] Brief description Returns the 160-bit SHA-1 HMAC of this buffer. Content fun hmacSha1 (key: ByteString ): ByteString hmacSha256 [jvm] Brief description Returns the 256-bit SHA-256 HMAC of this buffer. Content fun hmacSha256 (key: ByteString ): ByteString hmacSha512 [jvm] Brief description Returns the 512-bit SHA-512 HMAC of this buffer. Content fun hmacSha512 (key: ByteString ): ByteString indexOf [js, jvm, native] Content [js, jvm, native] open override fun indexOf (b: Byte ): Long [js, native] open override fun indexOf (b: Byte , fromIndex: Long ): Long [js, jvm, native] open override fun indexOf (b: Byte , fromIndex: Long , toIndex: Long ): Long [js, jvm, native] open override fun indexOf (bytes: ByteString ): Long [js, jvm, native] open override fun indexOf (bytes: ByteString , fromIndex: Long ): Long [jvm] Brief description Returns the index of b in this at or beyond fromIndex, or -1 if this buffer does not contain b in that range. Content open override fun indexOf (b: Byte , fromIndex: Long ): Long indexOfElement [js, jvm, native] Content [js, jvm, native] open override fun indexOfElement (targetBytes: ByteString ): Long [js, jvm, native] open override fun indexOfElement (targetBytes: ByteString , fromIndex: Long ): Long inputStream [jvm] Brief description Returns an input stream that reads from this source. Content open override fun inputStream (): InputStream isOpen [jvm] Content open override fun isOpen (): Boolean md5 [jvm] Brief description Returns the 128-bit MD5 hash of this buffer. Content fun md5 (): ByteString outputStream [jvm] Brief description Returns an output stream that writes to this sink. Content open override fun outputStream (): OutputStream peek [js, jvm, native] Content [js, jvm, native] open override fun peek (): BufferedSource rangeEquals [js, jvm, native] Content [js, jvm, native] open override fun rangeEquals (offset: Long , bytes: ByteString ): Boolean [js, jvm, native] open override fun rangeEquals (offset: Long , bytes: ByteString , bytesOffset: Int , byteCount: Int ): Boolean read [js, jvm, native] Content [js, jvm, native] open override fun read (sink: ByteArray ): Int [js, jvm, native] open override fun read (sink: ByteArray , offset: Int , byteCount: Int ): Int [js, jvm, native] open override fun read (sink: Buffer , byteCount: Long ): Long [jvm] open override fun read (sink: ByteBuffer ): Int readAll [js, jvm, native] Content [js, jvm, native] open override fun readAll (sink: Sink ): Long readAndWriteUnsafe [jvm] Content @ JvmOverloads () fun readAndWriteUnsafe (unsafeCursor: Buffer.UnsafeCursor ): Buffer.UnsafeCursor readByte [js, jvm, native] Content [js, jvm, native] open override fun readByte (): Byte readByteArray [js, jvm, native] Content [js, jvm, native] open override fun readByteArray (): ByteArray [js, jvm, native] open override fun readByteArray (byteCount: Long ): ByteArray readByteString [js, jvm, native] Content [js, jvm, native] open override fun readByteString (): ByteString [js, jvm, native] open override fun readByteString (byteCount: Long ): ByteString readDecimalLong [js, jvm, native] Content [js, jvm, native] open override fun readDecimalLong (): Long readFrom [jvm] Brief description Read and exhaust bytes from input into this. Content fun readFrom (input: InputStream ): Buffer [jvm] Brief description Read byteCount bytes from input into this. Content fun readFrom (input: InputStream , byteCount: Long ): Buffer readFully [js, jvm, native] Content [js, jvm, native] open override fun readFully (sink: Buffer , byteCount: Long ) [js, jvm, native] open override fun readFully (sink: ByteArray ) readHexadecimalUnsignedLong [js, jvm, native] Content [js, jvm, native] open override fun readHexadecimalUnsignedLong (): Long readInt [js, jvm, native] Content [js, jvm, native] open override fun readInt (): Int readIntLe [js, jvm, native] Content [js, jvm, native] open override fun readIntLe (): Int readLong [js, jvm, native] Content [js, jvm, native] open override fun readLong (): Long readLongLe [js, jvm, native] Content [js, jvm, native] open override fun readLongLe (): Long readShort [js, jvm, native] Content [js, jvm, native] open override fun readShort (): Short readShortLe [js, jvm, native] Content [js, jvm, native] open override fun readShortLe (): Short readString [jvm] Brief description Removes all bytes from this, decodes them as charset, and returns the string. Content open override fun readString (charset: Charset ): String [jvm] Brief description Removes byteCount bytes from this, decodes them as charset, and returns the string. Content open override fun readString (byteCount: Long , charset: Charset ): String readUnsafe [jvm] Content @ JvmOverloads () fun readUnsafe (unsafeCursor: Buffer.UnsafeCursor ): Buffer.UnsafeCursor readUtf8 [js, jvm, native] Content [js, jvm, native] open override fun readUtf8 (): String [js, jvm, native] open override fun readUtf8 (byteCount: Long ): String readUtf8CodePoint [js, jvm, native] Content [js, jvm, native] open override fun readUtf8CodePoint (): Int readUtf8Line [js, jvm, native] Content [js, jvm, native] open override fun readUtf8Line (): String ? readUtf8LineStrict [js, jvm, native] Content [js, jvm, native] open override fun readUtf8LineStrict (): String [js, jvm, native] open override fun readUtf8LineStrict (limit: Long ): String request [js, jvm, native] Content [js, jvm, native] open override fun request (byteCount: Long ): Boolean require [js, jvm, native] Content [js, jvm, native] open override fun require (byteCount: Long ) select [js, jvm, native] Content [js, jvm, native] open override fun select (options: ): Int sha1 [jvm] Brief description Returns the 160-bit SHA-1 hash of this buffer. Content fun sha1 (): ByteString sha256 [jvm] Brief description Returns the 256-bit SHA-256 hash of this buffer. Content fun sha256 (): ByteString sha512 [jvm] Brief description Returns the 512-bit SHA-512 hash of this buffer. Content fun sha512 (): ByteString skip [js, jvm, native] Content [js, jvm, native] open override fun skip (byteCount: Long ) snapshot [js, jvm, native] Content [js, jvm, native] fun snapshot (): ByteString [js, jvm, native] fun snapshot (byteCount: Int ): ByteString timeout [js, jvm, native] Content [js, jvm, native] open override fun timeout (): Timeout toString [js, jvm, native] Brief description Returns a human-readable string that describes the contents of this buffer. Typically this is a string like [text=Hello] or [hex=0000ffff]. Content [js, jvm, native] open override fun toString (): write [js, jvm, native] Content [js, jvm, native] open override fun write (byteString: ByteString ): Buffer [js, jvm, native] open override fun write (byteString: ByteString , offset: Int , byteCount: Int ): [js, jvm, native] open override fun write (source: ByteArray ): Buffer [js, jvm, native] open override fun write (source: ByteArray , offset: Int , byteCount: Int ): Buffer [js, jvm, native] open override fun write (source: Source , byteCount: Long ): Buffer [js, jvm, native] open override fun write (source: Buffer , byteCount: Long ) [jvm] open override fun write (source: ByteBuffer ): Int writeAll [js, jvm, native] Content [js, jvm, native] open override fun writeAll (source: Source ): Long writeByte [js, jvm, native] Content [js, jvm, native] open override fun writeByte (b: Int ): Buffer writeDecimalLong [js, jvm, native] Content [js, jvm, native] open override fun writeDecimalLong (v: Long ): Buffer writeHexadecimalUnsignedLong [js, jvm, native] Content [js, jvm, native] open override fun writeHexadecimalUnsignedLong (v: Long ): Buffer writeInt [js, jvm, native] Content [js, jvm, native] open override fun writeInt (i: Int ): Buffer writeIntLe [js, jvm, native] Content [js, jvm, native] open override fun writeIntLe (i: Int ): Buffer writeLong [js, jvm, native] Content [js, jvm, native] open override fun writeLong (v: Long ): Buffer writeLongLe [js, jvm, native] Content [js, jvm, native] open override fun writeLongLe (v: Long ): Buffer writeShort [js, jvm, native] Content [js, jvm, native] open override fun writeShort (s: Int ): Buffer writeShortLe [js, jvm, native] Content [js, jvm, native] open override fun writeShortLe (s: Int ): Buffer writeString [jvm] Content open override fun writeString (string: String , charset: Charset ): Buffer open override fun writeString (string: String , beginIndex: Int , endIndex: Int , charset: Charset ): Buffer writeTo [jvm] Brief description Write byteCount bytes from this to out. Content @ JvmOverloads () fun writeTo (out: OutputStream , byteCount: Long ): Buffer writeUtf8 [js, jvm, native] Content [js, jvm, native] open override fun writeUtf8 (string: String ): Buffer [js, jvm, native] open override fun writeUtf8 (string: String , beginIndex: Int , endIndex: Int ): Buffer writeUtf8CodePoint [js, jvm, native] Content [js, jvm, native] open override fun writeUtf8CodePoint (codePoint: Int ): Buffer","title":"Functions"},{"location":"2.x/okio/okio/-buffer/#properties","text":"Name Summary buffer [js, jvm, native] open override val buffer : Buffer size [js, jvm, native] var size : Long","title":"Properties"},{"location":"2.x/okio/okio/-buffer/-init-/","text":"// okio / okio / Buffer / \u00b6 [js, jvm, native] Content [js, jvm, native] fun ()","title":"<init>   - Okio"},{"location":"2.x/okio/okio/-buffer/-init-/#_1","text":"[js, jvm, native] Content [js, jvm, native] fun ()","title":""},{"location":"2.x/okio/okio/-buffer/buffer/","text":"// okio / okio / Buffer / buffer buffer \u00b6 [jvm] Brief description Returns this source\u2019s internal buffer. Content open override fun buffer (): Buffer","title":"buffer   - Okio"},{"location":"2.x/okio/okio/-buffer/buffer/#buffer","text":"[jvm] Brief description Returns this source\u2019s internal buffer. Content open override fun buffer (): Buffer","title":"buffer"},{"location":"2.x/okio/okio/-buffer/clear/","text":"// okio / okio / Buffer / clear clear \u00b6 [js, jvm, native] Content [js, jvm, native] fun clear ()","title":"clear   - Okio"},{"location":"2.x/okio/okio/-buffer/clear/#clear","text":"[js, jvm, native] Content [js, jvm, native] fun clear ()","title":"clear"},{"location":"2.x/okio/okio/-buffer/clone/","text":"// okio / okio / Buffer / clone clone \u00b6 [jvm] Brief description Returns a deep copy of this buffer. Content open override fun clone (): Buffer","title":"clone   - Okio"},{"location":"2.x/okio/okio/-buffer/clone/#clone","text":"[jvm] Brief description Returns a deep copy of this buffer. Content open override fun clone (): Buffer","title":"clone"},{"location":"2.x/okio/okio/-buffer/close/","text":"// okio / okio / Buffer / close close \u00b6 [js, jvm, native] Content [js, jvm, native] open override fun close ()","title":"close   - Okio"},{"location":"2.x/okio/okio/-buffer/close/#close","text":"[js, jvm, native] Content [js, jvm, native] open override fun close ()","title":"close"},{"location":"2.x/okio/okio/-buffer/complete-segment-byte-count/","text":"// okio / okio / Buffer / completeSegmentByteCount completeSegmentByteCount \u00b6 [js, jvm, native] Content [js, jvm, native] fun completeSegmentByteCount (): Long","title":"completeSegmentByteCount   - Okio"},{"location":"2.x/okio/okio/-buffer/complete-segment-byte-count/#completesegmentbytecount","text":"[js, jvm, native] Content [js, jvm, native] fun completeSegmentByteCount (): Long","title":"completeSegmentByteCount"},{"location":"2.x/okio/okio/-buffer/copy-to/","text":"// okio / okio / Buffer / copyTo copyTo \u00b6 [js, jvm, native] Content [js, jvm, native] fun copyTo (out: Buffer , offset: Long , byteCount: Long ): Buffer [js, jvm, native] fun copyTo (out: Buffer , offset: Long ): Buffer [jvm] Brief description Copy byteCount bytes from this, starting at offset, to out. Content @ JvmOverloads () fun copyTo (out: OutputStream , offset: Long , byteCount: Long ): Buffer","title":"copyTo   - Okio"},{"location":"2.x/okio/okio/-buffer/copy-to/#copyto","text":"[js, jvm, native] Content [js, jvm, native] fun copyTo (out: Buffer , offset: Long , byteCount: Long ): Buffer [js, jvm, native] fun copyTo (out: Buffer , offset: Long ): Buffer [jvm] Brief description Copy byteCount bytes from this, starting at offset, to out. Content @ JvmOverloads () fun copyTo (out: OutputStream , offset: Long , byteCount: Long ): Buffer","title":"copyTo"},{"location":"2.x/okio/okio/-buffer/copy/","text":"// okio / okio / Buffer / copy copy \u00b6 [js, jvm, native] Content [js, jvm, native] fun copy (): Buffer","title":"copy   - Okio"},{"location":"2.x/okio/okio/-buffer/copy/#copy","text":"[js, jvm, native] Content [js, jvm, native] fun copy (): Buffer","title":"copy"},{"location":"2.x/okio/okio/-buffer/emit-complete-segments/","text":"// okio / okio / Buffer / emitCompleteSegments emitCompleteSegments \u00b6 [js, jvm, native] Content [js, jvm, native] open override fun emitCompleteSegments (): Buffer","title":"emitCompleteSegments   - Okio"},{"location":"2.x/okio/okio/-buffer/emit-complete-segments/#emitcompletesegments","text":"[js, jvm, native] Content [js, jvm, native] open override fun emitCompleteSegments (): Buffer","title":"emitCompleteSegments"},{"location":"2.x/okio/okio/-buffer/emit/","text":"// okio / okio / Buffer / emit emit \u00b6 [js, jvm, native] Content [js, jvm, native] open override fun emit (): Buffer","title":"emit   - Okio"},{"location":"2.x/okio/okio/-buffer/emit/#emit","text":"[js, jvm, native] Content [js, jvm, native] open override fun emit (): Buffer","title":"emit"},{"location":"2.x/okio/okio/-buffer/equals/","text":"// okio / okio / Buffer / equals equals \u00b6 [js, jvm, native] Content [js, jvm, native] open operator override fun equals (other: Any ?): Boolean","title":"equals   - Okio"},{"location":"2.x/okio/okio/-buffer/equals/#equals","text":"[js, jvm, native] Content [js, jvm, native] open operator override fun equals (other: Any ?): Boolean","title":"equals"},{"location":"2.x/okio/okio/-buffer/exhausted/","text":"// okio / okio / Buffer / exhausted exhausted \u00b6 [js, jvm, native] Content [js, jvm, native] open override fun exhausted (): Boolean","title":"exhausted   - Okio"},{"location":"2.x/okio/okio/-buffer/exhausted/#exhausted","text":"[js, jvm, native] Content [js, jvm, native] open override fun exhausted (): Boolean","title":"exhausted"},{"location":"2.x/okio/okio/-buffer/flush/","text":"// okio / okio / Buffer / flush flush \u00b6 [js, jvm, native] Content [js, jvm, native] open override fun flush ()","title":"flush   - Okio"},{"location":"2.x/okio/okio/-buffer/flush/#flush","text":"[js, jvm, native] Content [js, jvm, native] open override fun flush ()","title":"flush"},{"location":"2.x/okio/okio/-buffer/get/","text":"// okio / okio / Buffer / get get \u00b6 [js, jvm, native] Content [js, native] operator fun get (pos: Long ): Byte [jvm] @ JvmName (name = \u201cgetByte\u201d) operator fun get (pos: Long ): Byte","title":"get   - Okio"},{"location":"2.x/okio/okio/-buffer/get/#get","text":"[js, jvm, native] Content [js, native] operator fun get (pos: Long ): Byte [jvm] @ JvmName (name = \u201cgetByte\u201d) operator fun get (pos: Long ): Byte","title":"get"},{"location":"2.x/okio/okio/-buffer/hash-code/","text":"// okio / okio / Buffer / hashCode hashCode \u00b6 [js, jvm, native] Content [js, jvm, native] open override fun hashCode (): Int","title":"hashCode   - Okio"},{"location":"2.x/okio/okio/-buffer/hash-code/#hashcode","text":"[js, jvm, native] Content [js, jvm, native] open override fun hashCode (): Int","title":"hashCode"},{"location":"2.x/okio/okio/-buffer/hmac-sha1/","text":"// okio / okio / Buffer / hmacSha1 hmacSha1 \u00b6 [jvm] Brief description Returns the 160-bit SHA-1 HMAC of this buffer. Content fun hmacSha1 (key: ByteString ): ByteString","title":"hmacSha1   - Okio"},{"location":"2.x/okio/okio/-buffer/hmac-sha1/#hmacsha1","text":"[jvm] Brief description Returns the 160-bit SHA-1 HMAC of this buffer. Content fun hmacSha1 (key: ByteString ): ByteString","title":"hmacSha1"},{"location":"2.x/okio/okio/-buffer/hmac-sha256/","text":"// okio / okio / Buffer / hmacSha256 hmacSha256 \u00b6 [jvm] Brief description Returns the 256-bit SHA-256 HMAC of this buffer. Content fun hmacSha256 (key: ByteString ): ByteString","title":"hmacSha256   - Okio"},{"location":"2.x/okio/okio/-buffer/hmac-sha256/#hmacsha256","text":"[jvm] Brief description Returns the 256-bit SHA-256 HMAC of this buffer. Content fun hmacSha256 (key: ByteString ): ByteString","title":"hmacSha256"},{"location":"2.x/okio/okio/-buffer/hmac-sha512/","text":"// okio / okio / Buffer / hmacSha512 hmacSha512 \u00b6 [jvm] Brief description Returns the 512-bit SHA-512 HMAC of this buffer. Content fun hmacSha512 (key: ByteString ): ByteString","title":"hmacSha512   - Okio"},{"location":"2.x/okio/okio/-buffer/hmac-sha512/#hmacsha512","text":"[jvm] Brief description Returns the 512-bit SHA-512 HMAC of this buffer. Content fun hmacSha512 (key: ByteString ): ByteString","title":"hmacSha512"},{"location":"2.x/okio/okio/-buffer/index-of-element/","text":"// okio / okio / Buffer / indexOfElement indexOfElement \u00b6 [js, jvm, native] Content [js, jvm, native] open override fun indexOfElement (targetBytes: ByteString ): Long [js, jvm, native] open override fun indexOfElement (targetBytes: ByteString , fromIndex: Long ): Long","title":"indexOfElement   - Okio"},{"location":"2.x/okio/okio/-buffer/index-of-element/#indexofelement","text":"[js, jvm, native] Content [js, jvm, native] open override fun indexOfElement (targetBytes: ByteString ): Long [js, jvm, native] open override fun indexOfElement (targetBytes: ByteString , fromIndex: Long ): Long","title":"indexOfElement"},{"location":"2.x/okio/okio/-buffer/index-of/","text":"// okio / okio / Buffer / indexOf indexOf \u00b6 [js, jvm, native] Content [js, jvm, native] open override fun indexOf (b: Byte ): Long [js, native] open override fun indexOf (b: Byte , fromIndex: Long ): Long [js, jvm, native] open override fun indexOf (b: Byte , fromIndex: Long , toIndex: Long ): Long [js, jvm, native] open override fun indexOf (bytes: ByteString ): Long [js, jvm, native] open override fun indexOf (bytes: ByteString , fromIndex: Long ): Long [jvm] Brief description Returns the index of b in this at or beyond fromIndex, or -1 if this buffer does not contain b in that range. Content open override fun indexOf (b: Byte , fromIndex: Long ): Long","title":"indexOf   - Okio"},{"location":"2.x/okio/okio/-buffer/index-of/#indexof","text":"[js, jvm, native] Content [js, jvm, native] open override fun indexOf (b: Byte ): Long [js, native] open override fun indexOf (b: Byte , fromIndex: Long ): Long [js, jvm, native] open override fun indexOf (b: Byte , fromIndex: Long , toIndex: Long ): Long [js, jvm, native] open override fun indexOf (bytes: ByteString ): Long [js, jvm, native] open override fun indexOf (bytes: ByteString , fromIndex: Long ): Long [jvm] Brief description Returns the index of b in this at or beyond fromIndex, or -1 if this buffer does not contain b in that range. Content open override fun indexOf (b: Byte , fromIndex: Long ): Long","title":"indexOf"},{"location":"2.x/okio/okio/-buffer/input-stream/","text":"// okio / okio / Buffer / inputStream inputStream \u00b6 [jvm] Brief description Returns an input stream that reads from this source. Content open override fun inputStream (): InputStream","title":"inputStream   - Okio"},{"location":"2.x/okio/okio/-buffer/input-stream/#inputstream","text":"[jvm] Brief description Returns an input stream that reads from this source. Content open override fun inputStream (): InputStream","title":"inputStream"},{"location":"2.x/okio/okio/-buffer/is-open/","text":"// okio / okio / Buffer / isOpen isOpen \u00b6 [jvm] Content open override fun isOpen (): Boolean","title":"isOpen   - Okio"},{"location":"2.x/okio/okio/-buffer/is-open/#isopen","text":"[jvm] Content open override fun isOpen (): Boolean","title":"isOpen"},{"location":"2.x/okio/okio/-buffer/md5/","text":"// okio / okio / Buffer / md5 md5 \u00b6 [jvm] Brief description Returns the 128-bit MD5 hash of this buffer. Content fun md5 (): ByteString","title":"md5   - Okio"},{"location":"2.x/okio/okio/-buffer/md5/#md5","text":"[jvm] Brief description Returns the 128-bit MD5 hash of this buffer. Content fun md5 (): ByteString","title":"md5"},{"location":"2.x/okio/okio/-buffer/output-stream/","text":"// okio / okio / Buffer / outputStream outputStream \u00b6 [jvm] Brief description Returns an output stream that writes to this sink. Content open override fun outputStream (): OutputStream","title":"outputStream   - Okio"},{"location":"2.x/okio/okio/-buffer/output-stream/#outputstream","text":"[jvm] Brief description Returns an output stream that writes to this sink. Content open override fun outputStream (): OutputStream","title":"outputStream"},{"location":"2.x/okio/okio/-buffer/peek/","text":"// okio / okio / Buffer / peek peek \u00b6 [js, jvm, native] Content [js, jvm, native] open override fun peek (): BufferedSource","title":"peek   - Okio"},{"location":"2.x/okio/okio/-buffer/peek/#peek","text":"[js, jvm, native] Content [js, jvm, native] open override fun peek (): BufferedSource","title":"peek"},{"location":"2.x/okio/okio/-buffer/range-equals/","text":"// okio / okio / Buffer / rangeEquals rangeEquals \u00b6 [js, jvm, native] Content [js, jvm, native] open override fun rangeEquals (offset: Long , bytes: ByteString ): Boolean [js, jvm, native] open override fun rangeEquals (offset: Long , bytes: ByteString , bytesOffset: Int , byteCount: Int ): Boolean","title":"rangeEquals   - Okio"},{"location":"2.x/okio/okio/-buffer/range-equals/#rangeequals","text":"[js, jvm, native] Content [js, jvm, native] open override fun rangeEquals (offset: Long , bytes: ByteString ): Boolean [js, jvm, native] open override fun rangeEquals (offset: Long , bytes: ByteString , bytesOffset: Int , byteCount: Int ): Boolean","title":"rangeEquals"},{"location":"2.x/okio/okio/-buffer/read-all/","text":"// okio / okio / Buffer / readAll readAll \u00b6 [js, jvm, native] Content [js, jvm, native] open override fun readAll (sink: Sink ): Long","title":"readAll   - Okio"},{"location":"2.x/okio/okio/-buffer/read-all/#readall","text":"[js, jvm, native] Content [js, jvm, native] open override fun readAll (sink: Sink ): Long","title":"readAll"},{"location":"2.x/okio/okio/-buffer/read-and-write-unsafe/","text":"// okio / okio / Buffer / readAndWriteUnsafe readAndWriteUnsafe \u00b6 [jvm] Content @ JvmOverloads () fun readAndWriteUnsafe (unsafeCursor: Buffer.UnsafeCursor ): Buffer.UnsafeCursor","title":"readAndWriteUnsafe   - Okio"},{"location":"2.x/okio/okio/-buffer/read-and-write-unsafe/#readandwriteunsafe","text":"[jvm] Content @ JvmOverloads () fun readAndWriteUnsafe (unsafeCursor: Buffer.UnsafeCursor ): Buffer.UnsafeCursor","title":"readAndWriteUnsafe"},{"location":"2.x/okio/okio/-buffer/read-byte-array/","text":"// okio / okio / Buffer / readByteArray readByteArray \u00b6 [js, jvm, native] Content [js, jvm, native] open override fun readByteArray (): ByteArray [js, jvm, native] open override fun readByteArray (byteCount: Long ): ByteArray","title":"readByteArray   - Okio"},{"location":"2.x/okio/okio/-buffer/read-byte-array/#readbytearray","text":"[js, jvm, native] Content [js, jvm, native] open override fun readByteArray (): ByteArray [js, jvm, native] open override fun readByteArray (byteCount: Long ): ByteArray","title":"readByteArray"},{"location":"2.x/okio/okio/-buffer/read-byte-string/","text":"// okio / okio / Buffer / readByteString readByteString \u00b6 [js, jvm, native] Content [js, jvm, native] open override fun readByteString (): ByteString [js, jvm, native] open override fun readByteString (byteCount: Long ): ByteString","title":"readByteString   - Okio"},{"location":"2.x/okio/okio/-buffer/read-byte-string/#readbytestring","text":"[js, jvm, native] Content [js, jvm, native] open override fun readByteString (): ByteString [js, jvm, native] open override fun readByteString (byteCount: Long ): ByteString","title":"readByteString"},{"location":"2.x/okio/okio/-buffer/read-byte/","text":"// okio / okio / Buffer / readByte readByte \u00b6 [js, jvm, native] Content [js, jvm, native] open override fun readByte (): Byte","title":"readByte   - Okio"},{"location":"2.x/okio/okio/-buffer/read-byte/#readbyte","text":"[js, jvm, native] Content [js, jvm, native] open override fun readByte (): Byte","title":"readByte"},{"location":"2.x/okio/okio/-buffer/read-decimal-long/","text":"// okio / okio / Buffer / readDecimalLong readDecimalLong \u00b6 [js, jvm, native] Content [js, jvm, native] open override fun readDecimalLong (): Long","title":"readDecimalLong   - Okio"},{"location":"2.x/okio/okio/-buffer/read-decimal-long/#readdecimallong","text":"[js, jvm, native] Content [js, jvm, native] open override fun readDecimalLong (): Long","title":"readDecimalLong"},{"location":"2.x/okio/okio/-buffer/read-from/","text":"// okio / okio / Buffer / readFrom readFrom \u00b6 [jvm] Brief description Read and exhaust bytes from input into this. Content fun readFrom (input: InputStream ): Buffer [jvm] Brief description Read byteCount bytes from input into this. Content fun readFrom (input: InputStream , byteCount: Long ): Buffer","title":"readFrom   - Okio"},{"location":"2.x/okio/okio/-buffer/read-from/#readfrom","text":"[jvm] Brief description Read and exhaust bytes from input into this. Content fun readFrom (input: InputStream ): Buffer [jvm] Brief description Read byteCount bytes from input into this. Content fun readFrom (input: InputStream , byteCount: Long ): Buffer","title":"readFrom"},{"location":"2.x/okio/okio/-buffer/read-fully/","text":"// okio / okio / Buffer / readFully readFully \u00b6 [js, jvm, native] Content [js, jvm, native] open override fun readFully (sink: Buffer , byteCount: Long ) [js, jvm, native] open override fun readFully (sink: ByteArray )","title":"readFully   - Okio"},{"location":"2.x/okio/okio/-buffer/read-fully/#readfully","text":"[js, jvm, native] Content [js, jvm, native] open override fun readFully (sink: Buffer , byteCount: Long ) [js, jvm, native] open override fun readFully (sink: ByteArray )","title":"readFully"},{"location":"2.x/okio/okio/-buffer/read-hexadecimal-unsigned-long/","text":"// okio / okio / Buffer / readHexadecimalUnsignedLong readHexadecimalUnsignedLong \u00b6 [js, jvm, native] Content [js, jvm, native] open override fun readHexadecimalUnsignedLong (): Long","title":"readHexadecimalUnsignedLong   - Okio"},{"location":"2.x/okio/okio/-buffer/read-hexadecimal-unsigned-long/#readhexadecimalunsignedlong","text":"[js, jvm, native] Content [js, jvm, native] open override fun readHexadecimalUnsignedLong (): Long","title":"readHexadecimalUnsignedLong"},{"location":"2.x/okio/okio/-buffer/read-int-le/","text":"// okio / okio / Buffer / readIntLe readIntLe \u00b6 [js, jvm, native] Content [js, jvm, native] open override fun readIntLe (): Int","title":"readIntLe   - Okio"},{"location":"2.x/okio/okio/-buffer/read-int-le/#readintle","text":"[js, jvm, native] Content [js, jvm, native] open override fun readIntLe (): Int","title":"readIntLe"},{"location":"2.x/okio/okio/-buffer/read-int/","text":"// okio / okio / Buffer / readInt readInt \u00b6 [js, jvm, native] Content [js, jvm, native] open override fun readInt (): Int","title":"readInt   - Okio"},{"location":"2.x/okio/okio/-buffer/read-int/#readint","text":"[js, jvm, native] Content [js, jvm, native] open override fun readInt (): Int","title":"readInt"},{"location":"2.x/okio/okio/-buffer/read-long-le/","text":"// okio / okio / Buffer / readLongLe readLongLe \u00b6 [js, jvm, native] Content [js, jvm, native] open override fun readLongLe (): Long","title":"readLongLe   - Okio"},{"location":"2.x/okio/okio/-buffer/read-long-le/#readlongle","text":"[js, jvm, native] Content [js, jvm, native] open override fun readLongLe (): Long","title":"readLongLe"},{"location":"2.x/okio/okio/-buffer/read-long/","text":"// okio / okio / Buffer / readLong readLong \u00b6 [js, jvm, native] Content [js, jvm, native] open override fun readLong (): Long","title":"readLong   - Okio"},{"location":"2.x/okio/okio/-buffer/read-long/#readlong","text":"[js, jvm, native] Content [js, jvm, native] open override fun readLong (): Long","title":"readLong"},{"location":"2.x/okio/okio/-buffer/read-short-le/","text":"// okio / okio / Buffer / readShortLe readShortLe \u00b6 [js, jvm, native] Content [js, jvm, native] open override fun readShortLe (): Short","title":"readShortLe   - Okio"},{"location":"2.x/okio/okio/-buffer/read-short-le/#readshortle","text":"[js, jvm, native] Content [js, jvm, native] open override fun readShortLe (): Short","title":"readShortLe"},{"location":"2.x/okio/okio/-buffer/read-short/","text":"// okio / okio / Buffer / readShort readShort \u00b6 [js, jvm, native] Content [js, jvm, native] open override fun readShort (): Short","title":"readShort   - Okio"},{"location":"2.x/okio/okio/-buffer/read-short/#readshort","text":"[js, jvm, native] Content [js, jvm, native] open override fun readShort (): Short","title":"readShort"},{"location":"2.x/okio/okio/-buffer/read-string/","text":"// okio / okio / Buffer / readString readString \u00b6 [jvm] Brief description Removes all bytes from this, decodes them as charset, and returns the string. Content open override fun readString (charset: Charset ): String [jvm] Brief description Removes byteCount bytes from this, decodes them as charset, and returns the string. Content open override fun readString (byteCount: Long , charset: Charset ): String","title":"readString   - Okio"},{"location":"2.x/okio/okio/-buffer/read-string/#readstring","text":"[jvm] Brief description Removes all bytes from this, decodes them as charset, and returns the string. Content open override fun readString (charset: Charset ): String [jvm] Brief description Removes byteCount bytes from this, decodes them as charset, and returns the string. Content open override fun readString (byteCount: Long , charset: Charset ): String","title":"readString"},{"location":"2.x/okio/okio/-buffer/read-unsafe/","text":"// okio / okio / Buffer / readUnsafe readUnsafe \u00b6 [jvm] Content @ JvmOverloads () fun readUnsafe (unsafeCursor: Buffer.UnsafeCursor ): Buffer.UnsafeCursor","title":"readUnsafe   - Okio"},{"location":"2.x/okio/okio/-buffer/read-unsafe/#readunsafe","text":"[jvm] Content @ JvmOverloads () fun readUnsafe (unsafeCursor: Buffer.UnsafeCursor ): Buffer.UnsafeCursor","title":"readUnsafe"},{"location":"2.x/okio/okio/-buffer/read-utf8-code-point/","text":"// okio / okio / Buffer / readUtf8CodePoint readUtf8CodePoint \u00b6 [js, jvm, native] Content [js, jvm, native] open override fun readUtf8CodePoint (): Int","title":"readUtf8CodePoint   - Okio"},{"location":"2.x/okio/okio/-buffer/read-utf8-code-point/#readutf8codepoint","text":"[js, jvm, native] Content [js, jvm, native] open override fun readUtf8CodePoint (): Int","title":"readUtf8CodePoint"},{"location":"2.x/okio/okio/-buffer/read-utf8-line-strict/","text":"// okio / okio / Buffer / readUtf8LineStrict readUtf8LineStrict \u00b6 [js, jvm, native] Content [js, jvm, native] open override fun readUtf8LineStrict (): String [js, jvm, native] open override fun readUtf8LineStrict (limit: Long ): String","title":"readUtf8LineStrict   - Okio"},{"location":"2.x/okio/okio/-buffer/read-utf8-line-strict/#readutf8linestrict","text":"[js, jvm, native] Content [js, jvm, native] open override fun readUtf8LineStrict (): String [js, jvm, native] open override fun readUtf8LineStrict (limit: Long ): String","title":"readUtf8LineStrict"},{"location":"2.x/okio/okio/-buffer/read-utf8-line/","text":"// okio / okio / Buffer / readUtf8Line readUtf8Line \u00b6 [js, jvm, native] Content [js, jvm, native] open override fun readUtf8Line (): String ?","title":"readUtf8Line   - Okio"},{"location":"2.x/okio/okio/-buffer/read-utf8-line/#readutf8line","text":"[js, jvm, native] Content [js, jvm, native] open override fun readUtf8Line (): String ?","title":"readUtf8Line"},{"location":"2.x/okio/okio/-buffer/read-utf8/","text":"// okio / okio / Buffer / readUtf8 readUtf8 \u00b6 [js, jvm, native] Content [js, jvm, native] open override fun readUtf8 (): String [js, jvm, native] open override fun readUtf8 (byteCount: Long ): String","title":"readUtf8   - Okio"},{"location":"2.x/okio/okio/-buffer/read-utf8/#readutf8","text":"[js, jvm, native] Content [js, jvm, native] open override fun readUtf8 (): String [js, jvm, native] open override fun readUtf8 (byteCount: Long ): String","title":"readUtf8"},{"location":"2.x/okio/okio/-buffer/read/","text":"// okio / okio / Buffer / read read \u00b6 [js, jvm, native] Content [js, jvm, native] open override fun read (sink: ByteArray ): Int [js, jvm, native] open override fun read (sink: ByteArray , offset: Int , byteCount: Int ): Int [js, jvm, native] open override fun read (sink: Buffer , byteCount: Long ): Long [jvm] open override fun read (sink: ByteBuffer ): Int","title":"read   - Okio"},{"location":"2.x/okio/okio/-buffer/read/#read","text":"[js, jvm, native] Content [js, jvm, native] open override fun read (sink: ByteArray ): Int [js, jvm, native] open override fun read (sink: ByteArray , offset: Int , byteCount: Int ): Int [js, jvm, native] open override fun read (sink: Buffer , byteCount: Long ): Long [jvm] open override fun read (sink: ByteBuffer ): Int","title":"read"},{"location":"2.x/okio/okio/-buffer/request/","text":"// okio / okio / Buffer / request request \u00b6 [js, jvm, native] Content [js, jvm, native] open override fun request (byteCount: Long ): Boolean","title":"request   - Okio"},{"location":"2.x/okio/okio/-buffer/request/#request","text":"[js, jvm, native] Content [js, jvm, native] open override fun request (byteCount: Long ): Boolean","title":"request"},{"location":"2.x/okio/okio/-buffer/require/","text":"// okio / okio / Buffer / require require \u00b6 [js, jvm, native] Content [js, jvm, native] open override fun require (byteCount: Long )","title":"require   - Okio"},{"location":"2.x/okio/okio/-buffer/require/#require","text":"[js, jvm, native] Content [js, jvm, native] open override fun require (byteCount: Long )","title":"require"},{"location":"2.x/okio/okio/-buffer/select/","text":"// okio / okio / Buffer / select select \u00b6 [js, jvm, native] Content [js, jvm, native] open override fun select (options: ): Int","title":"select   - Okio"},{"location":"2.x/okio/okio/-buffer/select/#select","text":"[js, jvm, native] Content [js, jvm, native] open override fun select (options: ): Int","title":"select"},{"location":"2.x/okio/okio/-buffer/sha1/","text":"// okio / okio / Buffer / sha1 sha1 \u00b6 [jvm] Brief description Returns the 160-bit SHA-1 hash of this buffer. Content fun sha1 (): ByteString","title":"sha1   - Okio"},{"location":"2.x/okio/okio/-buffer/sha1/#sha1","text":"[jvm] Brief description Returns the 160-bit SHA-1 hash of this buffer. Content fun sha1 (): ByteString","title":"sha1"},{"location":"2.x/okio/okio/-buffer/sha256/","text":"// okio / okio / Buffer / sha256 sha256 \u00b6 [jvm] Brief description Returns the 256-bit SHA-256 hash of this buffer. Content fun sha256 (): ByteString","title":"sha256   - Okio"},{"location":"2.x/okio/okio/-buffer/sha256/#sha256","text":"[jvm] Brief description Returns the 256-bit SHA-256 hash of this buffer. Content fun sha256 (): ByteString","title":"sha256"},{"location":"2.x/okio/okio/-buffer/sha512/","text":"// okio / okio / Buffer / sha512 sha512 \u00b6 [jvm] Brief description Returns the 512-bit SHA-512 hash of this buffer. Content fun sha512 (): ByteString","title":"sha512   - Okio"},{"location":"2.x/okio/okio/-buffer/sha512/#sha512","text":"[jvm] Brief description Returns the 512-bit SHA-512 hash of this buffer. Content fun sha512 (): ByteString","title":"sha512"},{"location":"2.x/okio/okio/-buffer/skip/","text":"// okio / okio / Buffer / skip skip \u00b6 [js, jvm, native] Content [js, jvm, native] open override fun skip (byteCount: Long )","title":"skip   - Okio"},{"location":"2.x/okio/okio/-buffer/skip/#skip","text":"[js, jvm, native] Content [js, jvm, native] open override fun skip (byteCount: Long )","title":"skip"},{"location":"2.x/okio/okio/-buffer/snapshot/","text":"// okio / okio / Buffer / snapshot snapshot \u00b6 [js, jvm, native] Content [js, jvm, native] fun snapshot (): ByteString [js, jvm, native] fun snapshot (byteCount: Int ): ByteString","title":"snapshot   - Okio"},{"location":"2.x/okio/okio/-buffer/snapshot/#snapshot","text":"[js, jvm, native] Content [js, jvm, native] fun snapshot (): ByteString [js, jvm, native] fun snapshot (byteCount: Int ): ByteString","title":"snapshot"},{"location":"2.x/okio/okio/-buffer/timeout/","text":"// okio / okio / Buffer / timeout timeout \u00b6 [js, jvm, native] Content [js, jvm, native] open override fun timeout (): Timeout","title":"timeout   - Okio"},{"location":"2.x/okio/okio/-buffer/timeout/#timeout","text":"[js, jvm, native] Content [js, jvm, native] open override fun timeout (): Timeout","title":"timeout"},{"location":"2.x/okio/okio/-buffer/to-string/","text":"// okio / okio / Buffer / toString toString \u00b6 [js, jvm, native] Brief description Returns a human-readable string that describes the contents of this buffer. Typically this is a string like [text=Hello] or [hex=0000ffff]. Content [js, jvm, native] open override fun toString ():","title":"toString   - Okio"},{"location":"2.x/okio/okio/-buffer/to-string/#tostring","text":"[js, jvm, native] Brief description Returns a human-readable string that describes the contents of this buffer. Typically this is a string like [text=Hello] or [hex=0000ffff]. Content [js, jvm, native] open override fun toString ():","title":"toString"},{"location":"2.x/okio/okio/-buffer/write-all/","text":"// okio / okio / Buffer / writeAll writeAll \u00b6 [js, jvm, native] Content [js, jvm, native] open override fun writeAll (source: Source ): Long","title":"writeAll   - Okio"},{"location":"2.x/okio/okio/-buffer/write-all/#writeall","text":"[js, jvm, native] Content [js, jvm, native] open override fun writeAll (source: Source ): Long","title":"writeAll"},{"location":"2.x/okio/okio/-buffer/write-byte/","text":"// okio / okio / Buffer / writeByte writeByte \u00b6 [js, jvm, native] Content [js, jvm, native] open override fun writeByte (b: Int ): Buffer","title":"writeByte   - Okio"},{"location":"2.x/okio/okio/-buffer/write-byte/#writebyte","text":"[js, jvm, native] Content [js, jvm, native] open override fun writeByte (b: Int ): Buffer","title":"writeByte"},{"location":"2.x/okio/okio/-buffer/write-decimal-long/","text":"// okio / okio / Buffer / writeDecimalLong writeDecimalLong \u00b6 [js, jvm, native] Content [js, jvm, native] open override fun writeDecimalLong (v: Long ): Buffer","title":"writeDecimalLong   - Okio"},{"location":"2.x/okio/okio/-buffer/write-decimal-long/#writedecimallong","text":"[js, jvm, native] Content [js, jvm, native] open override fun writeDecimalLong (v: Long ): Buffer","title":"writeDecimalLong"},{"location":"2.x/okio/okio/-buffer/write-hexadecimal-unsigned-long/","text":"// okio / okio / Buffer / writeHexadecimalUnsignedLong writeHexadecimalUnsignedLong \u00b6 [js, jvm, native] Content [js, jvm, native] open override fun writeHexadecimalUnsignedLong (v: Long ): Buffer","title":"writeHexadecimalUnsignedLong   - Okio"},{"location":"2.x/okio/okio/-buffer/write-hexadecimal-unsigned-long/#writehexadecimalunsignedlong","text":"[js, jvm, native] Content [js, jvm, native] open override fun writeHexadecimalUnsignedLong (v: Long ): Buffer","title":"writeHexadecimalUnsignedLong"},{"location":"2.x/okio/okio/-buffer/write-int-le/","text":"// okio / okio / Buffer / writeIntLe writeIntLe \u00b6 [js, jvm, native] Content [js, jvm, native] open override fun writeIntLe (i: Int ): Buffer","title":"writeIntLe   - Okio"},{"location":"2.x/okio/okio/-buffer/write-int-le/#writeintle","text":"[js, jvm, native] Content [js, jvm, native] open override fun writeIntLe (i: Int ): Buffer","title":"writeIntLe"},{"location":"2.x/okio/okio/-buffer/write-int/","text":"// okio / okio / Buffer / writeInt writeInt \u00b6 [js, jvm, native] Content [js, jvm, native] open override fun writeInt (i: Int ): Buffer","title":"writeInt   - Okio"},{"location":"2.x/okio/okio/-buffer/write-int/#writeint","text":"[js, jvm, native] Content [js, jvm, native] open override fun writeInt (i: Int ): Buffer","title":"writeInt"},{"location":"2.x/okio/okio/-buffer/write-long-le/","text":"// okio / okio / Buffer / writeLongLe writeLongLe \u00b6 [js, jvm, native] Content [js, jvm, native] open override fun writeLongLe (v: Long ): Buffer","title":"writeLongLe   - Okio"},{"location":"2.x/okio/okio/-buffer/write-long-le/#writelongle","text":"[js, jvm, native] Content [js, jvm, native] open override fun writeLongLe (v: Long ): Buffer","title":"writeLongLe"},{"location":"2.x/okio/okio/-buffer/write-long/","text":"// okio / okio / Buffer / writeLong writeLong \u00b6 [js, jvm, native] Content [js, jvm, native] open override fun writeLong (v: Long ): Buffer","title":"writeLong   - Okio"},{"location":"2.x/okio/okio/-buffer/write-long/#writelong","text":"[js, jvm, native] Content [js, jvm, native] open override fun writeLong (v: Long ): Buffer","title":"writeLong"},{"location":"2.x/okio/okio/-buffer/write-short-le/","text":"// okio / okio / Buffer / writeShortLe writeShortLe \u00b6 [js, jvm, native] Content [js, jvm, native] open override fun writeShortLe (s: Int ): Buffer","title":"writeShortLe   - Okio"},{"location":"2.x/okio/okio/-buffer/write-short-le/#writeshortle","text":"[js, jvm, native] Content [js, jvm, native] open override fun writeShortLe (s: Int ): Buffer","title":"writeShortLe"},{"location":"2.x/okio/okio/-buffer/write-short/","text":"// okio / okio / Buffer / writeShort writeShort \u00b6 [js, jvm, native] Content [js, jvm, native] open override fun writeShort (s: Int ): Buffer","title":"writeShort   - Okio"},{"location":"2.x/okio/okio/-buffer/write-short/#writeshort","text":"[js, jvm, native] Content [js, jvm, native] open override fun writeShort (s: Int ): Buffer","title":"writeShort"},{"location":"2.x/okio/okio/-buffer/write-string/","text":"// okio / okio / Buffer / writeString writeString \u00b6 [jvm] Content open override fun writeString (string: String , charset: Charset ): Buffer open override fun writeString (string: String , beginIndex: Int , endIndex: Int , charset: Charset ): Buffer","title":"writeString   - Okio"},{"location":"2.x/okio/okio/-buffer/write-string/#writestring","text":"[jvm] Content open override fun writeString (string: String , charset: Charset ): Buffer open override fun writeString (string: String , beginIndex: Int , endIndex: Int , charset: Charset ): Buffer","title":"writeString"},{"location":"2.x/okio/okio/-buffer/write-to/","text":"// okio / okio / Buffer / writeTo writeTo \u00b6 [jvm] Brief description Write byteCount bytes from this to out. Content @ JvmOverloads () fun writeTo (out: OutputStream , byteCount: Long ): Buffer","title":"writeTo   - Okio"},{"location":"2.x/okio/okio/-buffer/write-to/#writeto","text":"[jvm] Brief description Write byteCount bytes from this to out. Content @ JvmOverloads () fun writeTo (out: OutputStream , byteCount: Long ): Buffer","title":"writeTo"},{"location":"2.x/okio/okio/-buffer/write-utf8-code-point/","text":"// okio / okio / Buffer / writeUtf8CodePoint writeUtf8CodePoint \u00b6 [js, jvm, native] Content [js, jvm, native] open override fun writeUtf8CodePoint (codePoint: Int ): Buffer","title":"writeUtf8CodePoint   - Okio"},{"location":"2.x/okio/okio/-buffer/write-utf8-code-point/#writeutf8codepoint","text":"[js, jvm, native] Content [js, jvm, native] open override fun writeUtf8CodePoint (codePoint: Int ): Buffer","title":"writeUtf8CodePoint"},{"location":"2.x/okio/okio/-buffer/write-utf8/","text":"// okio / okio / Buffer / writeUtf8 writeUtf8 \u00b6 [js, jvm, native] Content [js, jvm, native] open override fun writeUtf8 (string: String ): Buffer [js, jvm, native] open override fun writeUtf8 (string: String , beginIndex: Int , endIndex: Int ): Buffer","title":"writeUtf8   - Okio"},{"location":"2.x/okio/okio/-buffer/write-utf8/#writeutf8","text":"[js, jvm, native] Content [js, jvm, native] open override fun writeUtf8 (string: String ): Buffer [js, jvm, native] open override fun writeUtf8 (string: String , beginIndex: Int , endIndex: Int ): Buffer","title":"writeUtf8"},{"location":"2.x/okio/okio/-buffer/write/","text":"// okio / okio / Buffer / write write \u00b6 [js, jvm, native] Content [js, jvm, native] open override fun write (byteString: ByteString ): Buffer [js, jvm, native] open override fun write (byteString: ByteString , offset: Int , byteCount: Int ): [js, jvm, native] open override fun write (source: ByteArray ): Buffer [js, jvm, native] open override fun write (source: ByteArray , offset: Int , byteCount: Int ): Buffer [js, jvm, native] open override fun write (source: Source , byteCount: Long ): Buffer [js, jvm, native] open override fun write (source: Buffer , byteCount: Long ) [jvm] open override fun write (source: ByteBuffer ): Int","title":"write   - Okio"},{"location":"2.x/okio/okio/-buffer/write/#write","text":"[js, jvm, native] Content [js, jvm, native] open override fun write (byteString: ByteString ): Buffer [js, jvm, native] open override fun write (byteString: ByteString , offset: Int , byteCount: Int ): [js, jvm, native] open override fun write (source: ByteArray ): Buffer [js, jvm, native] open override fun write (source: ByteArray , offset: Int , byteCount: Int ): Buffer [js, jvm, native] open override fun write (source: Source , byteCount: Long ): Buffer [js, jvm, native] open override fun write (source: Buffer , byteCount: Long ) [jvm] open override fun write (source: ByteBuffer ): Int","title":"write"},{"location":"2.x/okio/okio/-buffer/-unsafe-cursor/","text":"// okio / okio / Buffer / UnsafeCursor UnsafeCursor \u00b6 [jvm] A handle to the underlying data in a buffer. This handle is unsafe because it does not enforce its own invariants. Instead, it assumes a careful user who has studied Okio\u2019s implementation details and their consequences.Buffer Internals ----------------Most code should use Buffer as a black box: a class that holds 0 or more bytes of data with efficient APIs to append data to the end and to consume data from the front. Usually this is also the most efficient way to use buffers because it allows Okio to employ several optimizations, including: Buffers use a shared pool of memory that is not zero-filled before use. A buffer\u2019s capacity can change without copying its contents. Memory ownership can be reassigned from one buffer to another. Multiple buffers can share the same underlying memory. Common operations like UTF-8 encoding and decimal decoding do not require intermediate objects to be allocated. These optimizations all leverage the way Okio stores data internally. Okio Buffers are implemented using a doubly-linked list of segments. Each segment is a contiguous range within a 8 KiB ByteArray. Each segment has two indexes, start, the offset of the first byte of the array containing application data, and end, the offset of the first byte beyond start whose data is undefined.New buffers are empty and have no segments:val buffer = Buffer()We append 7 bytes of data to the end of our empty buffer. Internally, the buffer allocates a segment and writes its new data there. The lone segment has an 8 KiB byte array but only 7 bytes of data:buffer.writeUtf8(\u201csealion\u201d) // [ \u2018s\u2019, \u2018e\u2019, \u2018a\u2019, \u2018l\u2019, \u2018i\u2019, \u2018o\u2019, \u2018n\u2019, \u2018?\u2019, \u2018?\u2019, \u2018?\u2019, \u2026] // ^ ^ // start = 0 end = 7When we read 4 bytes of data from the buffer, it finds its first segment and returns that data to us. As bytes are read the data is consumed. The segment tracks this by adjusting its internal indices.buffer.readUtf8(4) // \u201cseal\u201d // [ \u2018s\u2019, \u2018e\u2019, \u2018a\u2019, \u2018l\u2019, \u2018i\u2019, \u2018o\u2019, \u2018n\u2019, \u2018?\u2019, \u2018?\u2019, \u2018?\u2019, \u2026] // ^ ^ // start = 4 end = 7As we write data into a buffer we fill up its internal segments. When a write doesn\u2019t fit into a buffer\u2019s last segment, additional segments are allocated and appended to the linked list of segments. Each segment has its own start and end indexes tracking where the user\u2019s data begins and ends.val xoxo = new Buffer() xoxo.writeUtf8(\u201cxo\u201d.repeat(5_000)) // [ \u2018x\u2019, \u2018o\u2019, \u2018x\u2019, \u2018o\u2019, \u2018x\u2019, \u2018o\u2019, \u2018x\u2019, \u2018o\u2019, \u2026, \u2018x\u2019, \u2018o\u2019, \u2018x\u2019, \u2018o\u2019] // ^ ^ // start = 0 end = 8192 // // [ \u2018x\u2019, \u2018o\u2019, \u2018x\u2019, \u2018o\u2019, \u2026, \u2018x\u2019, \u2018o\u2019, \u2018x\u2019, \u2018o\u2019, \u2018?\u2019, \u2018?\u2019, \u2018?\u2019, \u2026] // ^ ^ // start = 0 end = 1808The start index is always inclusive and the end index is always exclusive . The data preceding the start index is undefined, and the data at and following the end index is undefined.After the last byte of a segment has been read, that segment may be returned to an internal segment pool. In addition to reducing the need to do garbage collection, segment pooling also saves the JVM from needing to zero-fill byte arrays. Okio doesn\u2019t need to zero-fill its arrays because it always writes memory before it reads it. But if you look at a segment in a debugger you may see its effects. In this example, one of the \u201cxoxo\u201d segments above is reused in an unrelated buffer:val abc = new Buffer() abc.writeUtf8(\u201cabc\u201d) // [ \u2018a\u2019, \u2018b\u2019, \u2018c\u2019, \u2018o\u2019, \u2018x\u2019, \u2018o\u2019, \u2018x\u2019, \u2018o\u2019, \u2026] // ^ ^ // start = 0 end = 3There is an optimization in Buffer.clone() and other methods that allows two segments to share the same underlying byte array. Clones can\u2019t write to the shared byte array; instead they allocate a new (private) segment early.val nana = new Buffer() nana.writeUtf8(\u201cna\u201d.repeat(2_500)) nana.readUtf8(2) // \u201cna\u201d // [ \u2018n\u2019, \u2018a\u2019, \u2018n\u2019, \u2018a\u2019, \u2026, \u2018n\u2019, \u2018a\u2019, \u2018n\u2019, \u2018a\u2019, \u2018?\u2019, \u2018?\u2019, \u2018?\u2019, \u2026] // ^ ^ // start = 2 end = 5000 nana2 = nana.clone() nana2.writeUtf8(\u201cbatman\u201d) // [ \u2018n\u2019, \u2018a\u2019, \u2018n\u2019, \u2018a\u2019, \u2026, \u2018n\u2019, \u2018a\u2019, \u2018n\u2019, \u2018a\u2019, \u2018?\u2019, \u2018?\u2019, \u2018?\u2019, \u2026] // ^ ^ // start = 2 end = 5000 // // [ \u2018b\u2019, \u2018a\u2019, \u2018t\u2019, \u2018m\u2019, \u2018a\u2019, \u2018n\u2019, \u2018?\u2019, \u2018?\u2019, \u2018?\u2019, \u2026] // ^ ^ // start = 0 end = 6Segments are not shared when the shared region is small (ie. less than 1 KiB). This is intended to prevent fragmentation in sharing-heavy use cases.Unsafe Cursor API -----------------This class exposes privileged access to the internal byte arrays of a buffer. A cursor either references the data of a single segment, it is before the first segment (offset == -1), or it is after the last segment (offset == buffer.size).Call UnsafeCursor.seek to move the cursor to the segment that contains a specified offset. After seeking, UnsafeCursor.data references the segment\u2019s internal byte array, UnsafeCursor.start is the segment\u2019s start and UnsafeCursor.end is its end.Call UnsafeCursor.next to advance the cursor to the next segment. This returns -1 if there are no further segments in the buffer.Use Buffer.readUnsafe to create a cursor to read buffer data and Buffer.readAndWriteUnsafe to create a cursor to read and write buffer data. In either case, always call UnsafeCursor.close when done with a cursor. This is convenient with Kotlin\u2019s use extension function. In this example we read all of the bytes in a buffer into a byte array:val bufferBytes = ByteArray(buffer.size.toInt()) buffer.readUnsafe().use { cursor -> while (cursor.next() != -1) { System.arraycopy(cursor.data, cursor.start, bufferBytes, cursor.offset.toInt(), cursor.end - cursor.start); } }Change the capacity of a buffer with resizeBuffer . This is only permitted for read+write cursors. The buffer\u2019s size always changes from the end: shrinking it removes bytes from the end; growing it adds capacity to the end.Warnings --------Most application developers should avoid this API. Those that must use this API should respect these warnings. This class has public, non-final fields because that is convenient for low-level I/O frameworks. Never assign values to these fields; instead use the cursor API to adjust these. data You are on the honor system to never write the buffer in read-only mode. Read-only mode may be more efficient than read+write mode because it does not need to make private copies of shared segments. [start..end) Other data in the byte array is undefined! It may contain private or sensitive data from other parts of your process. Always fill the new capacity when you grow a buffer. New capacity is not zero-filled and may contain data from other parts of your process. Avoid leaking this information by always writing something to the newly-allocated capacity. Do not assume that new capacity will be filled with 0; it will not be. Do not access a buffer while is being accessed by a cursor. Even simple read-only operations like Buffer.clone are unsafe because they mark segments as shared. Do not hard-code the segment size in your application. It is possible that segment sizes will change with advances in hardware. Future versions of Okio may even have heterogeneous segment sizes.These warnings are intended to help you to use this API safely. It\u2019s here for developers that need absolutely the most throughput. Since that\u2019s you, here\u2019s one final performance tip. You can reuse instances of this class if you like. Use the overloads of Buffer.readUnsafe and Buffer.readAndWriteUnsafe that take a cursor and close it after use. class UnsafeCursor : Closeable Constructors \u00b6 Name Summary [jvm] fun () Functions \u00b6 Name Summary close [jvm] Content open override fun close () equals [jvm] Content open operator override fun equals (other: Any ?): Boolean expandBuffer [jvm] Brief description Grow the buffer by adding a contiguous range of capacity in a single segment. This adds at least minByteCount bytes but may add up to a full segment of additional capacity.As a side-effect this cursor will seek . It will move offset to the first byte of newly-added capacity. This is the size of the buffer prior to the expandBuffer() call.If minByteCount bytes are available in the buffer\u2019s current tail segment that will be used; otherwise another segment will be allocated and appended. In either case this returns the number of bytes of capacity added to this buffer.Warning: it is the caller\u2019s responsibility to either write new data to every byte of the newly-allocated capacity, or to shrink the buffer to the data written. Failure to do so may cause serious security problems as the data in the returned buffers is not zero filled. Buffers may contain dirty pooled segments that hold very sensitive data from other parts of the current process. Content fun expandBuffer (minByteCount: Int ): Long hashCode [jvm] Content open override fun hashCode (): Int next [jvm] Brief description Seeks to the next range of bytes, advancing the offset by end - start. Returns the size of the readable range (at least 1), or -1 if we have reached the end of the buffer and there are no more bytes to read. Content fun next (): Int resizeBuffer [jvm] Brief description Change the size of the buffer so that it equals newSize by either adding new capacity at the end or truncating the buffer at the end. Newly added capacity may span multiple segments.As a side-effect this cursor will seek . If the buffer is being enlarged it will move UnsafeCursor.offset to the first byte of newly-added capacity. This is the size of the buffer prior to the resizeBuffer() call. If the buffer is being shrunk it will move UnsafeCursor.offset to the end of the buffer.Warning: it is the caller\u2019s responsibility to write new data to every byte of the newly-allocated capacity. Failure to do so may cause serious security problems as the data in the returned buffers is not zero filled. Buffers may contain dirty pooled segments that hold very sensitive data from other parts of the current process. Content fun resizeBuffer (newSize: Long ): Long seek [jvm] Brief description Reposition the cursor so that the data at offset is readable at data[start]. Returns the number of bytes readable in data (at least 1), or -1 if there are no data to read. Content fun seek (offset: Long ): Int toString [jvm] Content open override fun toString (): String Properties \u00b6 Name Summary buffer [jvm] @ JvmField () var buffer : Buffer ? data [jvm] @ JvmField () var data : ByteArray ? end [jvm] @ JvmField () var end : Int offset [jvm] @ JvmField () var offset : Long readWrite [jvm] @ JvmField () var readWrite : Boolean start [jvm] @ JvmField () var start : Int","title":"UnsafeCursor   - Okio"},{"location":"2.x/okio/okio/-buffer/-unsafe-cursor/#unsafecursor","text":"[jvm] A handle to the underlying data in a buffer. This handle is unsafe because it does not enforce its own invariants. Instead, it assumes a careful user who has studied Okio\u2019s implementation details and their consequences.Buffer Internals ----------------Most code should use Buffer as a black box: a class that holds 0 or more bytes of data with efficient APIs to append data to the end and to consume data from the front. Usually this is also the most efficient way to use buffers because it allows Okio to employ several optimizations, including: Buffers use a shared pool of memory that is not zero-filled before use. A buffer\u2019s capacity can change without copying its contents. Memory ownership can be reassigned from one buffer to another. Multiple buffers can share the same underlying memory. Common operations like UTF-8 encoding and decimal decoding do not require intermediate objects to be allocated. These optimizations all leverage the way Okio stores data internally. Okio Buffers are implemented using a doubly-linked list of segments. Each segment is a contiguous range within a 8 KiB ByteArray. Each segment has two indexes, start, the offset of the first byte of the array containing application data, and end, the offset of the first byte beyond start whose data is undefined.New buffers are empty and have no segments:val buffer = Buffer()We append 7 bytes of data to the end of our empty buffer. Internally, the buffer allocates a segment and writes its new data there. The lone segment has an 8 KiB byte array but only 7 bytes of data:buffer.writeUtf8(\u201csealion\u201d) // [ \u2018s\u2019, \u2018e\u2019, \u2018a\u2019, \u2018l\u2019, \u2018i\u2019, \u2018o\u2019, \u2018n\u2019, \u2018?\u2019, \u2018?\u2019, \u2018?\u2019, \u2026] // ^ ^ // start = 0 end = 7When we read 4 bytes of data from the buffer, it finds its first segment and returns that data to us. As bytes are read the data is consumed. The segment tracks this by adjusting its internal indices.buffer.readUtf8(4) // \u201cseal\u201d // [ \u2018s\u2019, \u2018e\u2019, \u2018a\u2019, \u2018l\u2019, \u2018i\u2019, \u2018o\u2019, \u2018n\u2019, \u2018?\u2019, \u2018?\u2019, \u2018?\u2019, \u2026] // ^ ^ // start = 4 end = 7As we write data into a buffer we fill up its internal segments. When a write doesn\u2019t fit into a buffer\u2019s last segment, additional segments are allocated and appended to the linked list of segments. Each segment has its own start and end indexes tracking where the user\u2019s data begins and ends.val xoxo = new Buffer() xoxo.writeUtf8(\u201cxo\u201d.repeat(5_000)) // [ \u2018x\u2019, \u2018o\u2019, \u2018x\u2019, \u2018o\u2019, \u2018x\u2019, \u2018o\u2019, \u2018x\u2019, \u2018o\u2019, \u2026, \u2018x\u2019, \u2018o\u2019, \u2018x\u2019, \u2018o\u2019] // ^ ^ // start = 0 end = 8192 // // [ \u2018x\u2019, \u2018o\u2019, \u2018x\u2019, \u2018o\u2019, \u2026, \u2018x\u2019, \u2018o\u2019, \u2018x\u2019, \u2018o\u2019, \u2018?\u2019, \u2018?\u2019, \u2018?\u2019, \u2026] // ^ ^ // start = 0 end = 1808The start index is always inclusive and the end index is always exclusive . The data preceding the start index is undefined, and the data at and following the end index is undefined.After the last byte of a segment has been read, that segment may be returned to an internal segment pool. In addition to reducing the need to do garbage collection, segment pooling also saves the JVM from needing to zero-fill byte arrays. Okio doesn\u2019t need to zero-fill its arrays because it always writes memory before it reads it. But if you look at a segment in a debugger you may see its effects. In this example, one of the \u201cxoxo\u201d segments above is reused in an unrelated buffer:val abc = new Buffer() abc.writeUtf8(\u201cabc\u201d) // [ \u2018a\u2019, \u2018b\u2019, \u2018c\u2019, \u2018o\u2019, \u2018x\u2019, \u2018o\u2019, \u2018x\u2019, \u2018o\u2019, \u2026] // ^ ^ // start = 0 end = 3There is an optimization in Buffer.clone() and other methods that allows two segments to share the same underlying byte array. Clones can\u2019t write to the shared byte array; instead they allocate a new (private) segment early.val nana = new Buffer() nana.writeUtf8(\u201cna\u201d.repeat(2_500)) nana.readUtf8(2) // \u201cna\u201d // [ \u2018n\u2019, \u2018a\u2019, \u2018n\u2019, \u2018a\u2019, \u2026, \u2018n\u2019, \u2018a\u2019, \u2018n\u2019, \u2018a\u2019, \u2018?\u2019, \u2018?\u2019, \u2018?\u2019, \u2026] // ^ ^ // start = 2 end = 5000 nana2 = nana.clone() nana2.writeUtf8(\u201cbatman\u201d) // [ \u2018n\u2019, \u2018a\u2019, \u2018n\u2019, \u2018a\u2019, \u2026, \u2018n\u2019, \u2018a\u2019, \u2018n\u2019, \u2018a\u2019, \u2018?\u2019, \u2018?\u2019, \u2018?\u2019, \u2026] // ^ ^ // start = 2 end = 5000 // // [ \u2018b\u2019, \u2018a\u2019, \u2018t\u2019, \u2018m\u2019, \u2018a\u2019, \u2018n\u2019, \u2018?\u2019, \u2018?\u2019, \u2018?\u2019, \u2026] // ^ ^ // start = 0 end = 6Segments are not shared when the shared region is small (ie. less than 1 KiB). This is intended to prevent fragmentation in sharing-heavy use cases.Unsafe Cursor API -----------------This class exposes privileged access to the internal byte arrays of a buffer. A cursor either references the data of a single segment, it is before the first segment (offset == -1), or it is after the last segment (offset == buffer.size).Call UnsafeCursor.seek to move the cursor to the segment that contains a specified offset. After seeking, UnsafeCursor.data references the segment\u2019s internal byte array, UnsafeCursor.start is the segment\u2019s start and UnsafeCursor.end is its end.Call UnsafeCursor.next to advance the cursor to the next segment. This returns -1 if there are no further segments in the buffer.Use Buffer.readUnsafe to create a cursor to read buffer data and Buffer.readAndWriteUnsafe to create a cursor to read and write buffer data. In either case, always call UnsafeCursor.close when done with a cursor. This is convenient with Kotlin\u2019s use extension function. In this example we read all of the bytes in a buffer into a byte array:val bufferBytes = ByteArray(buffer.size.toInt()) buffer.readUnsafe().use { cursor -> while (cursor.next() != -1) { System.arraycopy(cursor.data, cursor.start, bufferBytes, cursor.offset.toInt(), cursor.end - cursor.start); } }Change the capacity of a buffer with resizeBuffer . This is only permitted for read+write cursors. The buffer\u2019s size always changes from the end: shrinking it removes bytes from the end; growing it adds capacity to the end.Warnings --------Most application developers should avoid this API. Those that must use this API should respect these warnings. This class has public, non-final fields because that is convenient for low-level I/O frameworks. Never assign values to these fields; instead use the cursor API to adjust these. data You are on the honor system to never write the buffer in read-only mode. Read-only mode may be more efficient than read+write mode because it does not need to make private copies of shared segments. [start..end) Other data in the byte array is undefined! It may contain private or sensitive data from other parts of your process. Always fill the new capacity when you grow a buffer. New capacity is not zero-filled and may contain data from other parts of your process. Avoid leaking this information by always writing something to the newly-allocated capacity. Do not assume that new capacity will be filled with 0; it will not be. Do not access a buffer while is being accessed by a cursor. Even simple read-only operations like Buffer.clone are unsafe because they mark segments as shared. Do not hard-code the segment size in your application. It is possible that segment sizes will change with advances in hardware. Future versions of Okio may even have heterogeneous segment sizes.These warnings are intended to help you to use this API safely. It\u2019s here for developers that need absolutely the most throughput. Since that\u2019s you, here\u2019s one final performance tip. You can reuse instances of this class if you like. Use the overloads of Buffer.readUnsafe and Buffer.readAndWriteUnsafe that take a cursor and close it after use. class UnsafeCursor : Closeable","title":"UnsafeCursor"},{"location":"2.x/okio/okio/-buffer/-unsafe-cursor/#constructors","text":"Name Summary [jvm] fun ()","title":"Constructors"},{"location":"2.x/okio/okio/-buffer/-unsafe-cursor/#functions","text":"Name Summary close [jvm] Content open override fun close () equals [jvm] Content open operator override fun equals (other: Any ?): Boolean expandBuffer [jvm] Brief description Grow the buffer by adding a contiguous range of capacity in a single segment. This adds at least minByteCount bytes but may add up to a full segment of additional capacity.As a side-effect this cursor will seek . It will move offset to the first byte of newly-added capacity. This is the size of the buffer prior to the expandBuffer() call.If minByteCount bytes are available in the buffer\u2019s current tail segment that will be used; otherwise another segment will be allocated and appended. In either case this returns the number of bytes of capacity added to this buffer.Warning: it is the caller\u2019s responsibility to either write new data to every byte of the newly-allocated capacity, or to shrink the buffer to the data written. Failure to do so may cause serious security problems as the data in the returned buffers is not zero filled. Buffers may contain dirty pooled segments that hold very sensitive data from other parts of the current process. Content fun expandBuffer (minByteCount: Int ): Long hashCode [jvm] Content open override fun hashCode (): Int next [jvm] Brief description Seeks to the next range of bytes, advancing the offset by end - start. Returns the size of the readable range (at least 1), or -1 if we have reached the end of the buffer and there are no more bytes to read. Content fun next (): Int resizeBuffer [jvm] Brief description Change the size of the buffer so that it equals newSize by either adding new capacity at the end or truncating the buffer at the end. Newly added capacity may span multiple segments.As a side-effect this cursor will seek . If the buffer is being enlarged it will move UnsafeCursor.offset to the first byte of newly-added capacity. This is the size of the buffer prior to the resizeBuffer() call. If the buffer is being shrunk it will move UnsafeCursor.offset to the end of the buffer.Warning: it is the caller\u2019s responsibility to write new data to every byte of the newly-allocated capacity. Failure to do so may cause serious security problems as the data in the returned buffers is not zero filled. Buffers may contain dirty pooled segments that hold very sensitive data from other parts of the current process. Content fun resizeBuffer (newSize: Long ): Long seek [jvm] Brief description Reposition the cursor so that the data at offset is readable at data[start]. Returns the number of bytes readable in data (at least 1), or -1 if there are no data to read. Content fun seek (offset: Long ): Int toString [jvm] Content open override fun toString (): String","title":"Functions"},{"location":"2.x/okio/okio/-buffer/-unsafe-cursor/#properties","text":"Name Summary buffer [jvm] @ JvmField () var buffer : Buffer ? data [jvm] @ JvmField () var data : ByteArray ? end [jvm] @ JvmField () var end : Int offset [jvm] @ JvmField () var offset : Long readWrite [jvm] @ JvmField () var readWrite : Boolean start [jvm] @ JvmField () var start : Int","title":"Properties"},{"location":"2.x/okio/okio/-buffer/-unsafe-cursor/-init-/","text":"// okio / okio / Buffer / UnsafeCursor / \u00b6 [jvm] Content fun ()","title":"<init>   - Okio"},{"location":"2.x/okio/okio/-buffer/-unsafe-cursor/-init-/#_1","text":"[jvm] Content fun ()","title":""},{"location":"2.x/okio/okio/-buffer/-unsafe-cursor/close/","text":"// okio / okio / Buffer / UnsafeCursor / close close \u00b6 [jvm] Content open override fun close ()","title":"close   - Okio"},{"location":"2.x/okio/okio/-buffer/-unsafe-cursor/close/#close","text":"[jvm] Content open override fun close ()","title":"close"},{"location":"2.x/okio/okio/-buffer/-unsafe-cursor/expand-buffer/","text":"// okio / okio / Buffer / UnsafeCursor / expandBuffer expandBuffer \u00b6 [jvm] Brief description Grow the buffer by adding a contiguous range of capacity in a single segment. This adds at least minByteCount bytes but may add up to a full segment of additional capacity.As a side-effect this cursor will seek . It will move offset to the first byte of newly-added capacity. This is the size of the buffer prior to the expandBuffer() call.If minByteCount bytes are available in the buffer\u2019s current tail segment that will be used; otherwise another segment will be allocated and appended. In either case this returns the number of bytes of capacity added to this buffer.Warning: it is the caller\u2019s responsibility to either write new data to every byte of the newly-allocated capacity, or to shrink the buffer to the data written. Failure to do so may cause serious security problems as the data in the returned buffers is not zero filled. Buffers may contain dirty pooled segments that hold very sensitive data from other parts of the current process. Return \u00b6 the number of bytes expanded by. Not less than minByteCount. Parameters \u00b6 jvm Name Summary minByteCount the size of the contiguous capacity. Must be positive and not greater than the capacity size of a single segment (8 KiB). Content fun expandBuffer (minByteCount: Int ): Long","title":"expandBuffer   - Okio"},{"location":"2.x/okio/okio/-buffer/-unsafe-cursor/expand-buffer/#expandbuffer","text":"[jvm] Brief description Grow the buffer by adding a contiguous range of capacity in a single segment. This adds at least minByteCount bytes but may add up to a full segment of additional capacity.As a side-effect this cursor will seek . It will move offset to the first byte of newly-added capacity. This is the size of the buffer prior to the expandBuffer() call.If minByteCount bytes are available in the buffer\u2019s current tail segment that will be used; otherwise another segment will be allocated and appended. In either case this returns the number of bytes of capacity added to this buffer.Warning: it is the caller\u2019s responsibility to either write new data to every byte of the newly-allocated capacity, or to shrink the buffer to the data written. Failure to do so may cause serious security problems as the data in the returned buffers is not zero filled. Buffers may contain dirty pooled segments that hold very sensitive data from other parts of the current process.","title":"expandBuffer"},{"location":"2.x/okio/okio/-buffer/-unsafe-cursor/expand-buffer/#return","text":"the number of bytes expanded by. Not less than minByteCount.","title":"Return"},{"location":"2.x/okio/okio/-buffer/-unsafe-cursor/expand-buffer/#parameters","text":"jvm Name Summary minByteCount the size of the contiguous capacity. Must be positive and not greater than the capacity size of a single segment (8 KiB). Content fun expandBuffer (minByteCount: Int ): Long","title":"Parameters"},{"location":"2.x/okio/okio/-buffer/-unsafe-cursor/next/","text":"// okio / okio / Buffer / UnsafeCursor / next next \u00b6 [jvm] Brief description Seeks to the next range of bytes, advancing the offset by end - start. Returns the size of the readable range (at least 1), or -1 if we have reached the end of the buffer and there are no more bytes to read. Content fun next (): Int","title":"next   - Okio"},{"location":"2.x/okio/okio/-buffer/-unsafe-cursor/next/#next","text":"[jvm] Brief description Seeks to the next range of bytes, advancing the offset by end - start. Returns the size of the readable range (at least 1), or -1 if we have reached the end of the buffer and there are no more bytes to read. Content fun next (): Int","title":"next"},{"location":"2.x/okio/okio/-buffer/-unsafe-cursor/resize-buffer/","text":"// okio / okio / Buffer / UnsafeCursor / resizeBuffer resizeBuffer \u00b6 [jvm] Brief description Change the size of the buffer so that it equals newSize by either adding new capacity at the end or truncating the buffer at the end. Newly added capacity may span multiple segments.As a side-effect this cursor will seek . If the buffer is being enlarged it will move UnsafeCursor.offset to the first byte of newly-added capacity. This is the size of the buffer prior to the resizeBuffer() call. If the buffer is being shrunk it will move UnsafeCursor.offset to the end of the buffer.Warning: it is the caller\u2019s responsibility to write new data to every byte of the newly-allocated capacity. Failure to do so may cause serious security problems as the data in the returned buffers is not zero filled. Buffers may contain dirty pooled segments that hold very sensitive data from other parts of the current process. Return \u00b6 the previous size of the buffer. Content fun resizeBuffer (newSize: Long ): Long","title":"resizeBuffer   - Okio"},{"location":"2.x/okio/okio/-buffer/-unsafe-cursor/resize-buffer/#resizebuffer","text":"[jvm] Brief description Change the size of the buffer so that it equals newSize by either adding new capacity at the end or truncating the buffer at the end. Newly added capacity may span multiple segments.As a side-effect this cursor will seek . If the buffer is being enlarged it will move UnsafeCursor.offset to the first byte of newly-added capacity. This is the size of the buffer prior to the resizeBuffer() call. If the buffer is being shrunk it will move UnsafeCursor.offset to the end of the buffer.Warning: it is the caller\u2019s responsibility to write new data to every byte of the newly-allocated capacity. Failure to do so may cause serious security problems as the data in the returned buffers is not zero filled. Buffers may contain dirty pooled segments that hold very sensitive data from other parts of the current process.","title":"resizeBuffer"},{"location":"2.x/okio/okio/-buffer/-unsafe-cursor/resize-buffer/#return","text":"the previous size of the buffer. Content fun resizeBuffer (newSize: Long ): Long","title":"Return"},{"location":"2.x/okio/okio/-buffer/-unsafe-cursor/seek/","text":"// okio / okio / Buffer / UnsafeCursor / seek seek \u00b6 [jvm] Brief description Reposition the cursor so that the data at offset is readable at data[start]. Returns the number of bytes readable in data (at least 1), or -1 if there are no data to read. Content fun seek (offset: Long ): Int","title":"seek   - Okio"},{"location":"2.x/okio/okio/-buffer/-unsafe-cursor/seek/#seek","text":"[jvm] Brief description Reposition the cursor so that the data at offset is readable at data[start]. Returns the number of bytes readable in data (at least 1), or -1 if there are no data to read. Content fun seek (offset: Long ): Int","title":"seek"},{"location":"2.x/okio/okio/-buffered-sink/","text":"// okio / okio / BufferedSink BufferedSink \u00b6 [js, native] interface BufferedSink : Sink [jvm] interface BufferedSink : Sink , WritableByteChannel Functions \u00b6 Name Summary close [js, jvm, native] Content [js, jvm, native] abstract override fun close () emit [js, jvm, native] Content [js, jvm, native] abstract fun emit (): BufferedSink emitCompleteSegments [js, jvm, native] Content [js, jvm, native] abstract fun emitCompleteSegments (): BufferedSink equals [js, jvm, native] Content [js, jvm, native] open operator override fun equals (other: Any ?): Boolean flush [js, native, jvm] Content [js, native] abstract override fun flush () [jvm] abstract override fun flush () hashCode [js, jvm, native] Content [js, jvm, native] open override fun hashCode (): Int isOpen [jvm] Content abstract override fun isOpen (): Boolean outputStream [jvm] Brief description Returns an output stream that writes to this sink. Content abstract fun outputStream (): OutputStream timeout [js, jvm, native] Content [js, jvm, native] abstract override fun timeout (): Timeout toString [js, jvm, native] Content [js, jvm, native] open override fun toString (): String write [js, jvm, native] Content [js, jvm, native] abstract fun write (byteString: ByteString ): BufferedSink [js, jvm, native] abstract fun write (byteString: ByteString , offset: Int , byteCount: Int ): BufferedSink [js, jvm, native] abstract fun write (source: ByteArray ): BufferedSink [js, jvm, native] abstract fun write (source: ByteArray , offset: Int , byteCount: Int ): BufferedSink [js, jvm, native] abstract fun write (source: Source , byteCount: Long ): BufferedSink [js, jvm, native] abstract override fun write (source: Buffer , byteCount: Long ) [jvm] abstract override fun write (p0: ByteBuffer ): Int writeAll [js, jvm, native] Content [js, jvm, native] abstract fun writeAll (source: Source ): Long writeByte [js, jvm, native] Content [js, jvm, native] abstract fun writeByte (b: Int ): BufferedSink writeDecimalLong [js, jvm, native] Content [js, jvm, native] abstract fun writeDecimalLong (v: Long ): BufferedSink writeHexadecimalUnsignedLong [js, jvm, native] Content [js, jvm, native] abstract fun writeHexadecimalUnsignedLong (v: Long ): BufferedSink writeInt [js, jvm, native] Content [js, jvm, native] abstract fun writeInt (i: Int ): BufferedSink writeIntLe [js, jvm, native] Content [js, jvm, native] abstract fun writeIntLe (i: Int ): BufferedSink writeLong [js, jvm, native] Content [js, jvm, native] abstract fun writeLong (v: Long ): BufferedSink writeLongLe [js, jvm, native] Content [js, jvm, native] abstract fun writeLongLe (v: Long ): BufferedSink writeShort [js, jvm, native] Content [js, jvm, native] abstract fun writeShort (s: Int ): BufferedSink writeShortLe [js, jvm, native] Content [js, jvm, native] abstract fun writeShortLe (s: Int ): BufferedSink writeString [jvm] Content abstract fun writeString (string: String , charset: Charset ): BufferedSink abstract fun writeString (string: String , beginIndex: Int , endIndex: Int , charset: Charset ): BufferedSink writeUtf8 [js, jvm, native] Content [js, jvm, native] abstract fun writeUtf8 (string: String ): BufferedSink [js, jvm, native] abstract fun writeUtf8 (string: String , beginIndex: Int , endIndex: Int ): BufferedSink writeUtf8CodePoint [js, jvm, native] Content [js, jvm, native] abstract fun writeUtf8CodePoint (codePoint: Int ): BufferedSink Properties \u00b6 Name Summary buffer [js, jvm, native] abstract val buffer : Buffer Inheritors \u00b6 Name Buffer","title":"BufferedSink   - Okio"},{"location":"2.x/okio/okio/-buffered-sink/#bufferedsink","text":"[js, native] interface BufferedSink : Sink [jvm] interface BufferedSink : Sink , WritableByteChannel","title":"BufferedSink"},{"location":"2.x/okio/okio/-buffered-sink/#functions","text":"Name Summary close [js, jvm, native] Content [js, jvm, native] abstract override fun close () emit [js, jvm, native] Content [js, jvm, native] abstract fun emit (): BufferedSink emitCompleteSegments [js, jvm, native] Content [js, jvm, native] abstract fun emitCompleteSegments (): BufferedSink equals [js, jvm, native] Content [js, jvm, native] open operator override fun equals (other: Any ?): Boolean flush [js, native, jvm] Content [js, native] abstract override fun flush () [jvm] abstract override fun flush () hashCode [js, jvm, native] Content [js, jvm, native] open override fun hashCode (): Int isOpen [jvm] Content abstract override fun isOpen (): Boolean outputStream [jvm] Brief description Returns an output stream that writes to this sink. Content abstract fun outputStream (): OutputStream timeout [js, jvm, native] Content [js, jvm, native] abstract override fun timeout (): Timeout toString [js, jvm, native] Content [js, jvm, native] open override fun toString (): String write [js, jvm, native] Content [js, jvm, native] abstract fun write (byteString: ByteString ): BufferedSink [js, jvm, native] abstract fun write (byteString: ByteString , offset: Int , byteCount: Int ): BufferedSink [js, jvm, native] abstract fun write (source: ByteArray ): BufferedSink [js, jvm, native] abstract fun write (source: ByteArray , offset: Int , byteCount: Int ): BufferedSink [js, jvm, native] abstract fun write (source: Source , byteCount: Long ): BufferedSink [js, jvm, native] abstract override fun write (source: Buffer , byteCount: Long ) [jvm] abstract override fun write (p0: ByteBuffer ): Int writeAll [js, jvm, native] Content [js, jvm, native] abstract fun writeAll (source: Source ): Long writeByte [js, jvm, native] Content [js, jvm, native] abstract fun writeByte (b: Int ): BufferedSink writeDecimalLong [js, jvm, native] Content [js, jvm, native] abstract fun writeDecimalLong (v: Long ): BufferedSink writeHexadecimalUnsignedLong [js, jvm, native] Content [js, jvm, native] abstract fun writeHexadecimalUnsignedLong (v: Long ): BufferedSink writeInt [js, jvm, native] Content [js, jvm, native] abstract fun writeInt (i: Int ): BufferedSink writeIntLe [js, jvm, native] Content [js, jvm, native] abstract fun writeIntLe (i: Int ): BufferedSink writeLong [js, jvm, native] Content [js, jvm, native] abstract fun writeLong (v: Long ): BufferedSink writeLongLe [js, jvm, native] Content [js, jvm, native] abstract fun writeLongLe (v: Long ): BufferedSink writeShort [js, jvm, native] Content [js, jvm, native] abstract fun writeShort (s: Int ): BufferedSink writeShortLe [js, jvm, native] Content [js, jvm, native] abstract fun writeShortLe (s: Int ): BufferedSink writeString [jvm] Content abstract fun writeString (string: String , charset: Charset ): BufferedSink abstract fun writeString (string: String , beginIndex: Int , endIndex: Int , charset: Charset ): BufferedSink writeUtf8 [js, jvm, native] Content [js, jvm, native] abstract fun writeUtf8 (string: String ): BufferedSink [js, jvm, native] abstract fun writeUtf8 (string: String , beginIndex: Int , endIndex: Int ): BufferedSink writeUtf8CodePoint [js, jvm, native] Content [js, jvm, native] abstract fun writeUtf8CodePoint (codePoint: Int ): BufferedSink","title":"Functions"},{"location":"2.x/okio/okio/-buffered-sink/#properties","text":"Name Summary buffer [js, jvm, native] abstract val buffer : Buffer","title":"Properties"},{"location":"2.x/okio/okio/-buffered-sink/#inheritors","text":"Name Buffer","title":"Inheritors"},{"location":"2.x/okio/okio/-buffered-sink/emit-complete-segments/","text":"// okio / okio / BufferedSink / emitCompleteSegments emitCompleteSegments \u00b6 [js, jvm, native] Content [js, jvm, native] abstract fun emitCompleteSegments (): BufferedSink","title":"emitCompleteSegments   - Okio"},{"location":"2.x/okio/okio/-buffered-sink/emit-complete-segments/#emitcompletesegments","text":"[js, jvm, native] Content [js, jvm, native] abstract fun emitCompleteSegments (): BufferedSink","title":"emitCompleteSegments"},{"location":"2.x/okio/okio/-buffered-sink/emit/","text":"// okio / okio / BufferedSink / emit emit \u00b6 [js, jvm, native] Content [js, jvm, native] abstract fun emit (): BufferedSink","title":"emit   - Okio"},{"location":"2.x/okio/okio/-buffered-sink/emit/#emit","text":"[js, jvm, native] Content [js, jvm, native] abstract fun emit (): BufferedSink","title":"emit"},{"location":"2.x/okio/okio/-buffered-sink/flush/","text":"// okio / okio / BufferedSink / flush flush \u00b6 [jvm] Content abstract override fun flush ()","title":"flush   - Okio"},{"location":"2.x/okio/okio/-buffered-sink/flush/#flush","text":"[jvm] Content abstract override fun flush ()","title":"flush"},{"location":"2.x/okio/okio/-buffered-sink/output-stream/","text":"// okio / okio / BufferedSink / outputStream outputStream \u00b6 [jvm] Brief description Returns an output stream that writes to this sink. Content abstract fun outputStream (): OutputStream","title":"outputStream   - Okio"},{"location":"2.x/okio/okio/-buffered-sink/output-stream/#outputstream","text":"[jvm] Brief description Returns an output stream that writes to this sink. Content abstract fun outputStream (): OutputStream","title":"outputStream"},{"location":"2.x/okio/okio/-buffered-sink/write-all/","text":"// okio / okio / BufferedSink / writeAll writeAll \u00b6 [js, jvm, native] Content [js, jvm, native] abstract fun writeAll (source: Source ): Long","title":"writeAll   - Okio"},{"location":"2.x/okio/okio/-buffered-sink/write-all/#writeall","text":"[js, jvm, native] Content [js, jvm, native] abstract fun writeAll (source: Source ): Long","title":"writeAll"},{"location":"2.x/okio/okio/-buffered-sink/write-byte/","text":"// okio / okio / BufferedSink / writeByte writeByte \u00b6 [js, jvm, native] Content [js, jvm, native] abstract fun writeByte (b: Int ): BufferedSink","title":"writeByte   - Okio"},{"location":"2.x/okio/okio/-buffered-sink/write-byte/#writebyte","text":"[js, jvm, native] Content [js, jvm, native] abstract fun writeByte (b: Int ): BufferedSink","title":"writeByte"},{"location":"2.x/okio/okio/-buffered-sink/write-decimal-long/","text":"// okio / okio / BufferedSink / writeDecimalLong writeDecimalLong \u00b6 [js, jvm, native] Content [js, jvm, native] abstract fun writeDecimalLong (v: Long ): BufferedSink","title":"writeDecimalLong   - Okio"},{"location":"2.x/okio/okio/-buffered-sink/write-decimal-long/#writedecimallong","text":"[js, jvm, native] Content [js, jvm, native] abstract fun writeDecimalLong (v: Long ): BufferedSink","title":"writeDecimalLong"},{"location":"2.x/okio/okio/-buffered-sink/write-hexadecimal-unsigned-long/","text":"// okio / okio / BufferedSink / writeHexadecimalUnsignedLong writeHexadecimalUnsignedLong \u00b6 [js, jvm, native] Content [js, jvm, native] abstract fun writeHexadecimalUnsignedLong (v: Long ): BufferedSink","title":"writeHexadecimalUnsignedLong   - Okio"},{"location":"2.x/okio/okio/-buffered-sink/write-hexadecimal-unsigned-long/#writehexadecimalunsignedlong","text":"[js, jvm, native] Content [js, jvm, native] abstract fun writeHexadecimalUnsignedLong (v: Long ): BufferedSink","title":"writeHexadecimalUnsignedLong"},{"location":"2.x/okio/okio/-buffered-sink/write-int-le/","text":"// okio / okio / BufferedSink / writeIntLe writeIntLe \u00b6 [js, jvm, native] Content [js, jvm, native] abstract fun writeIntLe (i: Int ): BufferedSink","title":"writeIntLe   - Okio"},{"location":"2.x/okio/okio/-buffered-sink/write-int-le/#writeintle","text":"[js, jvm, native] Content [js, jvm, native] abstract fun writeIntLe (i: Int ): BufferedSink","title":"writeIntLe"},{"location":"2.x/okio/okio/-buffered-sink/write-int/","text":"// okio / okio / BufferedSink / writeInt writeInt \u00b6 [js, jvm, native] Content [js, jvm, native] abstract fun writeInt (i: Int ): BufferedSink","title":"writeInt   - Okio"},{"location":"2.x/okio/okio/-buffered-sink/write-int/#writeint","text":"[js, jvm, native] Content [js, jvm, native] abstract fun writeInt (i: Int ): BufferedSink","title":"writeInt"},{"location":"2.x/okio/okio/-buffered-sink/write-long-le/","text":"// okio / okio / BufferedSink / writeLongLe writeLongLe \u00b6 [js, jvm, native] Content [js, jvm, native] abstract fun writeLongLe (v: Long ): BufferedSink","title":"writeLongLe   - Okio"},{"location":"2.x/okio/okio/-buffered-sink/write-long-le/#writelongle","text":"[js, jvm, native] Content [js, jvm, native] abstract fun writeLongLe (v: Long ): BufferedSink","title":"writeLongLe"},{"location":"2.x/okio/okio/-buffered-sink/write-long/","text":"// okio / okio / BufferedSink / writeLong writeLong \u00b6 [js, jvm, native] Content [js, jvm, native] abstract fun writeLong (v: Long ): BufferedSink","title":"writeLong   - Okio"},{"location":"2.x/okio/okio/-buffered-sink/write-long/#writelong","text":"[js, jvm, native] Content [js, jvm, native] abstract fun writeLong (v: Long ): BufferedSink","title":"writeLong"},{"location":"2.x/okio/okio/-buffered-sink/write-short-le/","text":"// okio / okio / BufferedSink / writeShortLe writeShortLe \u00b6 [js, jvm, native] Content [js, jvm, native] abstract fun writeShortLe (s: Int ): BufferedSink","title":"writeShortLe   - Okio"},{"location":"2.x/okio/okio/-buffered-sink/write-short-le/#writeshortle","text":"[js, jvm, native] Content [js, jvm, native] abstract fun writeShortLe (s: Int ): BufferedSink","title":"writeShortLe"},{"location":"2.x/okio/okio/-buffered-sink/write-short/","text":"// okio / okio / BufferedSink / writeShort writeShort \u00b6 [js, jvm, native] Content [js, jvm, native] abstract fun writeShort (s: Int ): BufferedSink","title":"writeShort   - Okio"},{"location":"2.x/okio/okio/-buffered-sink/write-short/#writeshort","text":"[js, jvm, native] Content [js, jvm, native] abstract fun writeShort (s: Int ): BufferedSink","title":"writeShort"},{"location":"2.x/okio/okio/-buffered-sink/write-string/","text":"// okio / okio / BufferedSink / writeString writeString \u00b6 [jvm] Content abstract fun writeString (string: String , charset: Charset ): BufferedSink abstract fun writeString (string: String , beginIndex: Int , endIndex: Int , charset: Charset ): BufferedSink","title":"writeString   - Okio"},{"location":"2.x/okio/okio/-buffered-sink/write-string/#writestring","text":"[jvm] Content abstract fun writeString (string: String , charset: Charset ): BufferedSink abstract fun writeString (string: String , beginIndex: Int , endIndex: Int , charset: Charset ): BufferedSink","title":"writeString"},{"location":"2.x/okio/okio/-buffered-sink/write-utf8-code-point/","text":"// okio / okio / BufferedSink / writeUtf8CodePoint writeUtf8CodePoint \u00b6 [js, jvm, native] Content [js, jvm, native] abstract fun writeUtf8CodePoint (codePoint: Int ): BufferedSink","title":"writeUtf8CodePoint   - Okio"},{"location":"2.x/okio/okio/-buffered-sink/write-utf8-code-point/#writeutf8codepoint","text":"[js, jvm, native] Content [js, jvm, native] abstract fun writeUtf8CodePoint (codePoint: Int ): BufferedSink","title":"writeUtf8CodePoint"},{"location":"2.x/okio/okio/-buffered-sink/write-utf8/","text":"// okio / okio / BufferedSink / writeUtf8 writeUtf8 \u00b6 [js, jvm, native] Content [js, jvm, native] abstract fun writeUtf8 (string: String ): BufferedSink [js, jvm, native] abstract fun writeUtf8 (string: String , beginIndex: Int , endIndex: Int ): BufferedSink","title":"writeUtf8   - Okio"},{"location":"2.x/okio/okio/-buffered-sink/write-utf8/#writeutf8","text":"[js, jvm, native] Content [js, jvm, native] abstract fun writeUtf8 (string: String ): BufferedSink [js, jvm, native] abstract fun writeUtf8 (string: String , beginIndex: Int , endIndex: Int ): BufferedSink","title":"writeUtf8"},{"location":"2.x/okio/okio/-buffered-sink/write/","text":"// okio / okio / BufferedSink / write write \u00b6 [js, jvm, native] Content [js, jvm, native] abstract fun write (byteString: ByteString ): BufferedSink [js, jvm, native] abstract fun write (byteString: ByteString , offset: Int , byteCount: Int ): BufferedSink [js, jvm, native] abstract fun write (source: ByteArray ): BufferedSink [js, jvm, native] abstract fun write (source: ByteArray , offset: Int , byteCount: Int ): BufferedSink [js, jvm, native] abstract fun write (source: Source , byteCount: Long ): BufferedSink","title":"write   - Okio"},{"location":"2.x/okio/okio/-buffered-sink/write/#write","text":"[js, jvm, native] Content [js, jvm, native] abstract fun write (byteString: ByteString ): BufferedSink [js, jvm, native] abstract fun write (byteString: ByteString , offset: Int , byteCount: Int ): BufferedSink [js, jvm, native] abstract fun write (source: ByteArray ): BufferedSink [js, jvm, native] abstract fun write (source: ByteArray , offset: Int , byteCount: Int ): BufferedSink [js, jvm, native] abstract fun write (source: Source , byteCount: Long ): BufferedSink","title":"write"},{"location":"2.x/okio/okio/-buffered-source/","text":"// okio / okio / BufferedSource BufferedSource \u00b6 [js, native] interface BufferedSource : Source [jvm] interface BufferedSource : Source , ReadableByteChannel Functions \u00b6 Name Summary close [js, jvm, native] Content [js, jvm, native] abstract override fun close () equals [js, jvm, native] Content [js, jvm, native] open operator override fun equals (other: Any ?): Boolean exhausted [js, jvm, native] Content [js, jvm, native] abstract fun exhausted (): Boolean hashCode [js, jvm, native] Content [js, jvm, native] open override fun hashCode (): Int indexOf [js, jvm, native] Content [js, jvm, native] abstract fun indexOf (b: Byte ): Long [js, jvm, native] abstract fun indexOf (b: Byte , fromIndex: Long ): Long [js, jvm, native] abstract fun indexOf (b: Byte , fromIndex: Long , toIndex: Long ): Long [js, jvm, native] abstract fun indexOf (bytes: ByteString ): Long [js, jvm, native] abstract fun indexOf (bytes: ByteString , fromIndex: Long ): Long indexOfElement [js, jvm, native] Content [js, jvm, native] abstract fun indexOfElement (targetBytes: ByteString ): Long [js, jvm, native] abstract fun indexOfElement (targetBytes: ByteString , fromIndex: Long ): Long inputStream [jvm] Brief description Returns an input stream that reads from this source. Content abstract fun inputStream (): InputStream isOpen [jvm] Content abstract override fun isOpen (): Boolean peek [js, jvm, native] Content [js, jvm, native] abstract fun peek (): BufferedSource rangeEquals [js, jvm, native] Content [js, jvm, native] abstract fun rangeEquals (offset: Long , bytes: ByteString ): Boolean [js, jvm, native] abstract fun rangeEquals (offset: Long , bytes: ByteString , bytesOffset: Int , byteCount: Int ): Boolean read [js, jvm, native] Content [js, jvm, native] abstract fun read (sink: ByteArray ): Int [js, jvm, native] abstract fun read (sink: ByteArray , offset: Int , byteCount: Int ): Int [js, jvm, native] abstract override fun read (sink: Buffer , byteCount: Long ): Long [jvm] abstract override fun read (p0: ByteBuffer ): Int readAll [js, jvm, native] Content [js, jvm, native] abstract fun readAll (sink: Sink ): Long readByte [js, jvm, native] Content [js, jvm, native] abstract fun readByte (): Byte readByteArray [js, jvm, native] Content [js, jvm, native] abstract fun readByteArray (): ByteArray [js, jvm, native] abstract fun readByteArray (byteCount: Long ): ByteArray readByteString [js, jvm, native] Content [js, jvm, native] abstract fun readByteString (): ByteString [js, jvm, native] abstract fun readByteString (byteCount: Long ): ByteString readDecimalLong [js, jvm, native] Content [js, jvm, native] abstract fun readDecimalLong (): Long readFully [js, jvm, native] Content [js, jvm, native] abstract fun readFully (sink: ByteArray ) [js, jvm, native] abstract fun readFully (sink: Buffer , byteCount: Long ) readHexadecimalUnsignedLong [js, jvm, native] Content [js, jvm, native] abstract fun readHexadecimalUnsignedLong (): Long readInt [js, jvm, native] Content [js, jvm, native] abstract fun readInt (): Int readIntLe [js, jvm, native] Content [js, jvm, native] abstract fun readIntLe (): Int readLong [js, jvm, native] Content [js, jvm, native] abstract fun readLong (): Long readLongLe [js, jvm, native] Content [js, jvm, native] abstract fun readLongLe (): Long readShort [js, jvm, native] Content [js, jvm, native] abstract fun readShort (): Short readShortLe [js, jvm, native] Content [js, jvm, native] abstract fun readShortLe (): Short readString [jvm] Brief description Removes all bytes from this, decodes them as charset, and returns the string. Content abstract fun readString (charset: Charset ): String [jvm] Brief description Removes byteCount bytes from this, decodes them as charset, and returns the string. Content abstract fun readString (byteCount: Long , charset: Charset ): String readUtf8 [js, jvm, native] Content [js, jvm, native] abstract fun readUtf8 (): String [js, jvm, native] abstract fun readUtf8 (byteCount: Long ): String readUtf8CodePoint [js, jvm, native] Content [js, jvm, native] abstract fun readUtf8CodePoint (): Int readUtf8Line [js, jvm, native] Content [js, jvm, native] abstract fun readUtf8Line (): String ? readUtf8LineStrict [js, jvm, native] Content [js, jvm, native] abstract fun readUtf8LineStrict (): String [js, jvm, native] abstract fun readUtf8LineStrict (limit: Long ): String request [js, jvm, native] Content [js, jvm, native] abstract fun request (byteCount: Long ): Boolean require [js, jvm, native] Content [js, jvm, native] abstract fun require (byteCount: Long ) select [js, jvm, native] Content [js, jvm, native] abstract fun select (options: ): Int skip [js, jvm, native] Content [js, jvm, native] abstract fun skip (byteCount: Long ) timeout [js, jvm, native] Content [js, jvm, native] abstract override fun timeout (): Timeout toString [js, jvm, native] Content [js, jvm, native] open override fun toString (): String Properties \u00b6 Name Summary buffer [js, jvm, native] abstract val buffer : Buffer Inheritors \u00b6 Name Buffer","title":"BufferedSource   - Okio"},{"location":"2.x/okio/okio/-buffered-source/#bufferedsource","text":"[js, native] interface BufferedSource : Source [jvm] interface BufferedSource : Source , ReadableByteChannel","title":"BufferedSource"},{"location":"2.x/okio/okio/-buffered-source/#functions","text":"Name Summary close [js, jvm, native] Content [js, jvm, native] abstract override fun close () equals [js, jvm, native] Content [js, jvm, native] open operator override fun equals (other: Any ?): Boolean exhausted [js, jvm, native] Content [js, jvm, native] abstract fun exhausted (): Boolean hashCode [js, jvm, native] Content [js, jvm, native] open override fun hashCode (): Int indexOf [js, jvm, native] Content [js, jvm, native] abstract fun indexOf (b: Byte ): Long [js, jvm, native] abstract fun indexOf (b: Byte , fromIndex: Long ): Long [js, jvm, native] abstract fun indexOf (b: Byte , fromIndex: Long , toIndex: Long ): Long [js, jvm, native] abstract fun indexOf (bytes: ByteString ): Long [js, jvm, native] abstract fun indexOf (bytes: ByteString , fromIndex: Long ): Long indexOfElement [js, jvm, native] Content [js, jvm, native] abstract fun indexOfElement (targetBytes: ByteString ): Long [js, jvm, native] abstract fun indexOfElement (targetBytes: ByteString , fromIndex: Long ): Long inputStream [jvm] Brief description Returns an input stream that reads from this source. Content abstract fun inputStream (): InputStream isOpen [jvm] Content abstract override fun isOpen (): Boolean peek [js, jvm, native] Content [js, jvm, native] abstract fun peek (): BufferedSource rangeEquals [js, jvm, native] Content [js, jvm, native] abstract fun rangeEquals (offset: Long , bytes: ByteString ): Boolean [js, jvm, native] abstract fun rangeEquals (offset: Long , bytes: ByteString , bytesOffset: Int , byteCount: Int ): Boolean read [js, jvm, native] Content [js, jvm, native] abstract fun read (sink: ByteArray ): Int [js, jvm, native] abstract fun read (sink: ByteArray , offset: Int , byteCount: Int ): Int [js, jvm, native] abstract override fun read (sink: Buffer , byteCount: Long ): Long [jvm] abstract override fun read (p0: ByteBuffer ): Int readAll [js, jvm, native] Content [js, jvm, native] abstract fun readAll (sink: Sink ): Long readByte [js, jvm, native] Content [js, jvm, native] abstract fun readByte (): Byte readByteArray [js, jvm, native] Content [js, jvm, native] abstract fun readByteArray (): ByteArray [js, jvm, native] abstract fun readByteArray (byteCount: Long ): ByteArray readByteString [js, jvm, native] Content [js, jvm, native] abstract fun readByteString (): ByteString [js, jvm, native] abstract fun readByteString (byteCount: Long ): ByteString readDecimalLong [js, jvm, native] Content [js, jvm, native] abstract fun readDecimalLong (): Long readFully [js, jvm, native] Content [js, jvm, native] abstract fun readFully (sink: ByteArray ) [js, jvm, native] abstract fun readFully (sink: Buffer , byteCount: Long ) readHexadecimalUnsignedLong [js, jvm, native] Content [js, jvm, native] abstract fun readHexadecimalUnsignedLong (): Long readInt [js, jvm, native] Content [js, jvm, native] abstract fun readInt (): Int readIntLe [js, jvm, native] Content [js, jvm, native] abstract fun readIntLe (): Int readLong [js, jvm, native] Content [js, jvm, native] abstract fun readLong (): Long readLongLe [js, jvm, native] Content [js, jvm, native] abstract fun readLongLe (): Long readShort [js, jvm, native] Content [js, jvm, native] abstract fun readShort (): Short readShortLe [js, jvm, native] Content [js, jvm, native] abstract fun readShortLe (): Short readString [jvm] Brief description Removes all bytes from this, decodes them as charset, and returns the string. Content abstract fun readString (charset: Charset ): String [jvm] Brief description Removes byteCount bytes from this, decodes them as charset, and returns the string. Content abstract fun readString (byteCount: Long , charset: Charset ): String readUtf8 [js, jvm, native] Content [js, jvm, native] abstract fun readUtf8 (): String [js, jvm, native] abstract fun readUtf8 (byteCount: Long ): String readUtf8CodePoint [js, jvm, native] Content [js, jvm, native] abstract fun readUtf8CodePoint (): Int readUtf8Line [js, jvm, native] Content [js, jvm, native] abstract fun readUtf8Line (): String ? readUtf8LineStrict [js, jvm, native] Content [js, jvm, native] abstract fun readUtf8LineStrict (): String [js, jvm, native] abstract fun readUtf8LineStrict (limit: Long ): String request [js, jvm, native] Content [js, jvm, native] abstract fun request (byteCount: Long ): Boolean require [js, jvm, native] Content [js, jvm, native] abstract fun require (byteCount: Long ) select [js, jvm, native] Content [js, jvm, native] abstract fun select (options: ): Int skip [js, jvm, native] Content [js, jvm, native] abstract fun skip (byteCount: Long ) timeout [js, jvm, native] Content [js, jvm, native] abstract override fun timeout (): Timeout toString [js, jvm, native] Content [js, jvm, native] open override fun toString (): String","title":"Functions"},{"location":"2.x/okio/okio/-buffered-source/#properties","text":"Name Summary buffer [js, jvm, native] abstract val buffer : Buffer","title":"Properties"},{"location":"2.x/okio/okio/-buffered-source/#inheritors","text":"Name Buffer","title":"Inheritors"},{"location":"2.x/okio/okio/-buffered-source/exhausted/","text":"// okio / okio / BufferedSource / exhausted exhausted \u00b6 [js, jvm, native] Content [js, jvm, native] abstract fun exhausted (): Boolean","title":"exhausted   - Okio"},{"location":"2.x/okio/okio/-buffered-source/exhausted/#exhausted","text":"[js, jvm, native] Content [js, jvm, native] abstract fun exhausted (): Boolean","title":"exhausted"},{"location":"2.x/okio/okio/-buffered-source/index-of-element/","text":"// okio / okio / BufferedSource / indexOfElement indexOfElement \u00b6 [js, jvm, native] Content [js, jvm, native] abstract fun indexOfElement (targetBytes: ByteString ): Long [js, jvm, native] abstract fun indexOfElement (targetBytes: ByteString , fromIndex: Long ): Long","title":"indexOfElement   - Okio"},{"location":"2.x/okio/okio/-buffered-source/index-of-element/#indexofelement","text":"[js, jvm, native] Content [js, jvm, native] abstract fun indexOfElement (targetBytes: ByteString ): Long [js, jvm, native] abstract fun indexOfElement (targetBytes: ByteString , fromIndex: Long ): Long","title":"indexOfElement"},{"location":"2.x/okio/okio/-buffered-source/index-of/","text":"// okio / okio / BufferedSource / indexOf indexOf \u00b6 [js, jvm, native] Content [js, jvm, native] abstract fun indexOf (b: Byte ): Long [js, jvm, native] abstract fun indexOf (b: Byte , fromIndex: Long ): Long [js, jvm, native] abstract fun indexOf (b: Byte , fromIndex: Long , toIndex: Long ): Long [js, jvm, native] abstract fun indexOf (bytes: ByteString ): Long [js, jvm, native] abstract fun indexOf (bytes: ByteString , fromIndex: Long ): Long","title":"indexOf   - Okio"},{"location":"2.x/okio/okio/-buffered-source/index-of/#indexof","text":"[js, jvm, native] Content [js, jvm, native] abstract fun indexOf (b: Byte ): Long [js, jvm, native] abstract fun indexOf (b: Byte , fromIndex: Long ): Long [js, jvm, native] abstract fun indexOf (b: Byte , fromIndex: Long , toIndex: Long ): Long [js, jvm, native] abstract fun indexOf (bytes: ByteString ): Long [js, jvm, native] abstract fun indexOf (bytes: ByteString , fromIndex: Long ): Long","title":"indexOf"},{"location":"2.x/okio/okio/-buffered-source/input-stream/","text":"// okio / okio / BufferedSource / inputStream inputStream \u00b6 [jvm] Brief description Returns an input stream that reads from this source. Content abstract fun inputStream (): InputStream","title":"inputStream   - Okio"},{"location":"2.x/okio/okio/-buffered-source/input-stream/#inputstream","text":"[jvm] Brief description Returns an input stream that reads from this source. Content abstract fun inputStream (): InputStream","title":"inputStream"},{"location":"2.x/okio/okio/-buffered-source/peek/","text":"// okio / okio / BufferedSource / peek peek \u00b6 [js, jvm, native] Content [js, jvm, native] abstract fun peek (): BufferedSource","title":"peek   - Okio"},{"location":"2.x/okio/okio/-buffered-source/peek/#peek","text":"[js, jvm, native] Content [js, jvm, native] abstract fun peek (): BufferedSource","title":"peek"},{"location":"2.x/okio/okio/-buffered-source/range-equals/","text":"// okio / okio / BufferedSource / rangeEquals rangeEquals \u00b6 [js, jvm, native] Content [js, jvm, native] abstract fun rangeEquals (offset: Long , bytes: ByteString ): Boolean [js, jvm, native] abstract fun rangeEquals (offset: Long , bytes: ByteString , bytesOffset: Int , byteCount: Int ): Boolean","title":"rangeEquals   - Okio"},{"location":"2.x/okio/okio/-buffered-source/range-equals/#rangeequals","text":"[js, jvm, native] Content [js, jvm, native] abstract fun rangeEquals (offset: Long , bytes: ByteString ): Boolean [js, jvm, native] abstract fun rangeEquals (offset: Long , bytes: ByteString , bytesOffset: Int , byteCount: Int ): Boolean","title":"rangeEquals"},{"location":"2.x/okio/okio/-buffered-source/read-all/","text":"// okio / okio / BufferedSource / readAll readAll \u00b6 [js, jvm, native] Content [js, jvm, native] abstract fun readAll (sink: Sink ): Long","title":"readAll   - Okio"},{"location":"2.x/okio/okio/-buffered-source/read-all/#readall","text":"[js, jvm, native] Content [js, jvm, native] abstract fun readAll (sink: Sink ): Long","title":"readAll"},{"location":"2.x/okio/okio/-buffered-source/read-byte-array/","text":"// okio / okio / BufferedSource / readByteArray readByteArray \u00b6 [js, jvm, native] Content [js, jvm, native] abstract fun readByteArray (): ByteArray [js, jvm, native] abstract fun readByteArray (byteCount: Long ): ByteArray","title":"readByteArray   - Okio"},{"location":"2.x/okio/okio/-buffered-source/read-byte-array/#readbytearray","text":"[js, jvm, native] Content [js, jvm, native] abstract fun readByteArray (): ByteArray [js, jvm, native] abstract fun readByteArray (byteCount: Long ): ByteArray","title":"readByteArray"},{"location":"2.x/okio/okio/-buffered-source/read-byte-string/","text":"// okio / okio / BufferedSource / readByteString readByteString \u00b6 [js, jvm, native] Content [js, jvm, native] abstract fun readByteString (): ByteString [js, jvm, native] abstract fun readByteString (byteCount: Long ): ByteString","title":"readByteString   - Okio"},{"location":"2.x/okio/okio/-buffered-source/read-byte-string/#readbytestring","text":"[js, jvm, native] Content [js, jvm, native] abstract fun readByteString (): ByteString [js, jvm, native] abstract fun readByteString (byteCount: Long ): ByteString","title":"readByteString"},{"location":"2.x/okio/okio/-buffered-source/read-byte/","text":"// okio / okio / BufferedSource / readByte readByte \u00b6 [js, jvm, native] Content [js, jvm, native] abstract fun readByte (): Byte","title":"readByte   - Okio"},{"location":"2.x/okio/okio/-buffered-source/read-byte/#readbyte","text":"[js, jvm, native] Content [js, jvm, native] abstract fun readByte (): Byte","title":"readByte"},{"location":"2.x/okio/okio/-buffered-source/read-decimal-long/","text":"// okio / okio / BufferedSource / readDecimalLong readDecimalLong \u00b6 [js, jvm, native] Content [js, jvm, native] abstract fun readDecimalLong (): Long","title":"readDecimalLong   - Okio"},{"location":"2.x/okio/okio/-buffered-source/read-decimal-long/#readdecimallong","text":"[js, jvm, native] Content [js, jvm, native] abstract fun readDecimalLong (): Long","title":"readDecimalLong"},{"location":"2.x/okio/okio/-buffered-source/read-fully/","text":"// okio / okio / BufferedSource / readFully readFully \u00b6 [js, jvm, native] Content [js, jvm, native] abstract fun readFully (sink: ByteArray ) [js, jvm, native] abstract fun readFully (sink: Buffer , byteCount: Long )","title":"readFully   - Okio"},{"location":"2.x/okio/okio/-buffered-source/read-fully/#readfully","text":"[js, jvm, native] Content [js, jvm, native] abstract fun readFully (sink: ByteArray ) [js, jvm, native] abstract fun readFully (sink: Buffer , byteCount: Long )","title":"readFully"},{"location":"2.x/okio/okio/-buffered-source/read-hexadecimal-unsigned-long/","text":"// okio / okio / BufferedSource / readHexadecimalUnsignedLong readHexadecimalUnsignedLong \u00b6 [js, jvm, native] Content [js, jvm, native] abstract fun readHexadecimalUnsignedLong (): Long","title":"readHexadecimalUnsignedLong   - Okio"},{"location":"2.x/okio/okio/-buffered-source/read-hexadecimal-unsigned-long/#readhexadecimalunsignedlong","text":"[js, jvm, native] Content [js, jvm, native] abstract fun readHexadecimalUnsignedLong (): Long","title":"readHexadecimalUnsignedLong"},{"location":"2.x/okio/okio/-buffered-source/read-int-le/","text":"// okio / okio / BufferedSource / readIntLe readIntLe \u00b6 [js, jvm, native] Content [js, jvm, native] abstract fun readIntLe (): Int","title":"readIntLe   - Okio"},{"location":"2.x/okio/okio/-buffered-source/read-int-le/#readintle","text":"[js, jvm, native] Content [js, jvm, native] abstract fun readIntLe (): Int","title":"readIntLe"},{"location":"2.x/okio/okio/-buffered-source/read-int/","text":"// okio / okio / BufferedSource / readInt readInt \u00b6 [js, jvm, native] Content [js, jvm, native] abstract fun readInt (): Int","title":"readInt   - Okio"},{"location":"2.x/okio/okio/-buffered-source/read-int/#readint","text":"[js, jvm, native] Content [js, jvm, native] abstract fun readInt (): Int","title":"readInt"},{"location":"2.x/okio/okio/-buffered-source/read-long-le/","text":"// okio / okio / BufferedSource / readLongLe readLongLe \u00b6 [js, jvm, native] Content [js, jvm, native] abstract fun readLongLe (): Long","title":"readLongLe   - Okio"},{"location":"2.x/okio/okio/-buffered-source/read-long-le/#readlongle","text":"[js, jvm, native] Content [js, jvm, native] abstract fun readLongLe (): Long","title":"readLongLe"},{"location":"2.x/okio/okio/-buffered-source/read-long/","text":"// okio / okio / BufferedSource / readLong readLong \u00b6 [js, jvm, native] Content [js, jvm, native] abstract fun readLong (): Long","title":"readLong   - Okio"},{"location":"2.x/okio/okio/-buffered-source/read-long/#readlong","text":"[js, jvm, native] Content [js, jvm, native] abstract fun readLong (): Long","title":"readLong"},{"location":"2.x/okio/okio/-buffered-source/read-short-le/","text":"// okio / okio / BufferedSource / readShortLe readShortLe \u00b6 [js, jvm, native] Content [js, jvm, native] abstract fun readShortLe (): Short","title":"readShortLe   - Okio"},{"location":"2.x/okio/okio/-buffered-source/read-short-le/#readshortle","text":"[js, jvm, native] Content [js, jvm, native] abstract fun readShortLe (): Short","title":"readShortLe"},{"location":"2.x/okio/okio/-buffered-source/read-short/","text":"// okio / okio / BufferedSource / readShort readShort \u00b6 [js, jvm, native] Content [js, jvm, native] abstract fun readShort (): Short","title":"readShort   - Okio"},{"location":"2.x/okio/okio/-buffered-source/read-short/#readshort","text":"[js, jvm, native] Content [js, jvm, native] abstract fun readShort (): Short","title":"readShort"},{"location":"2.x/okio/okio/-buffered-source/read-string/","text":"// okio / okio / BufferedSource / readString readString \u00b6 [jvm] Brief description Removes all bytes from this, decodes them as charset, and returns the string. Content abstract fun readString (charset: Charset ): String [jvm] Brief description Removes byteCount bytes from this, decodes them as charset, and returns the string. Content abstract fun readString (byteCount: Long , charset: Charset ): String","title":"readString   - Okio"},{"location":"2.x/okio/okio/-buffered-source/read-string/#readstring","text":"[jvm] Brief description Removes all bytes from this, decodes them as charset, and returns the string. Content abstract fun readString (charset: Charset ): String [jvm] Brief description Removes byteCount bytes from this, decodes them as charset, and returns the string. Content abstract fun readString (byteCount: Long , charset: Charset ): String","title":"readString"},{"location":"2.x/okio/okio/-buffered-source/read-utf8-code-point/","text":"// okio / okio / BufferedSource / readUtf8CodePoint readUtf8CodePoint \u00b6 [js, jvm, native] Content [js, jvm, native] abstract fun readUtf8CodePoint (): Int","title":"readUtf8CodePoint   - Okio"},{"location":"2.x/okio/okio/-buffered-source/read-utf8-code-point/#readutf8codepoint","text":"[js, jvm, native] Content [js, jvm, native] abstract fun readUtf8CodePoint (): Int","title":"readUtf8CodePoint"},{"location":"2.x/okio/okio/-buffered-source/read-utf8-line-strict/","text":"// okio / okio / BufferedSource / readUtf8LineStrict readUtf8LineStrict \u00b6 [js, jvm, native] Content [js, jvm, native] abstract fun readUtf8LineStrict (): String [js, jvm, native] abstract fun readUtf8LineStrict (limit: Long ): String","title":"readUtf8LineStrict   - Okio"},{"location":"2.x/okio/okio/-buffered-source/read-utf8-line-strict/#readutf8linestrict","text":"[js, jvm, native] Content [js, jvm, native] abstract fun readUtf8LineStrict (): String [js, jvm, native] abstract fun readUtf8LineStrict (limit: Long ): String","title":"readUtf8LineStrict"},{"location":"2.x/okio/okio/-buffered-source/read-utf8-line/","text":"// okio / okio / BufferedSource / readUtf8Line readUtf8Line \u00b6 [js, jvm, native] Content [js, jvm, native] abstract fun readUtf8Line (): String ?","title":"readUtf8Line   - Okio"},{"location":"2.x/okio/okio/-buffered-source/read-utf8-line/#readutf8line","text":"[js, jvm, native] Content [js, jvm, native] abstract fun readUtf8Line (): String ?","title":"readUtf8Line"},{"location":"2.x/okio/okio/-buffered-source/read-utf8/","text":"// okio / okio / BufferedSource / readUtf8 readUtf8 \u00b6 [js, jvm, native] Content [js, jvm, native] abstract fun readUtf8 (): String [js, jvm, native] abstract fun readUtf8 (byteCount: Long ): String","title":"readUtf8   - Okio"},{"location":"2.x/okio/okio/-buffered-source/read-utf8/#readutf8","text":"[js, jvm, native] Content [js, jvm, native] abstract fun readUtf8 (): String [js, jvm, native] abstract fun readUtf8 (byteCount: Long ): String","title":"readUtf8"},{"location":"2.x/okio/okio/-buffered-source/read/","text":"// okio / okio / BufferedSource / read read \u00b6 [js, jvm, native] Content [js, jvm, native] abstract fun read (sink: ByteArray ): Int [js, jvm, native] abstract fun read (sink: ByteArray , offset: Int , byteCount: Int ): Int","title":"read   - Okio"},{"location":"2.x/okio/okio/-buffered-source/read/#read","text":"[js, jvm, native] Content [js, jvm, native] abstract fun read (sink: ByteArray ): Int [js, jvm, native] abstract fun read (sink: ByteArray , offset: Int , byteCount: Int ): Int","title":"read"},{"location":"2.x/okio/okio/-buffered-source/request/","text":"// okio / okio / BufferedSource / request request \u00b6 [js, jvm, native] Content [js, jvm, native] abstract fun request (byteCount: Long ): Boolean","title":"request   - Okio"},{"location":"2.x/okio/okio/-buffered-source/request/#request","text":"[js, jvm, native] Content [js, jvm, native] abstract fun request (byteCount: Long ): Boolean","title":"request"},{"location":"2.x/okio/okio/-buffered-source/require/","text":"// okio / okio / BufferedSource / require require \u00b6 [js, jvm, native] Content [js, jvm, native] abstract fun require (byteCount: Long )","title":"require   - Okio"},{"location":"2.x/okio/okio/-buffered-source/require/#require","text":"[js, jvm, native] Content [js, jvm, native] abstract fun require (byteCount: Long )","title":"require"},{"location":"2.x/okio/okio/-buffered-source/select/","text":"// okio / okio / BufferedSource / select select \u00b6 [js, jvm, native] Content [js, jvm, native] abstract fun select (options: ): Int","title":"select   - Okio"},{"location":"2.x/okio/okio/-buffered-source/select/#select","text":"[js, jvm, native] Content [js, jvm, native] abstract fun select (options: ): Int","title":"select"},{"location":"2.x/okio/okio/-buffered-source/skip/","text":"// okio / okio / BufferedSource / skip skip \u00b6 [js, jvm, native] Content [js, jvm, native] abstract fun skip (byteCount: Long )","title":"skip   - Okio"},{"location":"2.x/okio/okio/-buffered-source/skip/#skip","text":"[js, jvm, native] Content [js, jvm, native] abstract fun skip (byteCount: Long )","title":"skip"},{"location":"2.x/okio/okio/-byte-string/","text":"// okio / okio / ByteString ByteString \u00b6 [js, native] open class ByteString : Comparable [jvm] open class ByteString : Serializable , Comparable Types \u00b6 Name Summary Companion [js, jvm, native] Content [js, jvm, native] object Companion Functions \u00b6 Name Summary asByteBuffer [jvm] Brief description Returns a ByteBuffer view of the bytes in this ByteString. Content open fun asByteBuffer (): ByteBuffer base64 [js, jvm, native] Content [js, jvm, native] open fun base64 (): String base64Url [js, jvm, native] Content [js, jvm, native] open fun base64Url (): String compareTo [js, jvm, native] Content [js, jvm, native] open operator override fun compareTo (other: ByteString ): endsWith [js, jvm, native] Content [js, jvm, native] fun endsWith (suffix: ByteString ): [js, jvm, native] fun endsWith (suffix: ByteArray ): equals [js, jvm, native] Content [js, jvm, native] open operator override fun equals (other: Any ?): get [js, jvm, native] Content [js, native] operator fun get (index: Int ): Byte [jvm] @ JvmName (name = \u201cgetByte\u201d) operator fun get (index: Int ): Byte hashCode [js, jvm, native] Content [js, jvm, native] open override fun hashCode (): hex [js, jvm, native] Content [js, jvm, native] open fun hex (): String hmacSha1 [jvm] Brief description Returns the 160-bit SHA-1 HMAC of this byte string. Content open fun hmacSha1 (key: ByteString ): ByteString hmacSha256 [jvm] Brief description Returns the 256-bit SHA-256 HMAC of this byte string. Content open fun hmacSha256 (key: ByteString ): ByteString hmacSha512 [jvm] Brief description Returns the 512-bit SHA-512 HMAC of this byte string. Content open fun hmacSha512 (key: ByteString ): ByteString indexOf [js, jvm, native] Content [js, native] fun indexOf (other: ByteString , fromIndex: Int ): [jvm] @ JvmOverloads () fun indexOf (other: ByteString , fromIndex: Int ): [js, native] open fun indexOf (other: ByteArray , fromIndex: Int ): [jvm] @ JvmOverloads () open fun indexOf (other: ByteArray , fromIndex: Int ): lastIndexOf [js, jvm, native] Content [js, native] fun lastIndexOf (other: ByteString , fromIndex: Int ): [jvm] @ JvmOverloads () fun lastIndexOf (other: ByteString , fromIndex: Int ): [js, native] open fun lastIndexOf (other: ByteArray , fromIndex: Int ): [jvm] @ JvmOverloads () open fun lastIndexOf (other: ByteArray , fromIndex: Int ): md5 [jvm] Brief description Returns the 128-bit MD5 hash of this byte string. Content open fun md5 (): ByteString rangeEquals [js, jvm, native] Content [js, jvm, native] open fun rangeEquals (offset: Int , other: ByteString , otherOffset: Int , byteCount: Int ): Boolean [js, jvm, native] open fun rangeEquals (offset: Int , other: ByteArray , otherOffset: Int , byteCount: Int ): Boolean sha1 [jvm] Brief description Returns the 160-bit SHA-1 hash of this byte string. Content open fun sha1 (): ByteString sha256 [jvm] Brief description Returns the 256-bit SHA-256 hash of this byte string. Content open fun sha256 (): ByteString sha512 [jvm] Brief description Returns the 512-bit SHA-512 hash of this byte string. Content open fun sha512 (): ByteString startsWith [js, jvm, native] Content [js, jvm, native] fun startsWith (prefix: ByteString ): [js, jvm, native] fun startsWith (prefix: ByteArray ): string [jvm] Brief description Constructs a new String by decoding the bytes using charset. Content open fun string (charset: Charset ): String substring [js, jvm, native] Content [js, native] open fun substring (beginIndex: Int , endIndex: Int ): ByteString [jvm] @ JvmOverloads () open fun substring (beginIndex: Int , endIndex: Int ): ByteString toAsciiLowercase [js, jvm, native] Content [js, jvm, native] open fun toAsciiLowercase (): ByteString toAsciiUppercase [js, jvm, native] Content [js, jvm, native] open fun toAsciiUppercase (): ByteString toByteArray [js, jvm, native] Content [js, jvm, native] open fun toByteArray (): toString [js, native] Brief description Returns a human-readable string that describes the contents of this byte string. Typically this is a string like [text=Hello] or [hex=0000ffff]. Content [js, native] open override fun toString (): [jvm] Brief description Content open override fun toString (): utf8 [js, jvm, native] Content [js, jvm, native] open fun utf8 (): String write [jvm] Brief description Writes the contents of this byte string to out. Content open fun write (out: OutputStream ) Properties \u00b6 Name Summary size [js, jvm, native] val size :","title":"ByteString   - Okio"},{"location":"2.x/okio/okio/-byte-string/#bytestring","text":"[js, native] open class ByteString : Comparable [jvm] open class ByteString : Serializable , Comparable","title":"ByteString"},{"location":"2.x/okio/okio/-byte-string/#types","text":"Name Summary Companion [js, jvm, native] Content [js, jvm, native] object Companion","title":"Types"},{"location":"2.x/okio/okio/-byte-string/#functions","text":"Name Summary asByteBuffer [jvm] Brief description Returns a ByteBuffer view of the bytes in this ByteString. Content open fun asByteBuffer (): ByteBuffer base64 [js, jvm, native] Content [js, jvm, native] open fun base64 (): String base64Url [js, jvm, native] Content [js, jvm, native] open fun base64Url (): String compareTo [js, jvm, native] Content [js, jvm, native] open operator override fun compareTo (other: ByteString ): endsWith [js, jvm, native] Content [js, jvm, native] fun endsWith (suffix: ByteString ): [js, jvm, native] fun endsWith (suffix: ByteArray ): equals [js, jvm, native] Content [js, jvm, native] open operator override fun equals (other: Any ?): get [js, jvm, native] Content [js, native] operator fun get (index: Int ): Byte [jvm] @ JvmName (name = \u201cgetByte\u201d) operator fun get (index: Int ): Byte hashCode [js, jvm, native] Content [js, jvm, native] open override fun hashCode (): hex [js, jvm, native] Content [js, jvm, native] open fun hex (): String hmacSha1 [jvm] Brief description Returns the 160-bit SHA-1 HMAC of this byte string. Content open fun hmacSha1 (key: ByteString ): ByteString hmacSha256 [jvm] Brief description Returns the 256-bit SHA-256 HMAC of this byte string. Content open fun hmacSha256 (key: ByteString ): ByteString hmacSha512 [jvm] Brief description Returns the 512-bit SHA-512 HMAC of this byte string. Content open fun hmacSha512 (key: ByteString ): ByteString indexOf [js, jvm, native] Content [js, native] fun indexOf (other: ByteString , fromIndex: Int ): [jvm] @ JvmOverloads () fun indexOf (other: ByteString , fromIndex: Int ): [js, native] open fun indexOf (other: ByteArray , fromIndex: Int ): [jvm] @ JvmOverloads () open fun indexOf (other: ByteArray , fromIndex: Int ): lastIndexOf [js, jvm, native] Content [js, native] fun lastIndexOf (other: ByteString , fromIndex: Int ): [jvm] @ JvmOverloads () fun lastIndexOf (other: ByteString , fromIndex: Int ): [js, native] open fun lastIndexOf (other: ByteArray , fromIndex: Int ): [jvm] @ JvmOverloads () open fun lastIndexOf (other: ByteArray , fromIndex: Int ): md5 [jvm] Brief description Returns the 128-bit MD5 hash of this byte string. Content open fun md5 (): ByteString rangeEquals [js, jvm, native] Content [js, jvm, native] open fun rangeEquals (offset: Int , other: ByteString , otherOffset: Int , byteCount: Int ): Boolean [js, jvm, native] open fun rangeEquals (offset: Int , other: ByteArray , otherOffset: Int , byteCount: Int ): Boolean sha1 [jvm] Brief description Returns the 160-bit SHA-1 hash of this byte string. Content open fun sha1 (): ByteString sha256 [jvm] Brief description Returns the 256-bit SHA-256 hash of this byte string. Content open fun sha256 (): ByteString sha512 [jvm] Brief description Returns the 512-bit SHA-512 hash of this byte string. Content open fun sha512 (): ByteString startsWith [js, jvm, native] Content [js, jvm, native] fun startsWith (prefix: ByteString ): [js, jvm, native] fun startsWith (prefix: ByteArray ): string [jvm] Brief description Constructs a new String by decoding the bytes using charset. Content open fun string (charset: Charset ): String substring [js, jvm, native] Content [js, native] open fun substring (beginIndex: Int , endIndex: Int ): ByteString [jvm] @ JvmOverloads () open fun substring (beginIndex: Int , endIndex: Int ): ByteString toAsciiLowercase [js, jvm, native] Content [js, jvm, native] open fun toAsciiLowercase (): ByteString toAsciiUppercase [js, jvm, native] Content [js, jvm, native] open fun toAsciiUppercase (): ByteString toByteArray [js, jvm, native] Content [js, jvm, native] open fun toByteArray (): toString [js, native] Brief description Returns a human-readable string that describes the contents of this byte string. Typically this is a string like [text=Hello] or [hex=0000ffff]. Content [js, native] open override fun toString (): [jvm] Brief description Content open override fun toString (): utf8 [js, jvm, native] Content [js, jvm, native] open fun utf8 (): String write [jvm] Brief description Writes the contents of this byte string to out. Content open fun write (out: OutputStream )","title":"Functions"},{"location":"2.x/okio/okio/-byte-string/#properties","text":"Name Summary size [js, jvm, native] val size :","title":"Properties"},{"location":"2.x/okio/okio/-byte-string/as-byte-buffer/","text":"// okio / okio / ByteString / asByteBuffer asByteBuffer \u00b6 [jvm] Brief description Returns a ByteBuffer view of the bytes in this ByteString. Content open fun asByteBuffer (): ByteBuffer","title":"asByteBuffer   - Okio"},{"location":"2.x/okio/okio/-byte-string/as-byte-buffer/#asbytebuffer","text":"[jvm] Brief description Returns a ByteBuffer view of the bytes in this ByteString. Content open fun asByteBuffer (): ByteBuffer","title":"asByteBuffer"},{"location":"2.x/okio/okio/-byte-string/base64-url/","text":"// okio / okio / ByteString / base64Url base64Url \u00b6 [js, jvm, native] Content [js, jvm, native] open fun base64Url (): String","title":"base64Url   - Okio"},{"location":"2.x/okio/okio/-byte-string/base64-url/#base64url","text":"[js, jvm, native] Content [js, jvm, native] open fun base64Url (): String","title":"base64Url"},{"location":"2.x/okio/okio/-byte-string/base64/","text":"// okio / okio / ByteString / base64 base64 \u00b6 [js, jvm, native] Content [js, jvm, native] open fun base64 (): String","title":"base64   - Okio"},{"location":"2.x/okio/okio/-byte-string/base64/#base64","text":"[js, jvm, native] Content [js, jvm, native] open fun base64 (): String","title":"base64"},{"location":"2.x/okio/okio/-byte-string/compare-to/","text":"// okio / okio / ByteString / compareTo compareTo \u00b6 [js, jvm, native] Content [js, jvm, native] open operator override fun compareTo (other: ByteString ):","title":"compareTo   - Okio"},{"location":"2.x/okio/okio/-byte-string/compare-to/#compareto","text":"[js, jvm, native] Content [js, jvm, native] open operator override fun compareTo (other: ByteString ):","title":"compareTo"},{"location":"2.x/okio/okio/-byte-string/ends-with/","text":"// okio / okio / ByteString / endsWith endsWith \u00b6 [js, jvm, native] Content [js, jvm, native] fun endsWith (suffix: ByteString ): [js, jvm, native] fun endsWith (suffix: ByteArray ):","title":"endsWith   - Okio"},{"location":"2.x/okio/okio/-byte-string/ends-with/#endswith","text":"[js, jvm, native] Content [js, jvm, native] fun endsWith (suffix: ByteString ): [js, jvm, native] fun endsWith (suffix: ByteArray ):","title":"endsWith"},{"location":"2.x/okio/okio/-byte-string/equals/","text":"// okio / okio / ByteString / equals equals \u00b6 [js, jvm, native] Content [js, jvm, native] open operator override fun equals (other: Any ?):","title":"equals   - Okio"},{"location":"2.x/okio/okio/-byte-string/equals/#equals","text":"[js, jvm, native] Content [js, jvm, native] open operator override fun equals (other: Any ?):","title":"equals"},{"location":"2.x/okio/okio/-byte-string/get/","text":"// okio / okio / ByteString / get get \u00b6 [js, jvm, native] Content [js, native] operator fun get (index: Int ): Byte [jvm] @ JvmName (name = \u201cgetByte\u201d) operator fun get (index: Int ): Byte","title":"get   - Okio"},{"location":"2.x/okio/okio/-byte-string/get/#get","text":"[js, jvm, native] Content [js, native] operator fun get (index: Int ): Byte [jvm] @ JvmName (name = \u201cgetByte\u201d) operator fun get (index: Int ): Byte","title":"get"},{"location":"2.x/okio/okio/-byte-string/hash-code/","text":"// okio / okio / ByteString / hashCode hashCode \u00b6 [js, jvm, native] Content [js, jvm, native] open override fun hashCode ():","title":"hashCode   - Okio"},{"location":"2.x/okio/okio/-byte-string/hash-code/#hashcode","text":"[js, jvm, native] Content [js, jvm, native] open override fun hashCode ():","title":"hashCode"},{"location":"2.x/okio/okio/-byte-string/hex/","text":"// okio / okio / ByteString / hex hex \u00b6 [js, jvm, native] Content [js, jvm, native] open fun hex (): String","title":"hex   - Okio"},{"location":"2.x/okio/okio/-byte-string/hex/#hex","text":"[js, jvm, native] Content [js, jvm, native] open fun hex (): String","title":"hex"},{"location":"2.x/okio/okio/-byte-string/hmac-sha1/","text":"// okio / okio / ByteString / hmacSha1 hmacSha1 \u00b6 [jvm] Brief description Returns the 160-bit SHA-1 HMAC of this byte string. Content open fun hmacSha1 (key: ByteString ): ByteString","title":"hmacSha1   - Okio"},{"location":"2.x/okio/okio/-byte-string/hmac-sha1/#hmacsha1","text":"[jvm] Brief description Returns the 160-bit SHA-1 HMAC of this byte string. Content open fun hmacSha1 (key: ByteString ): ByteString","title":"hmacSha1"},{"location":"2.x/okio/okio/-byte-string/hmac-sha256/","text":"// okio / okio / ByteString / hmacSha256 hmacSha256 \u00b6 [jvm] Brief description Returns the 256-bit SHA-256 HMAC of this byte string. Content open fun hmacSha256 (key: ByteString ): ByteString","title":"hmacSha256   - Okio"},{"location":"2.x/okio/okio/-byte-string/hmac-sha256/#hmacsha256","text":"[jvm] Brief description Returns the 256-bit SHA-256 HMAC of this byte string. Content open fun hmacSha256 (key: ByteString ): ByteString","title":"hmacSha256"},{"location":"2.x/okio/okio/-byte-string/hmac-sha512/","text":"// okio / okio / ByteString / hmacSha512 hmacSha512 \u00b6 [jvm] Brief description Returns the 512-bit SHA-512 HMAC of this byte string. Content open fun hmacSha512 (key: ByteString ): ByteString","title":"hmacSha512   - Okio"},{"location":"2.x/okio/okio/-byte-string/hmac-sha512/#hmacsha512","text":"[jvm] Brief description Returns the 512-bit SHA-512 HMAC of this byte string. Content open fun hmacSha512 (key: ByteString ): ByteString","title":"hmacSha512"},{"location":"2.x/okio/okio/-byte-string/index-of/","text":"// okio / okio / ByteString / indexOf indexOf \u00b6 [js, jvm, native] Content [js, native] fun indexOf (other: ByteString , fromIndex: Int ): [jvm] @ JvmOverloads () fun indexOf (other: ByteString , fromIndex: Int ): [js, native] open fun indexOf (other: ByteArray , fromIndex: Int ): [jvm] @ JvmOverloads () open fun indexOf (other: ByteArray , fromIndex: Int ):","title":"indexOf   - Okio"},{"location":"2.x/okio/okio/-byte-string/index-of/#indexof","text":"[js, jvm, native] Content [js, native] fun indexOf (other: ByteString , fromIndex: Int ): [jvm] @ JvmOverloads () fun indexOf (other: ByteString , fromIndex: Int ): [js, native] open fun indexOf (other: ByteArray , fromIndex: Int ): [jvm] @ JvmOverloads () open fun indexOf (other: ByteArray , fromIndex: Int ):","title":"indexOf"},{"location":"2.x/okio/okio/-byte-string/last-index-of/","text":"// okio / okio / ByteString / lastIndexOf lastIndexOf \u00b6 [js, jvm, native] Content [js, native] fun lastIndexOf (other: ByteString , fromIndex: Int ): [jvm] @ JvmOverloads () fun lastIndexOf (other: ByteString , fromIndex: Int ): [js, native] open fun lastIndexOf (other: ByteArray , fromIndex: Int ): [jvm] @ JvmOverloads () open fun lastIndexOf (other: ByteArray , fromIndex: Int ):","title":"lastIndexOf   - Okio"},{"location":"2.x/okio/okio/-byte-string/last-index-of/#lastindexof","text":"[js, jvm, native] Content [js, native] fun lastIndexOf (other: ByteString , fromIndex: Int ): [jvm] @ JvmOverloads () fun lastIndexOf (other: ByteString , fromIndex: Int ): [js, native] open fun lastIndexOf (other: ByteArray , fromIndex: Int ): [jvm] @ JvmOverloads () open fun lastIndexOf (other: ByteArray , fromIndex: Int ):","title":"lastIndexOf"},{"location":"2.x/okio/okio/-byte-string/md5/","text":"// okio / okio / ByteString / md5 md5 \u00b6 [jvm] Brief description Returns the 128-bit MD5 hash of this byte string. Content open fun md5 (): ByteString","title":"md5   - Okio"},{"location":"2.x/okio/okio/-byte-string/md5/#md5","text":"[jvm] Brief description Returns the 128-bit MD5 hash of this byte string. Content open fun md5 (): ByteString","title":"md5"},{"location":"2.x/okio/okio/-byte-string/range-equals/","text":"// okio / okio / ByteString / rangeEquals rangeEquals \u00b6 [js, jvm, native] Content [js, jvm, native] open fun rangeEquals (offset: Int , other: ByteString , otherOffset: Int , byteCount: Int ): Boolean [js, jvm, native] open fun rangeEquals (offset: Int , other: ByteArray , otherOffset: Int , byteCount: Int ): Boolean","title":"rangeEquals   - Okio"},{"location":"2.x/okio/okio/-byte-string/range-equals/#rangeequals","text":"[js, jvm, native] Content [js, jvm, native] open fun rangeEquals (offset: Int , other: ByteString , otherOffset: Int , byteCount: Int ): Boolean [js, jvm, native] open fun rangeEquals (offset: Int , other: ByteArray , otherOffset: Int , byteCount: Int ): Boolean","title":"rangeEquals"},{"location":"2.x/okio/okio/-byte-string/sha1/","text":"// okio / okio / ByteString / sha1 sha1 \u00b6 [jvm] Brief description Returns the 160-bit SHA-1 hash of this byte string. Content open fun sha1 (): ByteString","title":"sha1   - Okio"},{"location":"2.x/okio/okio/-byte-string/sha1/#sha1","text":"[jvm] Brief description Returns the 160-bit SHA-1 hash of this byte string. Content open fun sha1 (): ByteString","title":"sha1"},{"location":"2.x/okio/okio/-byte-string/sha256/","text":"// okio / okio / ByteString / sha256 sha256 \u00b6 [jvm] Brief description Returns the 256-bit SHA-256 hash of this byte string. Content open fun sha256 (): ByteString","title":"sha256   - Okio"},{"location":"2.x/okio/okio/-byte-string/sha256/#sha256","text":"[jvm] Brief description Returns the 256-bit SHA-256 hash of this byte string. Content open fun sha256 (): ByteString","title":"sha256"},{"location":"2.x/okio/okio/-byte-string/sha512/","text":"// okio / okio / ByteString / sha512 sha512 \u00b6 [jvm] Brief description Returns the 512-bit SHA-512 hash of this byte string. Content open fun sha512 (): ByteString","title":"sha512   - Okio"},{"location":"2.x/okio/okio/-byte-string/sha512/#sha512","text":"[jvm] Brief description Returns the 512-bit SHA-512 hash of this byte string. Content open fun sha512 (): ByteString","title":"sha512"},{"location":"2.x/okio/okio/-byte-string/starts-with/","text":"// okio / okio / ByteString / startsWith startsWith \u00b6 [js, jvm, native] Content [js, jvm, native] fun startsWith (prefix: ByteString ): [js, jvm, native] fun startsWith (prefix: ByteArray ):","title":"startsWith   - Okio"},{"location":"2.x/okio/okio/-byte-string/starts-with/#startswith","text":"[js, jvm, native] Content [js, jvm, native] fun startsWith (prefix: ByteString ): [js, jvm, native] fun startsWith (prefix: ByteArray ):","title":"startsWith"},{"location":"2.x/okio/okio/-byte-string/string/","text":"// okio / okio / ByteString / string string \u00b6 [jvm] Brief description Constructs a new String by decoding the bytes using charset. Content open fun string (charset: Charset ): String","title":"string   - Okio"},{"location":"2.x/okio/okio/-byte-string/string/#string","text":"[jvm] Brief description Constructs a new String by decoding the bytes using charset. Content open fun string (charset: Charset ): String","title":"string"},{"location":"2.x/okio/okio/-byte-string/substring/","text":"// okio / okio / ByteString / substring substring \u00b6 [js, jvm, native] Content [js, native] open fun substring (beginIndex: Int , endIndex: Int ): ByteString [jvm] @ JvmOverloads () open fun substring (beginIndex: Int , endIndex: Int ): ByteString","title":"substring   - Okio"},{"location":"2.x/okio/okio/-byte-string/substring/#substring","text":"[js, jvm, native] Content [js, native] open fun substring (beginIndex: Int , endIndex: Int ): ByteString [jvm] @ JvmOverloads () open fun substring (beginIndex: Int , endIndex: Int ): ByteString","title":"substring"},{"location":"2.x/okio/okio/-byte-string/to-ascii-lowercase/","text":"// okio / okio / ByteString / toAsciiLowercase toAsciiLowercase \u00b6 [js, jvm, native] Content [js, jvm, native] open fun toAsciiLowercase (): ByteString","title":"toAsciiLowercase   - Okio"},{"location":"2.x/okio/okio/-byte-string/to-ascii-lowercase/#toasciilowercase","text":"[js, jvm, native] Content [js, jvm, native] open fun toAsciiLowercase (): ByteString","title":"toAsciiLowercase"},{"location":"2.x/okio/okio/-byte-string/to-ascii-uppercase/","text":"// okio / okio / ByteString / toAsciiUppercase toAsciiUppercase \u00b6 [js, jvm, native] Content [js, jvm, native] open fun toAsciiUppercase (): ByteString","title":"toAsciiUppercase   - Okio"},{"location":"2.x/okio/okio/-byte-string/to-ascii-uppercase/#toasciiuppercase","text":"[js, jvm, native] Content [js, jvm, native] open fun toAsciiUppercase (): ByteString","title":"toAsciiUppercase"},{"location":"2.x/okio/okio/-byte-string/to-byte-array/","text":"// okio / okio / ByteString / toByteArray toByteArray \u00b6 [js, jvm, native] Content [js, jvm, native] open fun toByteArray ():","title":"toByteArray   - Okio"},{"location":"2.x/okio/okio/-byte-string/to-byte-array/#tobytearray","text":"[js, jvm, native] Content [js, jvm, native] open fun toByteArray ():","title":"toByteArray"},{"location":"2.x/okio/okio/-byte-string/to-string/","text":"// okio / okio / ByteString / toString toString \u00b6 [js, native] Brief description Returns a human-readable string that describes the contents of this byte string. Typically this is a string like [text=Hello] or [hex=0000ffff]. Content [js, native] open override fun toString (): [jvm] Brief description Content open override fun toString ():","title":"toString   - Okio"},{"location":"2.x/okio/okio/-byte-string/to-string/#tostring","text":"[js, native] Brief description Returns a human-readable string that describes the contents of this byte string. Typically this is a string like [text=Hello] or [hex=0000ffff]. Content [js, native] open override fun toString (): [jvm] Brief description Content open override fun toString ():","title":"toString"},{"location":"2.x/okio/okio/-byte-string/utf8/","text":"// okio / okio / ByteString / utf8 utf8 \u00b6 [js, jvm, native] Content [js, jvm, native] open fun utf8 (): String","title":"utf8   - Okio"},{"location":"2.x/okio/okio/-byte-string/utf8/#utf8","text":"[js, jvm, native] Content [js, jvm, native] open fun utf8 (): String","title":"utf8"},{"location":"2.x/okio/okio/-byte-string/write/","text":"// okio / okio / ByteString / write write \u00b6 [jvm] Brief description Writes the contents of this byte string to out. Content open fun write (out: OutputStream )","title":"write   - Okio"},{"location":"2.x/okio/okio/-byte-string/write/#write","text":"[jvm] Brief description Writes the contents of this byte string to out. Content open fun write (out: OutputStream )","title":"write"},{"location":"2.x/okio/okio/-byte-string/-companion/","text":"// okio / okio / ByteString / Companion Companion \u00b6 [js, jvm, native] object Companion Functions \u00b6 Name Summary decodeBase64 [js, jvm, native] Content [js, native] fun String . decodeBase64 (): ByteString ? [jvm] @ JvmStatic () fun String . decodeBase64 (): ByteString ? decodeHex [js, jvm, native] Content [js, native] fun String . decodeHex (): [jvm] @ JvmStatic () fun String . decodeHex (): encode [jvm] Brief description Returns a new ByteString containing the charset-encoded bytes of this String . Content @ JvmStatic () @ JvmName (name = \u201cencodeString\u201d) fun String . encode (charset: Charset ): ByteString encodeUtf8 [js, jvm, native] Content [js, native] fun String . encodeUtf8 (): ByteString [jvm] @ JvmStatic () fun String . encodeUtf8 (): ByteString equals [js, jvm, native] Content [js, jvm, native] open operator override fun equals (other: Any ?): Boolean hashCode [js, jvm, native] Content [js, jvm, native] open override fun hashCode (): Int of [js, jvm, native] Content [js, native] fun of (vararg data: ByteArray ): [jvm] @ JvmStatic () fun of (vararg data: ByteArray ): readByteString [jvm] Brief description Reads count bytes from this InputStream and returns the result. Content @ JvmStatic () @ JvmName (name = \u201cread\u201d) fun InputStream . readByteString (byteCount: Int ): ByteString toByteString [js, jvm, native] Content [js, native] fun ByteArray . toByteString (offset: Int , byteCount: Int ): ByteString [jvm] @ JvmStatic () @ JvmName (name = \u201cof\u201d) fun ByteArray . toByteString (offset: Int , byteCount: Int ): ByteString [jvm] Brief description Returns a ByteString containing a copy of this ByteBuffer . Content @ JvmStatic () @ JvmName (name = \u201cof\u201d) fun ByteBuffer . toByteString (): ByteString toString [js, jvm, native] Content [js, jvm, native] open override fun toString (): String Properties \u00b6 Name Summary EMPTY [js, native] val EMPTY : ByteString [jvm] @ JvmField () val EMPTY : ByteString","title":"Companion   - Okio"},{"location":"2.x/okio/okio/-byte-string/-companion/#companion","text":"[js, jvm, native] object Companion","title":"Companion"},{"location":"2.x/okio/okio/-byte-string/-companion/#functions","text":"Name Summary decodeBase64 [js, jvm, native] Content [js, native] fun String . decodeBase64 (): ByteString ? [jvm] @ JvmStatic () fun String . decodeBase64 (): ByteString ? decodeHex [js, jvm, native] Content [js, native] fun String . decodeHex (): [jvm] @ JvmStatic () fun String . decodeHex (): encode [jvm] Brief description Returns a new ByteString containing the charset-encoded bytes of this String . Content @ JvmStatic () @ JvmName (name = \u201cencodeString\u201d) fun String . encode (charset: Charset ): ByteString encodeUtf8 [js, jvm, native] Content [js, native] fun String . encodeUtf8 (): ByteString [jvm] @ JvmStatic () fun String . encodeUtf8 (): ByteString equals [js, jvm, native] Content [js, jvm, native] open operator override fun equals (other: Any ?): Boolean hashCode [js, jvm, native] Content [js, jvm, native] open override fun hashCode (): Int of [js, jvm, native] Content [js, native] fun of (vararg data: ByteArray ): [jvm] @ JvmStatic () fun of (vararg data: ByteArray ): readByteString [jvm] Brief description Reads count bytes from this InputStream and returns the result. Content @ JvmStatic () @ JvmName (name = \u201cread\u201d) fun InputStream . readByteString (byteCount: Int ): ByteString toByteString [js, jvm, native] Content [js, native] fun ByteArray . toByteString (offset: Int , byteCount: Int ): ByteString [jvm] @ JvmStatic () @ JvmName (name = \u201cof\u201d) fun ByteArray . toByteString (offset: Int , byteCount: Int ): ByteString [jvm] Brief description Returns a ByteString containing a copy of this ByteBuffer . Content @ JvmStatic () @ JvmName (name = \u201cof\u201d) fun ByteBuffer . toByteString (): ByteString toString [js, jvm, native] Content [js, jvm, native] open override fun toString (): String","title":"Functions"},{"location":"2.x/okio/okio/-byte-string/-companion/#properties","text":"Name Summary EMPTY [js, native] val EMPTY : ByteString [jvm] @ JvmField () val EMPTY : ByteString","title":"Properties"},{"location":"2.x/okio/okio/-byte-string/-companion/decode-base64/","text":"// okio / okio / ByteString / Companion / decodeBase64 decodeBase64 \u00b6 [js, jvm, native] Content [js, native] fun String . decodeBase64 (): ByteString ? [jvm] @ JvmStatic () fun String . decodeBase64 (): ByteString ?","title":"decodeBase64   - Okio"},{"location":"2.x/okio/okio/-byte-string/-companion/decode-base64/#decodebase64","text":"[js, jvm, native] Content [js, native] fun String . decodeBase64 (): ByteString ? [jvm] @ JvmStatic () fun String . decodeBase64 (): ByteString ?","title":"decodeBase64"},{"location":"2.x/okio/okio/-byte-string/-companion/decode-hex/","text":"// okio / okio / ByteString / Companion / decodeHex decodeHex \u00b6 [js, jvm, native] Content [js, native] fun String . decodeHex (): [jvm] @ JvmStatic () fun String . decodeHex ():","title":"decodeHex   - Okio"},{"location":"2.x/okio/okio/-byte-string/-companion/decode-hex/#decodehex","text":"[js, jvm, native] Content [js, native] fun String . decodeHex (): [jvm] @ JvmStatic () fun String . decodeHex ():","title":"decodeHex"},{"location":"2.x/okio/okio/-byte-string/-companion/encode-utf8/","text":"// okio / okio / ByteString / Companion / encodeUtf8 encodeUtf8 \u00b6 [js, jvm, native] Content [js, native] fun String . encodeUtf8 (): ByteString [jvm] @ JvmStatic () fun String . encodeUtf8 (): ByteString","title":"encodeUtf8   - Okio"},{"location":"2.x/okio/okio/-byte-string/-companion/encode-utf8/#encodeutf8","text":"[js, jvm, native] Content [js, native] fun String . encodeUtf8 (): ByteString [jvm] @ JvmStatic () fun String . encodeUtf8 (): ByteString","title":"encodeUtf8"},{"location":"2.x/okio/okio/-byte-string/-companion/encode/","text":"// okio / okio / ByteString / Companion / encode encode \u00b6 [jvm] Brief description Returns a new ByteString containing the charset-encoded bytes of this String . Content @ JvmStatic () @ JvmName (name = \u201cencodeString\u201d) fun String . encode (charset: Charset ): ByteString","title":"encode   - Okio"},{"location":"2.x/okio/okio/-byte-string/-companion/encode/#encode","text":"[jvm] Brief description Returns a new ByteString containing the charset-encoded bytes of this String . Content @ JvmStatic () @ JvmName (name = \u201cencodeString\u201d) fun String . encode (charset: Charset ): ByteString","title":"encode"},{"location":"2.x/okio/okio/-byte-string/-companion/of/","text":"// okio / okio / ByteString / Companion / of of \u00b6 [js, jvm, native] Content [js, native] fun of (vararg data: ByteArray ): [jvm] @ JvmStatic () fun of (vararg data: ByteArray ):","title":"of   - Okio"},{"location":"2.x/okio/okio/-byte-string/-companion/of/#of","text":"[js, jvm, native] Content [js, native] fun of (vararg data: ByteArray ): [jvm] @ JvmStatic () fun of (vararg data: ByteArray ):","title":"of"},{"location":"2.x/okio/okio/-byte-string/-companion/read-byte-string/","text":"// okio / okio / ByteString / Companion / readByteString readByteString \u00b6 [jvm] Brief description Reads count bytes from this InputStream and returns the result. Content @ JvmStatic () @ JvmName (name = \u201cread\u201d) fun InputStream . readByteString (byteCount: Int ): ByteString","title":"readByteString   - Okio"},{"location":"2.x/okio/okio/-byte-string/-companion/read-byte-string/#readbytestring","text":"[jvm] Brief description Reads count bytes from this InputStream and returns the result. Content @ JvmStatic () @ JvmName (name = \u201cread\u201d) fun InputStream . readByteString (byteCount: Int ): ByteString","title":"readByteString"},{"location":"2.x/okio/okio/-byte-string/-companion/to-byte-string/","text":"// okio / okio / ByteString / Companion / toByteString toByteString \u00b6 [js, jvm, native] Content [js, native] fun ByteArray . toByteString (offset: Int , byteCount: Int ): ByteString [jvm] @ JvmStatic () @ JvmName (name = \u201cof\u201d) fun ByteArray . toByteString (offset: Int , byteCount: Int ): ByteString [jvm] Brief description Returns a ByteString containing a copy of this ByteBuffer . Content @ JvmStatic () @ JvmName (name = \u201cof\u201d) fun ByteBuffer . toByteString (): ByteString","title":"toByteString   - Okio"},{"location":"2.x/okio/okio/-byte-string/-companion/to-byte-string/#tobytestring","text":"[js, jvm, native] Content [js, native] fun ByteArray . toByteString (offset: Int , byteCount: Int ): ByteString [jvm] @ JvmStatic () @ JvmName (name = \u201cof\u201d) fun ByteArray . toByteString (offset: Int , byteCount: Int ): ByteString [jvm] Brief description Returns a ByteString containing a copy of this ByteBuffer . Content @ JvmStatic () @ JvmName (name = \u201cof\u201d) fun ByteBuffer . toByteString (): ByteString","title":"toByteString"},{"location":"2.x/okio/okio/-deflater-sink/","text":"// okio / okio / DeflaterSink DeflaterSink \u00b6 [jvm] A sink that uses DEFLATE to compress data written to another source. Sync flush \u00b6 Aggressive flushing of this stream may result in reduced compression. Each call to flush immediately compresses all currently-buffered data; this early compression may be less effective than compression performed without flushing.This is equivalent to using Deflater with the sync flush option. This class does not offer any partial flush mechanism. For best performance, only call flush when application behavior requires it. class DeflaterSink : Sink Constructors \u00b6 Name Summary [jvm] fun (sink: Sink , deflater: Deflater ) Functions \u00b6 Name Summary close [jvm] Content open override fun close () equals [jvm] Content open operator override fun equals (other: Any ?): Boolean flush [jvm] Content open override fun flush () hashCode [jvm] Content open override fun hashCode (): Int timeout [jvm] Content open override fun timeout (): Timeout toString [jvm] Content open override fun toString (): String write [jvm] Content open override fun write (source: Buffer , byteCount: Long )","title":"DeflaterSink   - Okio"},{"location":"2.x/okio/okio/-deflater-sink/#deflatersink","text":"[jvm] A sink that uses DEFLATE to compress data written to another source.","title":"DeflaterSink"},{"location":"2.x/okio/okio/-deflater-sink/#sync-flush","text":"Aggressive flushing of this stream may result in reduced compression. Each call to flush immediately compresses all currently-buffered data; this early compression may be less effective than compression performed without flushing.This is equivalent to using Deflater with the sync flush option. This class does not offer any partial flush mechanism. For best performance, only call flush when application behavior requires it. class DeflaterSink : Sink","title":"Sync flush"},{"location":"2.x/okio/okio/-deflater-sink/#constructors","text":"Name Summary [jvm] fun (sink: Sink , deflater: Deflater )","title":"Constructors"},{"location":"2.x/okio/okio/-deflater-sink/#functions","text":"Name Summary close [jvm] Content open override fun close () equals [jvm] Content open operator override fun equals (other: Any ?): Boolean flush [jvm] Content open override fun flush () hashCode [jvm] Content open override fun hashCode (): Int timeout [jvm] Content open override fun timeout (): Timeout toString [jvm] Content open override fun toString (): String write [jvm] Content open override fun write (source: Buffer , byteCount: Long )","title":"Functions"},{"location":"2.x/okio/okio/-deflater-sink/-init-/","text":"// okio / okio / DeflaterSink / \u00b6 [jvm] Content fun (sink: Sink , deflater: Deflater )","title":"<init>   - Okio"},{"location":"2.x/okio/okio/-deflater-sink/-init-/#_1","text":"[jvm] Content fun (sink: Sink , deflater: Deflater )","title":""},{"location":"2.x/okio/okio/-deflater-sink/close/","text":"// okio / okio / DeflaterSink / close close \u00b6 [jvm] Content open override fun close ()","title":"close   - Okio"},{"location":"2.x/okio/okio/-deflater-sink/close/#close","text":"[jvm] Content open override fun close ()","title":"close"},{"location":"2.x/okio/okio/-deflater-sink/flush/","text":"// okio / okio / DeflaterSink / flush flush \u00b6 [jvm] Content open override fun flush ()","title":"flush   - Okio"},{"location":"2.x/okio/okio/-deflater-sink/flush/#flush","text":"[jvm] Content open override fun flush ()","title":"flush"},{"location":"2.x/okio/okio/-deflater-sink/timeout/","text":"// okio / okio / DeflaterSink / timeout timeout \u00b6 [jvm] Content open override fun timeout (): Timeout","title":"timeout   - Okio"},{"location":"2.x/okio/okio/-deflater-sink/timeout/#timeout","text":"[jvm] Content open override fun timeout (): Timeout","title":"timeout"},{"location":"2.x/okio/okio/-deflater-sink/to-string/","text":"// okio / okio / DeflaterSink / toString toString \u00b6 [jvm] Content open override fun toString (): String","title":"toString   - Okio"},{"location":"2.x/okio/okio/-deflater-sink/to-string/#tostring","text":"[jvm] Content open override fun toString (): String","title":"toString"},{"location":"2.x/okio/okio/-deflater-sink/write/","text":"// okio / okio / DeflaterSink / write write \u00b6 [jvm] Content open override fun write (source: Buffer , byteCount: Long )","title":"write   - Okio"},{"location":"2.x/okio/okio/-deflater-sink/write/#write","text":"[jvm] Content open override fun write (source: Buffer , byteCount: Long )","title":"write"},{"location":"2.x/okio/okio/-e-o-f-exception/","text":"// okio / okio / EOFException EOFException \u00b6 [js, native] open class EOFException ( message : String ?) : IOException Functions \u00b6 Name Summary equals [js, native] Content [js, native] open operator override fun equals (other: Any ?): Boolean hashCode [js, native] Content [js, native] open override fun hashCode (): Int toString [js, native] Content [js, native] open override fun toString (): String Properties \u00b6 Name Summary cause [js] open override val cause : Throwable ? message [js] open override val message : String ?","title":"EOFException   - Okio"},{"location":"2.x/okio/okio/-e-o-f-exception/#eofexception","text":"[js, native] open class EOFException ( message : String ?) : IOException","title":"EOFException"},{"location":"2.x/okio/okio/-e-o-f-exception/#functions","text":"Name Summary equals [js, native] Content [js, native] open operator override fun equals (other: Any ?): Boolean hashCode [js, native] Content [js, native] open override fun hashCode (): Int toString [js, native] Content [js, native] open override fun toString (): String","title":"Functions"},{"location":"2.x/okio/okio/-e-o-f-exception/#properties","text":"Name Summary cause [js] open override val cause : Throwable ? message [js] open override val message : String ?","title":"Properties"},{"location":"2.x/okio/okio/-e-o-f-exception/-init-/","text":"// okio / okio / EOFException / \u00b6 [js, native] Content [js, native] fun (message: String ?)","title":"<init>   - Okio"},{"location":"2.x/okio/okio/-e-o-f-exception/-init-/#_1","text":"[js, native] Content [js, native] fun (message: String ?)","title":""},{"location":"2.x/okio/okio/-forwarding-sink/","text":"// okio / okio / ForwardingSink ForwardingSink \u00b6 [jvm] A Sink which forwards calls to another. Useful for subclassing. abstract class ForwardingSink ( delegate : Sink ) : Sink Constructors \u00b6 Name Summary [jvm] fun (delegate: Sink ) Functions \u00b6 Name Summary close [jvm] Content open override fun close () equals [jvm] Content open operator override fun equals (other: Any ?): Boolean flush [jvm] Content open override fun flush () hashCode [jvm] Content open override fun hashCode (): Int timeout [jvm] Content open override fun timeout (): Timeout toString [jvm] Content open override fun toString (): String write [jvm] Content open override fun write (source: Buffer , byteCount: Long ) Properties \u00b6 Name Summary delegate [jvm] Sink to which this instance is delegating.val delegate : Sink Inheritors \u00b6 Name HashingSink","title":"ForwardingSink   - Okio"},{"location":"2.x/okio/okio/-forwarding-sink/#forwardingsink","text":"[jvm] A Sink which forwards calls to another. Useful for subclassing. abstract class ForwardingSink ( delegate : Sink ) : Sink","title":"ForwardingSink"},{"location":"2.x/okio/okio/-forwarding-sink/#constructors","text":"Name Summary [jvm] fun (delegate: Sink )","title":"Constructors"},{"location":"2.x/okio/okio/-forwarding-sink/#functions","text":"Name Summary close [jvm] Content open override fun close () equals [jvm] Content open operator override fun equals (other: Any ?): Boolean flush [jvm] Content open override fun flush () hashCode [jvm] Content open override fun hashCode (): Int timeout [jvm] Content open override fun timeout (): Timeout toString [jvm] Content open override fun toString (): String write [jvm] Content open override fun write (source: Buffer , byteCount: Long )","title":"Functions"},{"location":"2.x/okio/okio/-forwarding-sink/#properties","text":"Name Summary delegate [jvm] Sink to which this instance is delegating.val delegate : Sink","title":"Properties"},{"location":"2.x/okio/okio/-forwarding-sink/#inheritors","text":"Name HashingSink","title":"Inheritors"},{"location":"2.x/okio/okio/-forwarding-sink/-init-/","text":"// okio / okio / ForwardingSink / \u00b6 [jvm] Content fun (delegate: Sink )","title":"<init>   - Okio"},{"location":"2.x/okio/okio/-forwarding-sink/-init-/#_1","text":"[jvm] Content fun (delegate: Sink )","title":""},{"location":"2.x/okio/okio/-forwarding-sink/close/","text":"// okio / okio / ForwardingSink / close close \u00b6 [jvm] Content open override fun close ()","title":"close   - Okio"},{"location":"2.x/okio/okio/-forwarding-sink/close/#close","text":"[jvm] Content open override fun close ()","title":"close"},{"location":"2.x/okio/okio/-forwarding-sink/flush/","text":"// okio / okio / ForwardingSink / flush flush \u00b6 [jvm] Content open override fun flush ()","title":"flush   - Okio"},{"location":"2.x/okio/okio/-forwarding-sink/flush/#flush","text":"[jvm] Content open override fun flush ()","title":"flush"},{"location":"2.x/okio/okio/-forwarding-sink/timeout/","text":"// okio / okio / ForwardingSink / timeout timeout \u00b6 [jvm] Content open override fun timeout (): Timeout","title":"timeout   - Okio"},{"location":"2.x/okio/okio/-forwarding-sink/timeout/#timeout","text":"[jvm] Content open override fun timeout (): Timeout","title":"timeout"},{"location":"2.x/okio/okio/-forwarding-sink/to-string/","text":"// okio / okio / ForwardingSink / toString toString \u00b6 [jvm] Content open override fun toString (): String","title":"toString   - Okio"},{"location":"2.x/okio/okio/-forwarding-sink/to-string/#tostring","text":"[jvm] Content open override fun toString (): String","title":"toString"},{"location":"2.x/okio/okio/-forwarding-sink/write/","text":"// okio / okio / ForwardingSink / write write \u00b6 [jvm] Content open override fun write (source: Buffer , byteCount: Long )","title":"write   - Okio"},{"location":"2.x/okio/okio/-forwarding-sink/write/#write","text":"[jvm] Content open override fun write (source: Buffer , byteCount: Long )","title":"write"},{"location":"2.x/okio/okio/-forwarding-source/","text":"// okio / okio / ForwardingSource ForwardingSource \u00b6 [jvm] A Source which forwards calls to another. Useful for subclassing. abstract class ForwardingSource ( delegate : Source ) : Source Constructors \u00b6 Name Summary [jvm] fun (delegate: Source ) Functions \u00b6 Name Summary close [jvm] Content open override fun close () equals [jvm] Content open operator override fun equals (other: Any ?): Boolean hashCode [jvm] Content open override fun hashCode (): Int read [jvm] Content open override fun read (sink: Buffer , byteCount: Long ): Long timeout [jvm] Content open override fun timeout (): Timeout toString [jvm] Content open override fun toString (): String Properties \u00b6 Name Summary delegate [jvm] Source to which this instance is delegating.val delegate : Source Inheritors \u00b6 Name HashingSource","title":"ForwardingSource   - Okio"},{"location":"2.x/okio/okio/-forwarding-source/#forwardingsource","text":"[jvm] A Source which forwards calls to another. Useful for subclassing. abstract class ForwardingSource ( delegate : Source ) : Source","title":"ForwardingSource"},{"location":"2.x/okio/okio/-forwarding-source/#constructors","text":"Name Summary [jvm] fun (delegate: Source )","title":"Constructors"},{"location":"2.x/okio/okio/-forwarding-source/#functions","text":"Name Summary close [jvm] Content open override fun close () equals [jvm] Content open operator override fun equals (other: Any ?): Boolean hashCode [jvm] Content open override fun hashCode (): Int read [jvm] Content open override fun read (sink: Buffer , byteCount: Long ): Long timeout [jvm] Content open override fun timeout (): Timeout toString [jvm] Content open override fun toString (): String","title":"Functions"},{"location":"2.x/okio/okio/-forwarding-source/#properties","text":"Name Summary delegate [jvm] Source to which this instance is delegating.val delegate : Source","title":"Properties"},{"location":"2.x/okio/okio/-forwarding-source/#inheritors","text":"Name HashingSource","title":"Inheritors"},{"location":"2.x/okio/okio/-forwarding-source/-init-/","text":"// okio / okio / ForwardingSource / \u00b6 [jvm] Content fun (delegate: Source )","title":"<init>   - Okio"},{"location":"2.x/okio/okio/-forwarding-source/-init-/#_1","text":"[jvm] Content fun (delegate: Source )","title":""},{"location":"2.x/okio/okio/-forwarding-source/close/","text":"// okio / okio / ForwardingSource / close close \u00b6 [jvm] Content open override fun close ()","title":"close   - Okio"},{"location":"2.x/okio/okio/-forwarding-source/close/#close","text":"[jvm] Content open override fun close ()","title":"close"},{"location":"2.x/okio/okio/-forwarding-source/read/","text":"// okio / okio / ForwardingSource / read read \u00b6 [jvm] Content open override fun read (sink: Buffer , byteCount: Long ): Long","title":"read   - Okio"},{"location":"2.x/okio/okio/-forwarding-source/read/#read","text":"[jvm] Content open override fun read (sink: Buffer , byteCount: Long ): Long","title":"read"},{"location":"2.x/okio/okio/-forwarding-source/timeout/","text":"// okio / okio / ForwardingSource / timeout timeout \u00b6 [jvm] Content open override fun timeout (): Timeout","title":"timeout   - Okio"},{"location":"2.x/okio/okio/-forwarding-source/timeout/#timeout","text":"[jvm] Content open override fun timeout (): Timeout","title":"timeout"},{"location":"2.x/okio/okio/-forwarding-source/to-string/","text":"// okio / okio / ForwardingSource / toString toString \u00b6 [jvm] Content open override fun toString (): String","title":"toString   - Okio"},{"location":"2.x/okio/okio/-forwarding-source/to-string/#tostring","text":"[jvm] Content open override fun toString (): String","title":"toString"},{"location":"2.x/okio/okio/-forwarding-timeout/","text":"// okio / okio / ForwardingTimeout ForwardingTimeout \u00b6 [jvm] A Timeout which forwards calls to another. Useful for subclassing. open class ForwardingTimeout ( delegate : Timeout ) : Timeout Constructors \u00b6 Name Summary [jvm] fun (delegate: Timeout ) Functions \u00b6 Name Summary clearDeadline [jvm] Brief description Clears the deadline. Content open override fun clearDeadline (): Timeout clearTimeout [jvm] Brief description Clears the timeout. Operating system timeouts may still apply. Content open override fun clearTimeout (): Timeout deadline [jvm] Brief description Set a deadline of now plus duration time. Content override fun deadline (duration: Long , unit: TimeUnit ): Timeout deadlineNanoTime [jvm] Brief description Returns the nano time when the deadline will be reached. Content open override fun deadlineNanoTime (): Long [jvm] Brief description Sets the nano time when the deadline will be reached. All operations must complete before this time. Use a deadline to set a maximum bound on the time spent on a sequence of operations. Content open override fun deadlineNanoTime (deadlineNanoTime: Long ): Timeout equals [jvm] Content open operator override fun equals (other: Any ?): Boolean hasDeadline [jvm] Brief description Returns true if a deadline is enabled. Content open override fun hasDeadline (): Boolean hashCode [jvm] Content open override fun hashCode (): Int intersectWith [jvm] Brief description Applies the minimum intersection between this timeout and other, run block, then finally rollback this timeout\u2019s values. Content inline override fun intersectWith (other: Timeout , block: () -> Unit ) setDelegate [jvm] Content fun setDelegate (delegate: Timeout ): ForwardingTimeout throwIfReached [jvm] Brief description Throws an InterruptedIOException if the deadline has been reached or if the current thread has been interrupted. This method doesn\u2019t detect timeouts; that should be implemented to asynchronously abort an in-progress operation. Content open override fun throwIfReached () timeout [jvm] Brief description Wait at most timeout time before aborting an operation. Using a per-operation timeout means that as long as forward progress is being made, no sequence of operations will fail.If timeout == 0, operations will run indefinitely. (Operating system timeouts may still apply.) Content open override fun timeout (timeout: Long , unit: TimeUnit ): Timeout timeoutNanos [jvm] Brief description Returns the timeout in nanoseconds, or 0 for no timeout. Content open override fun timeoutNanos (): Long toString [jvm] Content open override fun toString (): String waitUntilNotified [jvm] Brief description Waits on monitor until it is notified. Throws InterruptedIOException if either the thread is interrupted or if this timeout elapses before monitor is notified. The caller must be synchronized on monitor.Here\u2019s a sample class that uses waitUntilNotified() to await a specific state. Note that the call is made within a loop to avoid unnecessary waiting and to mitigate spurious notifications.class Dice { Random random = new Random(); int latestTotal; public synchronized void roll() { latestTotal = 2 + random.nextInt(6) + random.nextInt(6); System.out.println(\u201cRolled \u201d + latestTotal); notifyAll(); } public void rollAtFixedRate(int period, TimeUnit timeUnit) { Executors.newScheduledThreadPool(0).scheduleAtFixedRate(new Runnable() { public void run() { roll(); } }, 0, period, timeUnit); } public synchronized void awaitTotal(Timeout timeout, int total) throws InterruptedIOException { while (latestTotal != total) { timeout.waitUntilNotified(this); } } } Content override fun waitUntilNotified (monitor: Any ) Properties \u00b6 Name Summary deadlineNanoTime [jvm] override var deadlineNanoTime : Long delegate [jvm] var delegate : Timeout hasDeadline [jvm] True if deadlineNanoTime is defined. There is no equivalent to null or 0 for System.nanoTime .override var hasDeadline : Boolean timeoutNanos [jvm] override var timeoutNanos : Long","title":"ForwardingTimeout   - Okio"},{"location":"2.x/okio/okio/-forwarding-timeout/#forwardingtimeout","text":"[jvm] A Timeout which forwards calls to another. Useful for subclassing. open class ForwardingTimeout ( delegate : Timeout ) : Timeout","title":"ForwardingTimeout"},{"location":"2.x/okio/okio/-forwarding-timeout/#constructors","text":"Name Summary [jvm] fun (delegate: Timeout )","title":"Constructors"},{"location":"2.x/okio/okio/-forwarding-timeout/#functions","text":"Name Summary clearDeadline [jvm] Brief description Clears the deadline. Content open override fun clearDeadline (): Timeout clearTimeout [jvm] Brief description Clears the timeout. Operating system timeouts may still apply. Content open override fun clearTimeout (): Timeout deadline [jvm] Brief description Set a deadline of now plus duration time. Content override fun deadline (duration: Long , unit: TimeUnit ): Timeout deadlineNanoTime [jvm] Brief description Returns the nano time when the deadline will be reached. Content open override fun deadlineNanoTime (): Long [jvm] Brief description Sets the nano time when the deadline will be reached. All operations must complete before this time. Use a deadline to set a maximum bound on the time spent on a sequence of operations. Content open override fun deadlineNanoTime (deadlineNanoTime: Long ): Timeout equals [jvm] Content open operator override fun equals (other: Any ?): Boolean hasDeadline [jvm] Brief description Returns true if a deadline is enabled. Content open override fun hasDeadline (): Boolean hashCode [jvm] Content open override fun hashCode (): Int intersectWith [jvm] Brief description Applies the minimum intersection between this timeout and other, run block, then finally rollback this timeout\u2019s values. Content inline override fun intersectWith (other: Timeout , block: () -> Unit ) setDelegate [jvm] Content fun setDelegate (delegate: Timeout ): ForwardingTimeout throwIfReached [jvm] Brief description Throws an InterruptedIOException if the deadline has been reached or if the current thread has been interrupted. This method doesn\u2019t detect timeouts; that should be implemented to asynchronously abort an in-progress operation. Content open override fun throwIfReached () timeout [jvm] Brief description Wait at most timeout time before aborting an operation. Using a per-operation timeout means that as long as forward progress is being made, no sequence of operations will fail.If timeout == 0, operations will run indefinitely. (Operating system timeouts may still apply.) Content open override fun timeout (timeout: Long , unit: TimeUnit ): Timeout timeoutNanos [jvm] Brief description Returns the timeout in nanoseconds, or 0 for no timeout. Content open override fun timeoutNanos (): Long toString [jvm] Content open override fun toString (): String waitUntilNotified [jvm] Brief description Waits on monitor until it is notified. Throws InterruptedIOException if either the thread is interrupted or if this timeout elapses before monitor is notified. The caller must be synchronized on monitor.Here\u2019s a sample class that uses waitUntilNotified() to await a specific state. Note that the call is made within a loop to avoid unnecessary waiting and to mitigate spurious notifications.class Dice { Random random = new Random(); int latestTotal; public synchronized void roll() { latestTotal = 2 + random.nextInt(6) + random.nextInt(6); System.out.println(\u201cRolled \u201d + latestTotal); notifyAll(); } public void rollAtFixedRate(int period, TimeUnit timeUnit) { Executors.newScheduledThreadPool(0).scheduleAtFixedRate(new Runnable() { public void run() { roll(); } }, 0, period, timeUnit); } public synchronized void awaitTotal(Timeout timeout, int total) throws InterruptedIOException { while (latestTotal != total) { timeout.waitUntilNotified(this); } } } Content override fun waitUntilNotified (monitor: Any )","title":"Functions"},{"location":"2.x/okio/okio/-forwarding-timeout/#properties","text":"Name Summary deadlineNanoTime [jvm] override var deadlineNanoTime : Long delegate [jvm] var delegate : Timeout hasDeadline [jvm] True if deadlineNanoTime is defined. There is no equivalent to null or 0 for System.nanoTime .override var hasDeadline : Boolean timeoutNanos [jvm] override var timeoutNanos : Long","title":"Properties"},{"location":"2.x/okio/okio/-forwarding-timeout/-init-/","text":"// okio / okio / ForwardingTimeout / \u00b6 [jvm] Content fun (delegate: Timeout )","title":"<init>   - Okio"},{"location":"2.x/okio/okio/-forwarding-timeout/-init-/#_1","text":"[jvm] Content fun (delegate: Timeout )","title":""},{"location":"2.x/okio/okio/-forwarding-timeout/clear-deadline/","text":"// okio / okio / ForwardingTimeout / clearDeadline clearDeadline \u00b6 [jvm] Brief description Clears the deadline. Content open override fun clearDeadline (): Timeout","title":"clearDeadline   - Okio"},{"location":"2.x/okio/okio/-forwarding-timeout/clear-deadline/#cleardeadline","text":"[jvm] Brief description Clears the deadline. Content open override fun clearDeadline (): Timeout","title":"clearDeadline"},{"location":"2.x/okio/okio/-forwarding-timeout/clear-timeout/","text":"// okio / okio / ForwardingTimeout / clearTimeout clearTimeout \u00b6 [jvm] Brief description Clears the timeout. Operating system timeouts may still apply. Content open override fun clearTimeout (): Timeout","title":"clearTimeout   - Okio"},{"location":"2.x/okio/okio/-forwarding-timeout/clear-timeout/#cleartimeout","text":"[jvm] Brief description Clears the timeout. Operating system timeouts may still apply. Content open override fun clearTimeout (): Timeout","title":"clearTimeout"},{"location":"2.x/okio/okio/-forwarding-timeout/deadline-nano-time/","text":"// okio / okio / ForwardingTimeout / deadlineNanoTime deadlineNanoTime \u00b6 [jvm] Brief description Returns the nano time when the deadline will be reached. Content open override fun deadlineNanoTime (): Long [jvm] Brief description Sets the nano time when the deadline will be reached. All operations must complete before this time. Use a deadline to set a maximum bound on the time spent on a sequence of operations. Content open override fun deadlineNanoTime (deadlineNanoTime: Long ): Timeout","title":"deadlineNanoTime   - Okio"},{"location":"2.x/okio/okio/-forwarding-timeout/deadline-nano-time/#deadlinenanotime","text":"[jvm] Brief description Returns the nano time when the deadline will be reached. Content open override fun deadlineNanoTime (): Long [jvm] Brief description Sets the nano time when the deadline will be reached. All operations must complete before this time. Use a deadline to set a maximum bound on the time spent on a sequence of operations. Content open override fun deadlineNanoTime (deadlineNanoTime: Long ): Timeout","title":"deadlineNanoTime"},{"location":"2.x/okio/okio/-forwarding-timeout/has-deadline/","text":"// okio / okio / ForwardingTimeout / hasDeadline hasDeadline \u00b6 [jvm] Brief description Returns true if a deadline is enabled. Content open override fun hasDeadline (): Boolean","title":"hasDeadline   - Okio"},{"location":"2.x/okio/okio/-forwarding-timeout/has-deadline/#hasdeadline","text":"[jvm] Brief description Returns true if a deadline is enabled. Content open override fun hasDeadline (): Boolean","title":"hasDeadline"},{"location":"2.x/okio/okio/-forwarding-timeout/set-delegate/","text":"// okio / okio / ForwardingTimeout / setDelegate setDelegate \u00b6 [jvm] Content fun setDelegate (delegate: Timeout ): ForwardingTimeout","title":"setDelegate   - Okio"},{"location":"2.x/okio/okio/-forwarding-timeout/set-delegate/#setdelegate","text":"[jvm] Content fun setDelegate (delegate: Timeout ): ForwardingTimeout","title":"setDelegate"},{"location":"2.x/okio/okio/-forwarding-timeout/throw-if-reached/","text":"// okio / okio / ForwardingTimeout / throwIfReached throwIfReached \u00b6 [jvm] Brief description Throws an InterruptedIOException if the deadline has been reached or if the current thread has been interrupted. This method doesn\u2019t detect timeouts; that should be implemented to asynchronously abort an in-progress operation. Content open override fun throwIfReached ()","title":"throwIfReached   - Okio"},{"location":"2.x/okio/okio/-forwarding-timeout/throw-if-reached/#throwifreached","text":"[jvm] Brief description Throws an InterruptedIOException if the deadline has been reached or if the current thread has been interrupted. This method doesn\u2019t detect timeouts; that should be implemented to asynchronously abort an in-progress operation. Content open override fun throwIfReached ()","title":"throwIfReached"},{"location":"2.x/okio/okio/-forwarding-timeout/timeout-nanos/","text":"// okio / okio / ForwardingTimeout / timeoutNanos timeoutNanos \u00b6 [jvm] Brief description Returns the timeout in nanoseconds, or 0 for no timeout. Content open override fun timeoutNanos (): Long","title":"timeoutNanos   - Okio"},{"location":"2.x/okio/okio/-forwarding-timeout/timeout-nanos/#timeoutnanos","text":"[jvm] Brief description Returns the timeout in nanoseconds, or 0 for no timeout. Content open override fun timeoutNanos (): Long","title":"timeoutNanos"},{"location":"2.x/okio/okio/-forwarding-timeout/timeout/","text":"// okio / okio / ForwardingTimeout / timeout timeout \u00b6 [jvm] Brief description Wait at most timeout time before aborting an operation. Using a per-operation timeout means that as long as forward progress is being made, no sequence of operations will fail.If timeout == 0, operations will run indefinitely. (Operating system timeouts may still apply.) Content open override fun timeout (timeout: Long , unit: TimeUnit ): Timeout","title":"timeout   - Okio"},{"location":"2.x/okio/okio/-forwarding-timeout/timeout/#timeout","text":"[jvm] Brief description Wait at most timeout time before aborting an operation. Using a per-operation timeout means that as long as forward progress is being made, no sequence of operations will fail.If timeout == 0, operations will run indefinitely. (Operating system timeouts may still apply.) Content open override fun timeout (timeout: Long , unit: TimeUnit ): Timeout","title":"timeout"},{"location":"2.x/okio/okio/-gzip-sink/","text":"// okio / okio / GzipSink GzipSink \u00b6 [jvm] A sink that uses GZIP to compress written data to another sink. Sync flush \u00b6 Aggressive flushing of this stream may result in reduced compression. Each call to flush immediately compresses all currently-buffered data; this early compression may be less effective than compression performed without flushing.This is equivalent to using Deflater with the sync flush option. This class does not offer any partial flush mechanism. For best performance, only call flush when application behavior requires it. class GzipSink ( sink : Sink ) : Sink Constructors \u00b6 Name Summary [jvm] fun (sink: Sink ) Functions \u00b6 Name Summary close [jvm] Content open override fun close () equals [jvm] Content open operator override fun equals (other: Any ?): Boolean flush [jvm] Content open override fun flush () hashCode [jvm] Content open override fun hashCode (): Int timeout [jvm] Content open override fun timeout (): Timeout toString [jvm] Content open override fun toString (): String write [jvm] Content open override fun write (source: Buffer , byteCount: Long ) Properties \u00b6 Name Summary deflater [jvm] The deflater used to compress the body.val deflater : Deflater","title":"GzipSink   - Okio"},{"location":"2.x/okio/okio/-gzip-sink/#gzipsink","text":"[jvm] A sink that uses GZIP to compress written data to another sink.","title":"GzipSink"},{"location":"2.x/okio/okio/-gzip-sink/#sync-flush","text":"Aggressive flushing of this stream may result in reduced compression. Each call to flush immediately compresses all currently-buffered data; this early compression may be less effective than compression performed without flushing.This is equivalent to using Deflater with the sync flush option. This class does not offer any partial flush mechanism. For best performance, only call flush when application behavior requires it. class GzipSink ( sink : Sink ) : Sink","title":"Sync flush"},{"location":"2.x/okio/okio/-gzip-sink/#constructors","text":"Name Summary [jvm] fun (sink: Sink )","title":"Constructors"},{"location":"2.x/okio/okio/-gzip-sink/#functions","text":"Name Summary close [jvm] Content open override fun close () equals [jvm] Content open operator override fun equals (other: Any ?): Boolean flush [jvm] Content open override fun flush () hashCode [jvm] Content open override fun hashCode (): Int timeout [jvm] Content open override fun timeout (): Timeout toString [jvm] Content open override fun toString (): String write [jvm] Content open override fun write (source: Buffer , byteCount: Long )","title":"Functions"},{"location":"2.x/okio/okio/-gzip-sink/#properties","text":"Name Summary deflater [jvm] The deflater used to compress the body.val deflater : Deflater","title":"Properties"},{"location":"2.x/okio/okio/-gzip-sink/-init-/","text":"// okio / okio / GzipSink / \u00b6 [jvm] Content fun (sink: Sink )","title":"<init>   - Okio"},{"location":"2.x/okio/okio/-gzip-sink/-init-/#_1","text":"[jvm] Content fun (sink: Sink )","title":""},{"location":"2.x/okio/okio/-gzip-sink/close/","text":"// okio / okio / GzipSink / close close \u00b6 [jvm] Content open override fun close ()","title":"close   - Okio"},{"location":"2.x/okio/okio/-gzip-sink/close/#close","text":"[jvm] Content open override fun close ()","title":"close"},{"location":"2.x/okio/okio/-gzip-sink/flush/","text":"// okio / okio / GzipSink / flush flush \u00b6 [jvm] Content open override fun flush ()","title":"flush   - Okio"},{"location":"2.x/okio/okio/-gzip-sink/flush/#flush","text":"[jvm] Content open override fun flush ()","title":"flush"},{"location":"2.x/okio/okio/-gzip-sink/timeout/","text":"// okio / okio / GzipSink / timeout timeout \u00b6 [jvm] Content open override fun timeout (): Timeout","title":"timeout   - Okio"},{"location":"2.x/okio/okio/-gzip-sink/timeout/#timeout","text":"[jvm] Content open override fun timeout (): Timeout","title":"timeout"},{"location":"2.x/okio/okio/-gzip-sink/write/","text":"// okio / okio / GzipSink / write write \u00b6 [jvm] Content open override fun write (source: Buffer , byteCount: Long )","title":"write   - Okio"},{"location":"2.x/okio/okio/-gzip-sink/write/#write","text":"[jvm] Content open override fun write (source: Buffer , byteCount: Long )","title":"write"},{"location":"2.x/okio/okio/-gzip-source/","text":"// okio / okio / GzipSource GzipSource \u00b6 [jvm] A source that uses GZIP to decompress data read from another source. class GzipSource ( source : Source ) : Source Constructors \u00b6 Name Summary [jvm] fun (source: Source ) Functions \u00b6 Name Summary close [jvm] Content open override fun close () equals [jvm] Content open operator override fun equals (other: Any ?): Boolean hashCode [jvm] Content open override fun hashCode (): Int read [jvm] Content open override fun read (sink: Buffer , byteCount: Long ): Long timeout [jvm] Content open override fun timeout (): Timeout toString [jvm] Content open override fun toString (): String","title":"GzipSource   - Okio"},{"location":"2.x/okio/okio/-gzip-source/#gzipsource","text":"[jvm] A source that uses GZIP to decompress data read from another source. class GzipSource ( source : Source ) : Source","title":"GzipSource"},{"location":"2.x/okio/okio/-gzip-source/#constructors","text":"Name Summary [jvm] fun (source: Source )","title":"Constructors"},{"location":"2.x/okio/okio/-gzip-source/#functions","text":"Name Summary close [jvm] Content open override fun close () equals [jvm] Content open operator override fun equals (other: Any ?): Boolean hashCode [jvm] Content open override fun hashCode (): Int read [jvm] Content open override fun read (sink: Buffer , byteCount: Long ): Long timeout [jvm] Content open override fun timeout (): Timeout toString [jvm] Content open override fun toString (): String","title":"Functions"},{"location":"2.x/okio/okio/-gzip-source/-init-/","text":"// okio / okio / GzipSource / \u00b6 [jvm] Content fun (source: Source )","title":"<init>   - Okio"},{"location":"2.x/okio/okio/-gzip-source/-init-/#_1","text":"[jvm] Content fun (source: Source )","title":""},{"location":"2.x/okio/okio/-gzip-source/close/","text":"// okio / okio / GzipSource / close close \u00b6 [jvm] Content open override fun close ()","title":"close   - Okio"},{"location":"2.x/okio/okio/-gzip-source/close/#close","text":"[jvm] Content open override fun close ()","title":"close"},{"location":"2.x/okio/okio/-gzip-source/read/","text":"// okio / okio / GzipSource / read read \u00b6 [jvm] Content open override fun read (sink: Buffer , byteCount: Long ): Long","title":"read   - Okio"},{"location":"2.x/okio/okio/-gzip-source/read/#read","text":"[jvm] Content open override fun read (sink: Buffer , byteCount: Long ): Long","title":"read"},{"location":"2.x/okio/okio/-gzip-source/timeout/","text":"// okio / okio / GzipSource / timeout timeout \u00b6 [jvm] Content open override fun timeout (): Timeout","title":"timeout   - Okio"},{"location":"2.x/okio/okio/-gzip-source/timeout/#timeout","text":"[jvm] Content open override fun timeout (): Timeout","title":"timeout"},{"location":"2.x/okio/okio/-hashing-sink/","text":"// okio / okio / HashingSink HashingSink \u00b6 [jvm] A sink that computes a hash of the full stream of bytes it has accepted. To use, create an instance with your preferred hash algorithm. Write all of the data to the sink and then call hash to compute the final hash value.In this example we use HashingSink with a BufferedSink to make writing to the sink easier.HashingSink hashingSink = HashingSink.sha256(s); BufferedSink bufferedSink = Okio.buffer(hashingSink); \u2026 // Write to bufferedSink and either flush or close it. ByteString hash = hashingSink.hash(); class HashingSink : ForwardingSink Types \u00b6 Name Summary Companion [jvm] Content object Companion Functions \u00b6 Name Summary close [jvm] Content open override fun close () equals [jvm] Content open operator override fun equals (other: Any ?): Boolean flush [jvm] Content open override fun flush () hashCode [jvm] Content open override fun hashCode (): Int timeout [jvm] Content open override fun timeout (): Timeout toString [jvm] Content open override fun toString (): String write [jvm] Content open override fun write (source: Buffer , byteCount: Long ) Properties \u00b6 Name Summary delegate [jvm] Sink to which this instance is delegating.override val delegate : Sink hash [jvm] Returns the hash of the bytes accepted thus far and resets the internal state of this sink. This method is not idempotent. Each time this method is called its internal state is cleared. This starts a new hash with zero bytes accepted.val hash : ByteString","title":"HashingSink   - Okio"},{"location":"2.x/okio/okio/-hashing-sink/#hashingsink","text":"[jvm] A sink that computes a hash of the full stream of bytes it has accepted. To use, create an instance with your preferred hash algorithm. Write all of the data to the sink and then call hash to compute the final hash value.In this example we use HashingSink with a BufferedSink to make writing to the sink easier.HashingSink hashingSink = HashingSink.sha256(s); BufferedSink bufferedSink = Okio.buffer(hashingSink); \u2026 // Write to bufferedSink and either flush or close it. ByteString hash = hashingSink.hash(); class HashingSink : ForwardingSink","title":"HashingSink"},{"location":"2.x/okio/okio/-hashing-sink/#types","text":"Name Summary Companion [jvm] Content object Companion","title":"Types"},{"location":"2.x/okio/okio/-hashing-sink/#functions","text":"Name Summary close [jvm] Content open override fun close () equals [jvm] Content open operator override fun equals (other: Any ?): Boolean flush [jvm] Content open override fun flush () hashCode [jvm] Content open override fun hashCode (): Int timeout [jvm] Content open override fun timeout (): Timeout toString [jvm] Content open override fun toString (): String write [jvm] Content open override fun write (source: Buffer , byteCount: Long )","title":"Functions"},{"location":"2.x/okio/okio/-hashing-sink/#properties","text":"Name Summary delegate [jvm] Sink to which this instance is delegating.override val delegate : Sink hash [jvm] Returns the hash of the bytes accepted thus far and resets the internal state of this sink. This method is not idempotent. Each time this method is called its internal state is cleared. This starts a new hash with zero bytes accepted.val hash : ByteString","title":"Properties"},{"location":"2.x/okio/okio/-hashing-sink/write/","text":"// okio / okio / HashingSink / write write \u00b6 [jvm] Content open override fun write (source: Buffer , byteCount: Long )","title":"write   - Okio"},{"location":"2.x/okio/okio/-hashing-sink/write/#write","text":"[jvm] Content open override fun write (source: Buffer , byteCount: Long )","title":"write"},{"location":"2.x/okio/okio/-hashing-sink/-companion/","text":"// okio / okio / HashingSink / Companion Companion \u00b6 [jvm] object Companion Functions \u00b6 Name Summary equals [jvm] Content open operator override fun equals (other: Any ?): Boolean hashCode [jvm] Content open override fun hashCode (): Int hmacSha1 [jvm] Brief description Returns a sink that uses the obsolete SHA-1 HMAC algorithm to produce 160-bit hashes. Content @ JvmStatic () fun hmacSha1 (sink: Sink , key: ByteString ): HashingSink hmacSha256 [jvm] Brief description Returns a sink that uses the SHA-256 HMAC algorithm to produce 256-bit hashes. Content @ JvmStatic () fun hmacSha256 (sink: Sink , key: ByteString ): HashingSink hmacSha512 [jvm] Brief description Returns a sink that uses the SHA-512 HMAC algorithm to produce 512-bit hashes. Content @ JvmStatic () fun hmacSha512 (sink: Sink , key: ByteString ): HashingSink md5 [jvm] Brief description Returns a sink that uses the obsolete MD5 hash algorithm to produce 128-bit hashes. Content @ JvmStatic () fun md5 (sink: Sink ): HashingSink sha1 [jvm] Brief description Returns a sink that uses the obsolete SHA-1 hash algorithm to produce 160-bit hashes. Content @ JvmStatic () fun sha1 (sink: Sink ): HashingSink sha256 [jvm] Brief description Returns a sink that uses the SHA-256 hash algorithm to produce 256-bit hashes. Content @ JvmStatic () fun sha256 (sink: Sink ): HashingSink sha512 [jvm] Brief description Returns a sink that uses the SHA-512 hash algorithm to produce 512-bit hashes. Content @ JvmStatic () fun sha512 (sink: Sink ): HashingSink toString [jvm] Content open override fun toString (): String","title":"Companion   - Okio"},{"location":"2.x/okio/okio/-hashing-sink/-companion/#companion","text":"[jvm] object Companion","title":"Companion"},{"location":"2.x/okio/okio/-hashing-sink/-companion/#functions","text":"Name Summary equals [jvm] Content open operator override fun equals (other: Any ?): Boolean hashCode [jvm] Content open override fun hashCode (): Int hmacSha1 [jvm] Brief description Returns a sink that uses the obsolete SHA-1 HMAC algorithm to produce 160-bit hashes. Content @ JvmStatic () fun hmacSha1 (sink: Sink , key: ByteString ): HashingSink hmacSha256 [jvm] Brief description Returns a sink that uses the SHA-256 HMAC algorithm to produce 256-bit hashes. Content @ JvmStatic () fun hmacSha256 (sink: Sink , key: ByteString ): HashingSink hmacSha512 [jvm] Brief description Returns a sink that uses the SHA-512 HMAC algorithm to produce 512-bit hashes. Content @ JvmStatic () fun hmacSha512 (sink: Sink , key: ByteString ): HashingSink md5 [jvm] Brief description Returns a sink that uses the obsolete MD5 hash algorithm to produce 128-bit hashes. Content @ JvmStatic () fun md5 (sink: Sink ): HashingSink sha1 [jvm] Brief description Returns a sink that uses the obsolete SHA-1 hash algorithm to produce 160-bit hashes. Content @ JvmStatic () fun sha1 (sink: Sink ): HashingSink sha256 [jvm] Brief description Returns a sink that uses the SHA-256 hash algorithm to produce 256-bit hashes. Content @ JvmStatic () fun sha256 (sink: Sink ): HashingSink sha512 [jvm] Brief description Returns a sink that uses the SHA-512 hash algorithm to produce 512-bit hashes. Content @ JvmStatic () fun sha512 (sink: Sink ): HashingSink toString [jvm] Content open override fun toString (): String","title":"Functions"},{"location":"2.x/okio/okio/-hashing-sink/-companion/hmac-sha1/","text":"// okio / okio / HashingSink / Companion / hmacSha1 hmacSha1 \u00b6 [jvm] Brief description Returns a sink that uses the obsolete SHA-1 HMAC algorithm to produce 160-bit hashes. Content @ JvmStatic () fun hmacSha1 (sink: Sink , key: ByteString ): HashingSink","title":"hmacSha1   - Okio"},{"location":"2.x/okio/okio/-hashing-sink/-companion/hmac-sha1/#hmacsha1","text":"[jvm] Brief description Returns a sink that uses the obsolete SHA-1 HMAC algorithm to produce 160-bit hashes. Content @ JvmStatic () fun hmacSha1 (sink: Sink , key: ByteString ): HashingSink","title":"hmacSha1"},{"location":"2.x/okio/okio/-hashing-sink/-companion/hmac-sha256/","text":"// okio / okio / HashingSink / Companion / hmacSha256 hmacSha256 \u00b6 [jvm] Brief description Returns a sink that uses the SHA-256 HMAC algorithm to produce 256-bit hashes. Content @ JvmStatic () fun hmacSha256 (sink: Sink , key: ByteString ): HashingSink","title":"hmacSha256   - Okio"},{"location":"2.x/okio/okio/-hashing-sink/-companion/hmac-sha256/#hmacsha256","text":"[jvm] Brief description Returns a sink that uses the SHA-256 HMAC algorithm to produce 256-bit hashes. Content @ JvmStatic () fun hmacSha256 (sink: Sink , key: ByteString ): HashingSink","title":"hmacSha256"},{"location":"2.x/okio/okio/-hashing-sink/-companion/hmac-sha512/","text":"// okio / okio / HashingSink / Companion / hmacSha512 hmacSha512 \u00b6 [jvm] Brief description Returns a sink that uses the SHA-512 HMAC algorithm to produce 512-bit hashes. Content @ JvmStatic () fun hmacSha512 (sink: Sink , key: ByteString ): HashingSink","title":"hmacSha512   - Okio"},{"location":"2.x/okio/okio/-hashing-sink/-companion/hmac-sha512/#hmacsha512","text":"[jvm] Brief description Returns a sink that uses the SHA-512 HMAC algorithm to produce 512-bit hashes. Content @ JvmStatic () fun hmacSha512 (sink: Sink , key: ByteString ): HashingSink","title":"hmacSha512"},{"location":"2.x/okio/okio/-hashing-sink/-companion/md5/","text":"// okio / okio / HashingSink / Companion / md5 md5 \u00b6 [jvm] Brief description Returns a sink that uses the obsolete MD5 hash algorithm to produce 128-bit hashes. Content @ JvmStatic () fun md5 (sink: Sink ): HashingSink","title":"md5   - Okio"},{"location":"2.x/okio/okio/-hashing-sink/-companion/md5/#md5","text":"[jvm] Brief description Returns a sink that uses the obsolete MD5 hash algorithm to produce 128-bit hashes. Content @ JvmStatic () fun md5 (sink: Sink ): HashingSink","title":"md5"},{"location":"2.x/okio/okio/-hashing-sink/-companion/sha1/","text":"// okio / okio / HashingSink / Companion / sha1 sha1 \u00b6 [jvm] Brief description Returns a sink that uses the obsolete SHA-1 hash algorithm to produce 160-bit hashes. Content @ JvmStatic () fun sha1 (sink: Sink ): HashingSink","title":"sha1   - Okio"},{"location":"2.x/okio/okio/-hashing-sink/-companion/sha1/#sha1","text":"[jvm] Brief description Returns a sink that uses the obsolete SHA-1 hash algorithm to produce 160-bit hashes. Content @ JvmStatic () fun sha1 (sink: Sink ): HashingSink","title":"sha1"},{"location":"2.x/okio/okio/-hashing-sink/-companion/sha256/","text":"// okio / okio / HashingSink / Companion / sha256 sha256 \u00b6 [jvm] Brief description Returns a sink that uses the SHA-256 hash algorithm to produce 256-bit hashes. Content @ JvmStatic () fun sha256 (sink: Sink ): HashingSink","title":"sha256   - Okio"},{"location":"2.x/okio/okio/-hashing-sink/-companion/sha256/#sha256","text":"[jvm] Brief description Returns a sink that uses the SHA-256 hash algorithm to produce 256-bit hashes. Content @ JvmStatic () fun sha256 (sink: Sink ): HashingSink","title":"sha256"},{"location":"2.x/okio/okio/-hashing-sink/-companion/sha512/","text":"// okio / okio / HashingSink / Companion / sha512 sha512 \u00b6 [jvm] Brief description Returns a sink that uses the SHA-512 hash algorithm to produce 512-bit hashes. Content @ JvmStatic () fun sha512 (sink: Sink ): HashingSink","title":"sha512   - Okio"},{"location":"2.x/okio/okio/-hashing-sink/-companion/sha512/#sha512","text":"[jvm] Brief description Returns a sink that uses the SHA-512 hash algorithm to produce 512-bit hashes. Content @ JvmStatic () fun sha512 (sink: Sink ): HashingSink","title":"sha512"},{"location":"2.x/okio/okio/-hashing-source/","text":"// okio / okio / HashingSource HashingSource \u00b6 [jvm] A source that computes a hash of the full stream of bytes it has supplied. To use, create an instance with your preferred hash algorithm. Exhaust the source by reading all of its bytes and then call hash to compute the final hash value.In this example we use HashingSource with a BufferedSource to make reading from the source easier.HashingSource hashingSource = HashingSource.sha256(rawSource); BufferedSource bufferedSource = Okio.buffer(hashingSource); \u2026 // Read all of bufferedSource. ByteString hash = hashingSource.hash(); class HashingSource : ForwardingSource Types \u00b6 Name Summary Companion [jvm] Content object Companion Functions \u00b6 Name Summary close [jvm] Content open override fun close () equals [jvm] Content open operator override fun equals (other: Any ?): Boolean hashCode [jvm] Content open override fun hashCode (): Int read [jvm] Content open override fun read (sink: Buffer , byteCount: Long ): Long timeout [jvm] Content open override fun timeout (): Timeout toString [jvm] Content open override fun toString (): String Properties \u00b6 Name Summary delegate [jvm] Source to which this instance is delegating.override val delegate : Source hash [jvm] Returns the hash of the bytes supplied thus far and resets the internal state of this source. This method is not idempotent. Each time this method is called its internal state is cleared. This starts a new hash with zero bytes supplied.val hash : ByteString","title":"HashingSource   - Okio"},{"location":"2.x/okio/okio/-hashing-source/#hashingsource","text":"[jvm] A source that computes a hash of the full stream of bytes it has supplied. To use, create an instance with your preferred hash algorithm. Exhaust the source by reading all of its bytes and then call hash to compute the final hash value.In this example we use HashingSource with a BufferedSource to make reading from the source easier.HashingSource hashingSource = HashingSource.sha256(rawSource); BufferedSource bufferedSource = Okio.buffer(hashingSource); \u2026 // Read all of bufferedSource. ByteString hash = hashingSource.hash(); class HashingSource : ForwardingSource","title":"HashingSource"},{"location":"2.x/okio/okio/-hashing-source/#types","text":"Name Summary Companion [jvm] Content object Companion","title":"Types"},{"location":"2.x/okio/okio/-hashing-source/#functions","text":"Name Summary close [jvm] Content open override fun close () equals [jvm] Content open operator override fun equals (other: Any ?): Boolean hashCode [jvm] Content open override fun hashCode (): Int read [jvm] Content open override fun read (sink: Buffer , byteCount: Long ): Long timeout [jvm] Content open override fun timeout (): Timeout toString [jvm] Content open override fun toString (): String","title":"Functions"},{"location":"2.x/okio/okio/-hashing-source/#properties","text":"Name Summary delegate [jvm] Source to which this instance is delegating.override val delegate : Source hash [jvm] Returns the hash of the bytes supplied thus far and resets the internal state of this source. This method is not idempotent. Each time this method is called its internal state is cleared. This starts a new hash with zero bytes supplied.val hash : ByteString","title":"Properties"},{"location":"2.x/okio/okio/-hashing-source/read/","text":"// okio / okio / HashingSource / read read \u00b6 [jvm] Content open override fun read (sink: Buffer , byteCount: Long ): Long","title":"read   - Okio"},{"location":"2.x/okio/okio/-hashing-source/read/#read","text":"[jvm] Content open override fun read (sink: Buffer , byteCount: Long ): Long","title":"read"},{"location":"2.x/okio/okio/-hashing-source/-companion/","text":"// okio / okio / HashingSource / Companion Companion \u00b6 [jvm] object Companion Functions \u00b6 Name Summary equals [jvm] Content open operator override fun equals (other: Any ?): Boolean hashCode [jvm] Content open override fun hashCode (): Int hmacSha1 [jvm] Brief description Returns a sink that uses the obsolete SHA-1 HMAC algorithm to produce 160-bit hashes. Content @ JvmStatic () fun hmacSha1 (source: Source , key: ByteString ): HashingSource hmacSha256 [jvm] Brief description Returns a sink that uses the SHA-256 HMAC algorithm to produce 256-bit hashes. Content @ JvmStatic () fun hmacSha256 (source: Source , key: ByteString ): HashingSource hmacSha512 [jvm] Brief description Returns a sink that uses the SHA-512 HMAC algorithm to produce 512-bit hashes. Content @ JvmStatic () fun hmacSha512 (source: Source , key: ByteString ): HashingSource md5 [jvm] Brief description Returns a sink that uses the obsolete MD5 hash algorithm to produce 128-bit hashes. Content @ JvmStatic () fun md5 (source: Source ): HashingSource sha1 [jvm] Brief description Returns a sink that uses the obsolete SHA-1 hash algorithm to produce 160-bit hashes. Content @ JvmStatic () fun sha1 (source: Source ): HashingSource sha256 [jvm] Brief description Returns a sink that uses the SHA-256 hash algorithm to produce 256-bit hashes. Content @ JvmStatic () fun sha256 (source: Source ): HashingSource sha512 [jvm] Brief description Returns a sink that uses the SHA-512 hash algorithm to produce 512-bit hashes. Content @ JvmStatic () fun sha512 (source: Source ): HashingSource toString [jvm] Content open override fun toString (): String","title":"Companion   - Okio"},{"location":"2.x/okio/okio/-hashing-source/-companion/#companion","text":"[jvm] object Companion","title":"Companion"},{"location":"2.x/okio/okio/-hashing-source/-companion/#functions","text":"Name Summary equals [jvm] Content open operator override fun equals (other: Any ?): Boolean hashCode [jvm] Content open override fun hashCode (): Int hmacSha1 [jvm] Brief description Returns a sink that uses the obsolete SHA-1 HMAC algorithm to produce 160-bit hashes. Content @ JvmStatic () fun hmacSha1 (source: Source , key: ByteString ): HashingSource hmacSha256 [jvm] Brief description Returns a sink that uses the SHA-256 HMAC algorithm to produce 256-bit hashes. Content @ JvmStatic () fun hmacSha256 (source: Source , key: ByteString ): HashingSource hmacSha512 [jvm] Brief description Returns a sink that uses the SHA-512 HMAC algorithm to produce 512-bit hashes. Content @ JvmStatic () fun hmacSha512 (source: Source , key: ByteString ): HashingSource md5 [jvm] Brief description Returns a sink that uses the obsolete MD5 hash algorithm to produce 128-bit hashes. Content @ JvmStatic () fun md5 (source: Source ): HashingSource sha1 [jvm] Brief description Returns a sink that uses the obsolete SHA-1 hash algorithm to produce 160-bit hashes. Content @ JvmStatic () fun sha1 (source: Source ): HashingSource sha256 [jvm] Brief description Returns a sink that uses the SHA-256 hash algorithm to produce 256-bit hashes. Content @ JvmStatic () fun sha256 (source: Source ): HashingSource sha512 [jvm] Brief description Returns a sink that uses the SHA-512 hash algorithm to produce 512-bit hashes. Content @ JvmStatic () fun sha512 (source: Source ): HashingSource toString [jvm] Content open override fun toString (): String","title":"Functions"},{"location":"2.x/okio/okio/-hashing-source/-companion/hmac-sha1/","text":"// okio / okio / HashingSource / Companion / hmacSha1 hmacSha1 \u00b6 [jvm] Brief description Returns a sink that uses the obsolete SHA-1 HMAC algorithm to produce 160-bit hashes. Content @ JvmStatic () fun hmacSha1 (source: Source , key: ByteString ): HashingSource","title":"hmacSha1   - Okio"},{"location":"2.x/okio/okio/-hashing-source/-companion/hmac-sha1/#hmacsha1","text":"[jvm] Brief description Returns a sink that uses the obsolete SHA-1 HMAC algorithm to produce 160-bit hashes. Content @ JvmStatic () fun hmacSha1 (source: Source , key: ByteString ): HashingSource","title":"hmacSha1"},{"location":"2.x/okio/okio/-hashing-source/-companion/hmac-sha256/","text":"// okio / okio / HashingSource / Companion / hmacSha256 hmacSha256 \u00b6 [jvm] Brief description Returns a sink that uses the SHA-256 HMAC algorithm to produce 256-bit hashes. Content @ JvmStatic () fun hmacSha256 (source: Source , key: ByteString ): HashingSource","title":"hmacSha256   - Okio"},{"location":"2.x/okio/okio/-hashing-source/-companion/hmac-sha256/#hmacsha256","text":"[jvm] Brief description Returns a sink that uses the SHA-256 HMAC algorithm to produce 256-bit hashes. Content @ JvmStatic () fun hmacSha256 (source: Source , key: ByteString ): HashingSource","title":"hmacSha256"},{"location":"2.x/okio/okio/-hashing-source/-companion/hmac-sha512/","text":"// okio / okio / HashingSource / Companion / hmacSha512 hmacSha512 \u00b6 [jvm] Brief description Returns a sink that uses the SHA-512 HMAC algorithm to produce 512-bit hashes. Content @ JvmStatic () fun hmacSha512 (source: Source , key: ByteString ): HashingSource","title":"hmacSha512   - Okio"},{"location":"2.x/okio/okio/-hashing-source/-companion/hmac-sha512/#hmacsha512","text":"[jvm] Brief description Returns a sink that uses the SHA-512 HMAC algorithm to produce 512-bit hashes. Content @ JvmStatic () fun hmacSha512 (source: Source , key: ByteString ): HashingSource","title":"hmacSha512"},{"location":"2.x/okio/okio/-hashing-source/-companion/md5/","text":"// okio / okio / HashingSource / Companion / md5 md5 \u00b6 [jvm] Brief description Returns a sink that uses the obsolete MD5 hash algorithm to produce 128-bit hashes. Content @ JvmStatic () fun md5 (source: Source ): HashingSource","title":"md5   - Okio"},{"location":"2.x/okio/okio/-hashing-source/-companion/md5/#md5","text":"[jvm] Brief description Returns a sink that uses the obsolete MD5 hash algorithm to produce 128-bit hashes. Content @ JvmStatic () fun md5 (source: Source ): HashingSource","title":"md5"},{"location":"2.x/okio/okio/-hashing-source/-companion/sha1/","text":"// okio / okio / HashingSource / Companion / sha1 sha1 \u00b6 [jvm] Brief description Returns a sink that uses the obsolete SHA-1 hash algorithm to produce 160-bit hashes. Content @ JvmStatic () fun sha1 (source: Source ): HashingSource","title":"sha1   - Okio"},{"location":"2.x/okio/okio/-hashing-source/-companion/sha1/#sha1","text":"[jvm] Brief description Returns a sink that uses the obsolete SHA-1 hash algorithm to produce 160-bit hashes. Content @ JvmStatic () fun sha1 (source: Source ): HashingSource","title":"sha1"},{"location":"2.x/okio/okio/-hashing-source/-companion/sha256/","text":"// okio / okio / HashingSource / Companion / sha256 sha256 \u00b6 [jvm] Brief description Returns a sink that uses the SHA-256 hash algorithm to produce 256-bit hashes. Content @ JvmStatic () fun sha256 (source: Source ): HashingSource","title":"sha256   - Okio"},{"location":"2.x/okio/okio/-hashing-source/-companion/sha256/#sha256","text":"[jvm] Brief description Returns a sink that uses the SHA-256 hash algorithm to produce 256-bit hashes. Content @ JvmStatic () fun sha256 (source: Source ): HashingSource","title":"sha256"},{"location":"2.x/okio/okio/-hashing-source/-companion/sha512/","text":"// okio / okio / HashingSource / Companion / sha512 sha512 \u00b6 [jvm] Brief description Returns a sink that uses the SHA-512 hash algorithm to produce 512-bit hashes. Content @ JvmStatic () fun sha512 (source: Source ): HashingSource","title":"sha512   - Okio"},{"location":"2.x/okio/okio/-hashing-source/-companion/sha512/#sha512","text":"[jvm] Brief description Returns a sink that uses the SHA-512 hash algorithm to produce 512-bit hashes. Content @ JvmStatic () fun sha512 (source: Source ): HashingSource","title":"sha512"},{"location":"2.x/okio/okio/-i-o-exception/","text":"// okio / okio / IOException IOException \u00b6 [js] open class IOException ( message : String ?) : Exception [native] open class IOException ( message : String ?) Functions \u00b6 Name Summary equals [js, native] Content [js, native] open operator override fun equals (other: Any ?): Boolean hashCode [js, native] Content [js, native] open override fun hashCode (): Int toString [js, native] Content [js, native] open override fun toString (): String Properties \u00b6 Name Summary cause [js] open override val cause : Throwable ? message [js] open override val message : String ? Inheritors \u00b6 Name EOFException","title":"IOException   - Okio"},{"location":"2.x/okio/okio/-i-o-exception/#ioexception","text":"[js] open class IOException ( message : String ?) : Exception [native] open class IOException ( message : String ?)","title":"IOException"},{"location":"2.x/okio/okio/-i-o-exception/#functions","text":"Name Summary equals [js, native] Content [js, native] open operator override fun equals (other: Any ?): Boolean hashCode [js, native] Content [js, native] open override fun hashCode (): Int toString [js, native] Content [js, native] open override fun toString (): String","title":"Functions"},{"location":"2.x/okio/okio/-i-o-exception/#properties","text":"Name Summary cause [js] open override val cause : Throwable ? message [js] open override val message : String ?","title":"Properties"},{"location":"2.x/okio/okio/-i-o-exception/#inheritors","text":"Name EOFException","title":"Inheritors"},{"location":"2.x/okio/okio/-i-o-exception/-init-/","text":"// okio / okio / IOException / \u00b6 [js, native] Content [js, native] fun (message: String ?)","title":"<init>   - Okio"},{"location":"2.x/okio/okio/-i-o-exception/-init-/#_1","text":"[js, native] Content [js, native] fun (message: String ?)","title":""},{"location":"2.x/okio/okio/-inflater-source/","text":"// okio / okio / InflaterSource InflaterSource \u00b6 [jvm] A source that uses DEFLATE to decompress data read from another source. class InflaterSource : Source Constructors \u00b6 Name Summary [jvm] fun (source: Source , inflater: Inflater ) Functions \u00b6 Name Summary close [jvm] Content open override fun close () equals [jvm] Content open operator override fun equals (other: Any ?): Boolean hashCode [jvm] Content open override fun hashCode (): Int read [jvm] Content open override fun read (sink: Buffer , byteCount: Long ): Long readOrInflate [jvm] Brief description Consume deflated bytes from the underlying source, and write any inflated bytes to sink . Returns the number of inflated bytes written to sink . This may return 0L, though it will always consume 1 or more bytes from the underlying source if it is not exhausted.Use this instead of read when it is useful to consume the deflated stream even when doing so doesn\u2019t yield inflated bytes. Content fun readOrInflate (sink: Buffer , byteCount: Long ): Long refill [jvm] Brief description Refills the inflater with compressed data if it needs input. (And only if it needs input). Returns true if the inflater required input but the source was exhausted. Content fun refill (): Boolean timeout [jvm] Content open override fun timeout (): Timeout toString [jvm] Content open override fun toString (): String","title":"InflaterSource   - Okio"},{"location":"2.x/okio/okio/-inflater-source/#inflatersource","text":"[jvm] A source that uses DEFLATE to decompress data read from another source. class InflaterSource : Source","title":"InflaterSource"},{"location":"2.x/okio/okio/-inflater-source/#constructors","text":"Name Summary [jvm] fun (source: Source , inflater: Inflater )","title":"Constructors"},{"location":"2.x/okio/okio/-inflater-source/#functions","text":"Name Summary close [jvm] Content open override fun close () equals [jvm] Content open operator override fun equals (other: Any ?): Boolean hashCode [jvm] Content open override fun hashCode (): Int read [jvm] Content open override fun read (sink: Buffer , byteCount: Long ): Long readOrInflate [jvm] Brief description Consume deflated bytes from the underlying source, and write any inflated bytes to sink . Returns the number of inflated bytes written to sink . This may return 0L, though it will always consume 1 or more bytes from the underlying source if it is not exhausted.Use this instead of read when it is useful to consume the deflated stream even when doing so doesn\u2019t yield inflated bytes. Content fun readOrInflate (sink: Buffer , byteCount: Long ): Long refill [jvm] Brief description Refills the inflater with compressed data if it needs input. (And only if it needs input). Returns true if the inflater required input but the source was exhausted. Content fun refill (): Boolean timeout [jvm] Content open override fun timeout (): Timeout toString [jvm] Content open override fun toString (): String","title":"Functions"},{"location":"2.x/okio/okio/-inflater-source/-init-/","text":"// okio / okio / InflaterSource / \u00b6 [jvm] Content fun (source: Source , inflater: Inflater )","title":"<init>   - Okio"},{"location":"2.x/okio/okio/-inflater-source/-init-/#_1","text":"[jvm] Content fun (source: Source , inflater: Inflater )","title":""},{"location":"2.x/okio/okio/-inflater-source/close/","text":"// okio / okio / InflaterSource / close close \u00b6 [jvm] Content open override fun close ()","title":"close   - Okio"},{"location":"2.x/okio/okio/-inflater-source/close/#close","text":"[jvm] Content open override fun close ()","title":"close"},{"location":"2.x/okio/okio/-inflater-source/read-or-inflate/","text":"// okio / okio / InflaterSource / readOrInflate readOrInflate \u00b6 [jvm] Brief description Consume deflated bytes from the underlying source, and write any inflated bytes to sink . Returns the number of inflated bytes written to sink . This may return 0L, though it will always consume 1 or more bytes from the underlying source if it is not exhausted.Use this instead of read when it is useful to consume the deflated stream even when doing so doesn\u2019t yield inflated bytes. Content fun readOrInflate (sink: Buffer , byteCount: Long ): Long","title":"readOrInflate   - Okio"},{"location":"2.x/okio/okio/-inflater-source/read-or-inflate/#readorinflate","text":"[jvm] Brief description Consume deflated bytes from the underlying source, and write any inflated bytes to sink . Returns the number of inflated bytes written to sink . This may return 0L, though it will always consume 1 or more bytes from the underlying source if it is not exhausted.Use this instead of read when it is useful to consume the deflated stream even when doing so doesn\u2019t yield inflated bytes. Content fun readOrInflate (sink: Buffer , byteCount: Long ): Long","title":"readOrInflate"},{"location":"2.x/okio/okio/-inflater-source/read/","text":"// okio / okio / InflaterSource / read read \u00b6 [jvm] Content open override fun read (sink: Buffer , byteCount: Long ): Long","title":"read   - Okio"},{"location":"2.x/okio/okio/-inflater-source/read/#read","text":"[jvm] Content open override fun read (sink: Buffer , byteCount: Long ): Long","title":"read"},{"location":"2.x/okio/okio/-inflater-source/refill/","text":"// okio / okio / InflaterSource / refill refill \u00b6 [jvm] Brief description Refills the inflater with compressed data if it needs input. (And only if it needs input). Returns true if the inflater required input but the source was exhausted. Content fun refill (): Boolean","title":"refill   - Okio"},{"location":"2.x/okio/okio/-inflater-source/refill/#refill","text":"[jvm] Brief description Refills the inflater with compressed data if it needs input. (And only if it needs input). Returns true if the inflater required input but the source was exhausted. Content fun refill (): Boolean","title":"refill"},{"location":"2.x/okio/okio/-inflater-source/timeout/","text":"// okio / okio / InflaterSource / timeout timeout \u00b6 [jvm] Content open override fun timeout (): Timeout","title":"timeout   - Okio"},{"location":"2.x/okio/okio/-inflater-source/timeout/#timeout","text":"[jvm] Content open override fun timeout (): Timeout","title":"timeout"},{"location":"2.x/okio/okio/-pipe/","text":"// okio / okio / Pipe Pipe \u00b6 [jvm] A source and a sink that are attached. The sink\u2019s output is the source\u2019s input. Typically each is accessed by its own thread: a producer thread writes data to the sink and a consumer thread reads data from the source.This class uses a buffer to decouple source and sink. This buffer has a user-specified maximum size. When a producer thread outruns its consumer the buffer fills up and eventually writes to the sink will block until the consumer has caught up. Symmetrically, if a consumer outruns its producer reads block until there is data to be read. Limits on the amount of time spent waiting for the other party can be configured with timeouts on the source and the sink.When the sink is closed, source reads will continue to complete normally until the buffer has been exhausted. At that point reads will return -1, indicating the end of the stream. But if the source is closed first, writes to the sink will immediately fail with an IOException .A pipe may be canceled to immediately fail writes to the sink and reads from the source. class Pipe ( maxBufferSize : Long ) Constructors \u00b6 Name Summary [jvm] fun (maxBufferSize: Long ) Functions \u00b6 Name Summary cancel [jvm] Brief description Fail any in-flight and future operations. After canceling: Any attempt to write or flush sink will fail immediately with an IOException . Any attempt to read source will fail immediately with an IOException . Any attempt to fold will fail immediately with an IOException . Closing the source and the sink will complete normally even after a pipe has been canceled. If this sink has been folded, closing it will close the folded sink. This operation may block.This operation may be called by any thread at any time. It is safe to call concurrently while operating on the source or the sink. Content fun cancel () equals [jvm] Content open operator override fun equals (other: Any ?): Boolean fold [jvm] Brief description Writes any buffered contents of this pipe to sink, then replace this pipe\u2019s source with sink. This pipe\u2019s source is closed and attempts to read it will throw an IllegalStateException .This method must not be called while concurrently accessing this pipe\u2019s source. It is safe, however, to call this while concurrently writing this pipe\u2019s sink. Content fun fold (sink: Sink ) hashCode [jvm] Content open override fun hashCode (): Int toString [jvm] Content open override fun toString (): String Properties \u00b6 Name Summary sink [jvm] val sink : Sink source [jvm] val source : Source","title":"Pipe   - Okio"},{"location":"2.x/okio/okio/-pipe/#pipe","text":"[jvm] A source and a sink that are attached. The sink\u2019s output is the source\u2019s input. Typically each is accessed by its own thread: a producer thread writes data to the sink and a consumer thread reads data from the source.This class uses a buffer to decouple source and sink. This buffer has a user-specified maximum size. When a producer thread outruns its consumer the buffer fills up and eventually writes to the sink will block until the consumer has caught up. Symmetrically, if a consumer outruns its producer reads block until there is data to be read. Limits on the amount of time spent waiting for the other party can be configured with timeouts on the source and the sink.When the sink is closed, source reads will continue to complete normally until the buffer has been exhausted. At that point reads will return -1, indicating the end of the stream. But if the source is closed first, writes to the sink will immediately fail with an IOException .A pipe may be canceled to immediately fail writes to the sink and reads from the source. class Pipe ( maxBufferSize : Long )","title":"Pipe"},{"location":"2.x/okio/okio/-pipe/#constructors","text":"Name Summary [jvm] fun (maxBufferSize: Long )","title":"Constructors"},{"location":"2.x/okio/okio/-pipe/#functions","text":"Name Summary cancel [jvm] Brief description Fail any in-flight and future operations. After canceling: Any attempt to write or flush sink will fail immediately with an IOException . Any attempt to read source will fail immediately with an IOException . Any attempt to fold will fail immediately with an IOException . Closing the source and the sink will complete normally even after a pipe has been canceled. If this sink has been folded, closing it will close the folded sink. This operation may block.This operation may be called by any thread at any time. It is safe to call concurrently while operating on the source or the sink. Content fun cancel () equals [jvm] Content open operator override fun equals (other: Any ?): Boolean fold [jvm] Brief description Writes any buffered contents of this pipe to sink, then replace this pipe\u2019s source with sink. This pipe\u2019s source is closed and attempts to read it will throw an IllegalStateException .This method must not be called while concurrently accessing this pipe\u2019s source. It is safe, however, to call this while concurrently writing this pipe\u2019s sink. Content fun fold (sink: Sink ) hashCode [jvm] Content open override fun hashCode (): Int toString [jvm] Content open override fun toString (): String","title":"Functions"},{"location":"2.x/okio/okio/-pipe/#properties","text":"Name Summary sink [jvm] val sink : Sink source [jvm] val source : Source","title":"Properties"},{"location":"2.x/okio/okio/-pipe/-init-/","text":"// okio / okio / Pipe / \u00b6 [jvm] Content fun (maxBufferSize: Long )","title":"<init>   - Okio"},{"location":"2.x/okio/okio/-pipe/-init-/#_1","text":"[jvm] Content fun (maxBufferSize: Long )","title":""},{"location":"2.x/okio/okio/-pipe/cancel/","text":"// okio / okio / Pipe / cancel cancel \u00b6 [jvm] Brief description Fail any in-flight and future operations. After canceling: Any attempt to write or flush sink will fail immediately with an IOException . Any attempt to read source will fail immediately with an IOException . Any attempt to fold will fail immediately with an IOException . Closing the source and the sink will complete normally even after a pipe has been canceled. If this sink has been folded, closing it will close the folded sink. This operation may block.This operation may be called by any thread at any time. It is safe to call concurrently while operating on the source or the sink. Content fun cancel ()","title":"cancel   - Okio"},{"location":"2.x/okio/okio/-pipe/cancel/#cancel","text":"[jvm] Brief description Fail any in-flight and future operations. After canceling: Any attempt to write or flush sink will fail immediately with an IOException . Any attempt to read source will fail immediately with an IOException . Any attempt to fold will fail immediately with an IOException . Closing the source and the sink will complete normally even after a pipe has been canceled. If this sink has been folded, closing it will close the folded sink. This operation may block.This operation may be called by any thread at any time. It is safe to call concurrently while operating on the source or the sink. Content fun cancel ()","title":"cancel"},{"location":"2.x/okio/okio/-pipe/fold/","text":"// okio / okio / Pipe / fold fold \u00b6 [jvm] Brief description Writes any buffered contents of this pipe to sink, then replace this pipe\u2019s source with sink. This pipe\u2019s source is closed and attempts to read it will throw an IllegalStateException .This method must not be called while concurrently accessing this pipe\u2019s source. It is safe, however, to call this while concurrently writing this pipe\u2019s sink. Content fun fold (sink: Sink )","title":"fold   - Okio"},{"location":"2.x/okio/okio/-pipe/fold/#fold","text":"[jvm] Brief description Writes any buffered contents of this pipe to sink, then replace this pipe\u2019s source with sink. This pipe\u2019s source is closed and attempts to read it will throw an IllegalStateException .This method must not be called while concurrently accessing this pipe\u2019s source. It is safe, however, to call this while concurrently writing this pipe\u2019s sink. Content fun fold (sink: Sink )","title":"fold"},{"location":"2.x/okio/okio/-sink/","text":"// okio / okio / Sink Sink \u00b6 [js, native] interface Sink [jvm] interface Sink : Closeable , Flushable Functions \u00b6 Name Summary close [js, jvm, native] Content [js, native] abstract fun close () [jvm] abstract override fun close () equals [js, jvm, native] Content [js, jvm, native] open operator override fun equals (other: Any ?): Boolean flush [js, jvm, native] Content [js, native] abstract fun flush () [jvm] abstract override fun flush () hashCode [js, jvm, native] Content [js, jvm, native] open override fun hashCode (): Int timeout [js, jvm, native] Content [js, jvm, native] abstract fun timeout (): Timeout toString [js, jvm, native] Content [js, jvm, native] open override fun toString (): String write [js, jvm, native] Content [js, jvm, native] abstract fun write (source: Buffer , byteCount: Long ) Inheritors \u00b6 Name BufferedSink DeflaterSink ForwardingSink GzipSink Extensions \u00b6 Name Summary deflate [jvm] Brief description Returns an DeflaterSink that DEFLATE-compresses data to this Sink while writing. Content inline fun Sink . deflate (deflater: Deflater ): DeflaterSink gzip [jvm] Brief description Returns a GzipSink that gzip-compresses to this Sink while writing. Content inline fun Sink . gzip (): GzipSink","title":"Sink   - Okio"},{"location":"2.x/okio/okio/-sink/#sink","text":"[js, native] interface Sink [jvm] interface Sink : Closeable , Flushable","title":"Sink"},{"location":"2.x/okio/okio/-sink/#functions","text":"Name Summary close [js, jvm, native] Content [js, native] abstract fun close () [jvm] abstract override fun close () equals [js, jvm, native] Content [js, jvm, native] open operator override fun equals (other: Any ?): Boolean flush [js, jvm, native] Content [js, native] abstract fun flush () [jvm] abstract override fun flush () hashCode [js, jvm, native] Content [js, jvm, native] open override fun hashCode (): Int timeout [js, jvm, native] Content [js, jvm, native] abstract fun timeout (): Timeout toString [js, jvm, native] Content [js, jvm, native] open override fun toString (): String write [js, jvm, native] Content [js, jvm, native] abstract fun write (source: Buffer , byteCount: Long )","title":"Functions"},{"location":"2.x/okio/okio/-sink/#inheritors","text":"Name BufferedSink DeflaterSink ForwardingSink GzipSink","title":"Inheritors"},{"location":"2.x/okio/okio/-sink/#extensions","text":"Name Summary deflate [jvm] Brief description Returns an DeflaterSink that DEFLATE-compresses data to this Sink while writing. Content inline fun Sink . deflate (deflater: Deflater ): DeflaterSink gzip [jvm] Brief description Returns a GzipSink that gzip-compresses to this Sink while writing. Content inline fun Sink . gzip (): GzipSink","title":"Extensions"},{"location":"2.x/okio/okio/-sink/close/","text":"// okio / okio / Sink / close close \u00b6 [js, jvm, native] Content [js, native] abstract fun close () [jvm] abstract override fun close ()","title":"close   - Okio"},{"location":"2.x/okio/okio/-sink/close/#close","text":"[js, jvm, native] Content [js, native] abstract fun close () [jvm] abstract override fun close ()","title":"close"},{"location":"2.x/okio/okio/-sink/flush/","text":"// okio / okio / Sink / flush flush \u00b6 [js, jvm, native] Content [js, native] abstract fun flush () [jvm] abstract override fun flush ()","title":"flush   - Okio"},{"location":"2.x/okio/okio/-sink/flush/#flush","text":"[js, jvm, native] Content [js, native] abstract fun flush () [jvm] abstract override fun flush ()","title":"flush"},{"location":"2.x/okio/okio/-sink/timeout/","text":"// okio / okio / Sink / timeout timeout \u00b6 [js, jvm, native] Content [js, jvm, native] abstract fun timeout (): Timeout","title":"timeout   - Okio"},{"location":"2.x/okio/okio/-sink/timeout/#timeout","text":"[js, jvm, native] Content [js, jvm, native] abstract fun timeout (): Timeout","title":"timeout"},{"location":"2.x/okio/okio/-sink/write/","text":"// okio / okio / Sink / write write \u00b6 [js, jvm, native] Content [js, jvm, native] abstract fun write (source: Buffer , byteCount: Long )","title":"write   - Okio"},{"location":"2.x/okio/okio/-sink/write/#write","text":"[js, jvm, native] Content [js, jvm, native] abstract fun write (source: Buffer , byteCount: Long )","title":"write"},{"location":"2.x/okio/okio/-source/","text":"// okio / okio / Source Source \u00b6 [js, native] interface Source [jvm] interface Source : Closeable Functions \u00b6 Name Summary close [js, jvm, native] Content [js, native] abstract fun close () [jvm] abstract override fun close () equals [js, jvm, native] Content [js, jvm, native] open operator override fun equals (other: Any ?): Boolean hashCode [js, jvm, native] Content [js, jvm, native] open override fun hashCode (): Int read [js, jvm, native] Content [js, jvm, native] abstract fun read (sink: Buffer , byteCount: Long ): Long timeout [js, jvm, native] Content [js, jvm, native] abstract fun timeout (): Timeout toString [js, jvm, native] Content [js, jvm, native] open override fun toString (): String Inheritors \u00b6 Name BufferedSource ForwardingSource GzipSource InflaterSource Extensions \u00b6 Name Summary gzip [jvm] Brief description Returns a GzipSource that gzip-decompresses this Source while reading. Content inline fun Source . gzip (): GzipSource inflate [jvm] Brief description Returns an InflaterSource that DEFLATE-decompresses this Source while reading. Content inline fun Source . inflate (inflater: Inflater ): InflaterSource","title":"Source   - Okio"},{"location":"2.x/okio/okio/-source/#source","text":"[js, native] interface Source [jvm] interface Source : Closeable","title":"Source"},{"location":"2.x/okio/okio/-source/#functions","text":"Name Summary close [js, jvm, native] Content [js, native] abstract fun close () [jvm] abstract override fun close () equals [js, jvm, native] Content [js, jvm, native] open operator override fun equals (other: Any ?): Boolean hashCode [js, jvm, native] Content [js, jvm, native] open override fun hashCode (): Int read [js, jvm, native] Content [js, jvm, native] abstract fun read (sink: Buffer , byteCount: Long ): Long timeout [js, jvm, native] Content [js, jvm, native] abstract fun timeout (): Timeout toString [js, jvm, native] Content [js, jvm, native] open override fun toString (): String","title":"Functions"},{"location":"2.x/okio/okio/-source/#inheritors","text":"Name BufferedSource ForwardingSource GzipSource InflaterSource","title":"Inheritors"},{"location":"2.x/okio/okio/-source/#extensions","text":"Name Summary gzip [jvm] Brief description Returns a GzipSource that gzip-decompresses this Source while reading. Content inline fun Source . gzip (): GzipSource inflate [jvm] Brief description Returns an InflaterSource that DEFLATE-decompresses this Source while reading. Content inline fun Source . inflate (inflater: Inflater ): InflaterSource","title":"Extensions"},{"location":"2.x/okio/okio/-source/close/","text":"// okio / okio / Source / close close \u00b6 [js, jvm, native] Content [js, native] abstract fun close () [jvm] abstract override fun close ()","title":"close   - Okio"},{"location":"2.x/okio/okio/-source/close/#close","text":"[js, jvm, native] Content [js, native] abstract fun close () [jvm] abstract override fun close ()","title":"close"},{"location":"2.x/okio/okio/-source/read/","text":"// okio / okio / Source / read read \u00b6 [js, jvm, native] Content [js, jvm, native] abstract fun read (sink: Buffer , byteCount: Long ): Long","title":"read   - Okio"},{"location":"2.x/okio/okio/-source/read/#read","text":"[js, jvm, native] Content [js, jvm, native] abstract fun read (sink: Buffer , byteCount: Long ): Long","title":"read"},{"location":"2.x/okio/okio/-source/timeout/","text":"// okio / okio / Source / timeout timeout \u00b6 [js, jvm, native] Content [js, jvm, native] abstract fun timeout (): Timeout","title":"timeout   - Okio"},{"location":"2.x/okio/okio/-source/timeout/#timeout","text":"[js, jvm, native] Content [js, jvm, native] abstract fun timeout (): Timeout","title":"timeout"},{"location":"2.x/okio/okio/-throttler/","text":"// okio / okio / Throttler Throttler \u00b6 [jvm] Enables limiting of Source and Sink throughput. Attach to this throttler via source and sink and set the desired throughput via bytesPerSecond . Multiple Sources and Sinks can be attached to a single Throttler and they will be throttled as a group, where their combined throughput will not exceed the desired throughput. The same Source or Sink can be attached to multiple Throttlers and its throughput will not exceed the desired throughput of any of the Throttlers.This class has these tuning parameters: bytesPerSecond: Maximum sustained throughput. Use 0 for no limit. waitByteCount: When the requested byte count is greater than this many bytes and isn\u2019t immediately available, only wait until we can allocate at least this many bytes. Use this to set the ideal byte count during sustained throughput. maxByteCount: Maximum number of bytes to allocate on any call. This is also the number of bytes that will be returned before any waiting. class Throttler Constructors \u00b6 Name Summary [jvm] fun () Functions \u00b6 Name Summary bytesPerSecond [jvm] Brief description Sets the rate at which bytes will be allocated. Use 0 for no limit. Content @ JvmOverloads () fun bytesPerSecond (bytesPerSecond: Long , waitByteCount: Long , maxByteCount: Long ) equals [jvm] Content open operator override fun equals (other: Any ?): Boolean hashCode [jvm] Content open override fun hashCode (): Int sink [jvm] Brief description Create a Sink which honors this Throttler. Content fun sink (sink: Sink ): Sink source [jvm] Brief description Create a Source which honors this Throttler. Content fun source (source: Source ): Source toString [jvm] Content open override fun toString (): String","title":"Throttler   - Okio"},{"location":"2.x/okio/okio/-throttler/#throttler","text":"[jvm] Enables limiting of Source and Sink throughput. Attach to this throttler via source and sink and set the desired throughput via bytesPerSecond . Multiple Sources and Sinks can be attached to a single Throttler and they will be throttled as a group, where their combined throughput will not exceed the desired throughput. The same Source or Sink can be attached to multiple Throttlers and its throughput will not exceed the desired throughput of any of the Throttlers.This class has these tuning parameters: bytesPerSecond: Maximum sustained throughput. Use 0 for no limit. waitByteCount: When the requested byte count is greater than this many bytes and isn\u2019t immediately available, only wait until we can allocate at least this many bytes. Use this to set the ideal byte count during sustained throughput. maxByteCount: Maximum number of bytes to allocate on any call. This is also the number of bytes that will be returned before any waiting. class Throttler","title":"Throttler"},{"location":"2.x/okio/okio/-throttler/#constructors","text":"Name Summary [jvm] fun ()","title":"Constructors"},{"location":"2.x/okio/okio/-throttler/#functions","text":"Name Summary bytesPerSecond [jvm] Brief description Sets the rate at which bytes will be allocated. Use 0 for no limit. Content @ JvmOverloads () fun bytesPerSecond (bytesPerSecond: Long , waitByteCount: Long , maxByteCount: Long ) equals [jvm] Content open operator override fun equals (other: Any ?): Boolean hashCode [jvm] Content open override fun hashCode (): Int sink [jvm] Brief description Create a Sink which honors this Throttler. Content fun sink (sink: Sink ): Sink source [jvm] Brief description Create a Source which honors this Throttler. Content fun source (source: Source ): Source toString [jvm] Content open override fun toString (): String","title":"Functions"},{"location":"2.x/okio/okio/-throttler/-init-/","text":"// okio / okio / Throttler / \u00b6 [jvm] Content fun ()","title":"<init>   - Okio"},{"location":"2.x/okio/okio/-throttler/-init-/#_1","text":"[jvm] Content fun ()","title":""},{"location":"2.x/okio/okio/-throttler/bytes-per-second/","text":"// okio / okio / Throttler / bytesPerSecond bytesPerSecond \u00b6 [jvm] Brief description Sets the rate at which bytes will be allocated. Use 0 for no limit. Content @ JvmOverloads () fun bytesPerSecond (bytesPerSecond: Long , waitByteCount: Long , maxByteCount: Long )","title":"bytesPerSecond   - Okio"},{"location":"2.x/okio/okio/-throttler/bytes-per-second/#bytespersecond","text":"[jvm] Brief description Sets the rate at which bytes will be allocated. Use 0 for no limit. Content @ JvmOverloads () fun bytesPerSecond (bytesPerSecond: Long , waitByteCount: Long , maxByteCount: Long )","title":"bytesPerSecond"},{"location":"2.x/okio/okio/-throttler/sink/","text":"// okio / okio / Throttler / sink sink \u00b6 [jvm] Brief description Create a Sink which honors this Throttler. Content fun sink (sink: Sink ): Sink","title":"sink   - Okio"},{"location":"2.x/okio/okio/-throttler/sink/#sink","text":"[jvm] Brief description Create a Sink which honors this Throttler. Content fun sink (sink: Sink ): Sink","title":"sink"},{"location":"2.x/okio/okio/-throttler/source/","text":"// okio / okio / Throttler / source source \u00b6 [jvm] Brief description Create a Source which honors this Throttler. Content fun source (source: Source ): Source","title":"source   - Okio"},{"location":"2.x/okio/okio/-throttler/source/#source","text":"[jvm] Brief description Create a Source which honors this Throttler. Content fun source (source: Source ): Source","title":"source"},{"location":"2.x/okio/okio/-timeout/","text":"// okio / okio / Timeout Timeout \u00b6 [js, jvm, native] open class Timeout Types \u00b6 Name Summary Companion [js, jvm, native] Content [js, jvm, native] object Companion Functions \u00b6 Name Summary clearDeadline [jvm] Brief description Clears the deadline. Content open fun clearDeadline (): Timeout clearTimeout [jvm] Brief description Clears the timeout. Operating system timeouts may still apply. Content open fun clearTimeout (): Timeout deadline [jvm] Brief description Set a deadline of now plus duration time. Content fun deadline (duration: Long , unit: TimeUnit ): Timeout deadlineNanoTime [jvm] Brief description Returns the nano time when the deadline will be reached. Content open fun deadlineNanoTime (): Long [jvm] Brief description Sets the nano time when the deadline will be reached. All operations must complete before this time. Use a deadline to set a maximum bound on the time spent on a sequence of operations. Content open fun deadlineNanoTime (deadlineNanoTime: Long ): Timeout equals [js, jvm, native] Content [js, jvm, native] open operator override fun equals (other: Any ?): Boolean hasDeadline [jvm] Brief description Returns true if a deadline is enabled. Content open fun hasDeadline (): Boolean hashCode [js, jvm, native] Content [js, jvm, native] open override fun hashCode (): Int intersectWith [jvm] Brief description Applies the minimum intersection between this timeout and other, run block, then finally rollback this timeout\u2019s values. Content inline fun intersectWith (other: Timeout , block: () -> Unit ) throwIfReached [jvm] Brief description Throws an InterruptedIOException if the deadline has been reached or if the current thread has been interrupted. This method doesn\u2019t detect timeouts; that should be implemented to asynchronously abort an in-progress operation. Content open fun throwIfReached () timeout [jvm] Brief description Wait at most timeout time before aborting an operation. Using a per-operation timeout means that as long as forward progress is being made, no sequence of operations will fail.If timeout == 0, operations will run indefinitely. (Operating system timeouts may still apply.) Content open fun timeout (timeout: Long , unit: TimeUnit ): Timeout timeoutNanos [jvm] Brief description Returns the timeout in nanoseconds, or 0 for no timeout. Content open fun timeoutNanos (): Long toString [js, jvm, native] Content [js, jvm, native] open override fun toString (): String waitUntilNotified [jvm] Brief description Waits on monitor until it is notified. Throws InterruptedIOException if either the thread is interrupted or if this timeout elapses before monitor is notified. The caller must be synchronized on monitor.Here\u2019s a sample class that uses waitUntilNotified() to await a specific state. Note that the call is made within a loop to avoid unnecessary waiting and to mitigate spurious notifications.class Dice { Random random = new Random(); int latestTotal; public synchronized void roll() { latestTotal = 2 + random.nextInt(6) + random.nextInt(6); System.out.println(\u201cRolled \u201d + latestTotal); notifyAll(); } public void rollAtFixedRate(int period, TimeUnit timeUnit) { Executors.newScheduledThreadPool(0).scheduleAtFixedRate(new Runnable() { public void run() { roll(); } }, 0, period, timeUnit); } public synchronized void awaitTotal(Timeout timeout, int total) throws InterruptedIOException { while (latestTotal != total) { timeout.waitUntilNotified(this); } } } Content fun waitUntilNotified (monitor: Any ) Inheritors \u00b6 Name AsyncTimeout ForwardingTimeout","title":"Timeout   - Okio"},{"location":"2.x/okio/okio/-timeout/#timeout","text":"[js, jvm, native] open class Timeout","title":"Timeout"},{"location":"2.x/okio/okio/-timeout/#types","text":"Name Summary Companion [js, jvm, native] Content [js, jvm, native] object Companion","title":"Types"},{"location":"2.x/okio/okio/-timeout/#functions","text":"Name Summary clearDeadline [jvm] Brief description Clears the deadline. Content open fun clearDeadline (): Timeout clearTimeout [jvm] Brief description Clears the timeout. Operating system timeouts may still apply. Content open fun clearTimeout (): Timeout deadline [jvm] Brief description Set a deadline of now plus duration time. Content fun deadline (duration: Long , unit: TimeUnit ): Timeout deadlineNanoTime [jvm] Brief description Returns the nano time when the deadline will be reached. Content open fun deadlineNanoTime (): Long [jvm] Brief description Sets the nano time when the deadline will be reached. All operations must complete before this time. Use a deadline to set a maximum bound on the time spent on a sequence of operations. Content open fun deadlineNanoTime (deadlineNanoTime: Long ): Timeout equals [js, jvm, native] Content [js, jvm, native] open operator override fun equals (other: Any ?): Boolean hasDeadline [jvm] Brief description Returns true if a deadline is enabled. Content open fun hasDeadline (): Boolean hashCode [js, jvm, native] Content [js, jvm, native] open override fun hashCode (): Int intersectWith [jvm] Brief description Applies the minimum intersection between this timeout and other, run block, then finally rollback this timeout\u2019s values. Content inline fun intersectWith (other: Timeout , block: () -> Unit ) throwIfReached [jvm] Brief description Throws an InterruptedIOException if the deadline has been reached or if the current thread has been interrupted. This method doesn\u2019t detect timeouts; that should be implemented to asynchronously abort an in-progress operation. Content open fun throwIfReached () timeout [jvm] Brief description Wait at most timeout time before aborting an operation. Using a per-operation timeout means that as long as forward progress is being made, no sequence of operations will fail.If timeout == 0, operations will run indefinitely. (Operating system timeouts may still apply.) Content open fun timeout (timeout: Long , unit: TimeUnit ): Timeout timeoutNanos [jvm] Brief description Returns the timeout in nanoseconds, or 0 for no timeout. Content open fun timeoutNanos (): Long toString [js, jvm, native] Content [js, jvm, native] open override fun toString (): String waitUntilNotified [jvm] Brief description Waits on monitor until it is notified. Throws InterruptedIOException if either the thread is interrupted or if this timeout elapses before monitor is notified. The caller must be synchronized on monitor.Here\u2019s a sample class that uses waitUntilNotified() to await a specific state. Note that the call is made within a loop to avoid unnecessary waiting and to mitigate spurious notifications.class Dice { Random random = new Random(); int latestTotal; public synchronized void roll() { latestTotal = 2 + random.nextInt(6) + random.nextInt(6); System.out.println(\u201cRolled \u201d + latestTotal); notifyAll(); } public void rollAtFixedRate(int period, TimeUnit timeUnit) { Executors.newScheduledThreadPool(0).scheduleAtFixedRate(new Runnable() { public void run() { roll(); } }, 0, period, timeUnit); } public synchronized void awaitTotal(Timeout timeout, int total) throws InterruptedIOException { while (latestTotal != total) { timeout.waitUntilNotified(this); } } } Content fun waitUntilNotified (monitor: Any )","title":"Functions"},{"location":"2.x/okio/okio/-timeout/#inheritors","text":"Name AsyncTimeout ForwardingTimeout","title":"Inheritors"},{"location":"2.x/okio/okio/-timeout/-init-/","text":"// okio / okio / Timeout / \u00b6 [js, jvm, native] Content [js, jvm, native] fun ()","title":"<init>   - Okio"},{"location":"2.x/okio/okio/-timeout/-init-/#_1","text":"[js, jvm, native] Content [js, jvm, native] fun ()","title":""},{"location":"2.x/okio/okio/-timeout/clear-deadline/","text":"// okio / okio / Timeout / clearDeadline clearDeadline \u00b6 [jvm] Brief description Clears the deadline. Content open fun clearDeadline (): Timeout","title":"clearDeadline   - Okio"},{"location":"2.x/okio/okio/-timeout/clear-deadline/#cleardeadline","text":"[jvm] Brief description Clears the deadline. Content open fun clearDeadline (): Timeout","title":"clearDeadline"},{"location":"2.x/okio/okio/-timeout/clear-timeout/","text":"// okio / okio / Timeout / clearTimeout clearTimeout \u00b6 [jvm] Brief description Clears the timeout. Operating system timeouts may still apply. Content open fun clearTimeout (): Timeout","title":"clearTimeout   - Okio"},{"location":"2.x/okio/okio/-timeout/clear-timeout/#cleartimeout","text":"[jvm] Brief description Clears the timeout. Operating system timeouts may still apply. Content open fun clearTimeout (): Timeout","title":"clearTimeout"},{"location":"2.x/okio/okio/-timeout/deadline-nano-time/","text":"// okio / okio / Timeout / deadlineNanoTime deadlineNanoTime \u00b6 [jvm] Brief description Returns the nano time when the deadline will be reached. Content open fun deadlineNanoTime (): Long [jvm] Brief description Sets the nano time when the deadline will be reached. All operations must complete before this time. Use a deadline to set a maximum bound on the time spent on a sequence of operations. Content open fun deadlineNanoTime (deadlineNanoTime: Long ): Timeout","title":"deadlineNanoTime   - Okio"},{"location":"2.x/okio/okio/-timeout/deadline-nano-time/#deadlinenanotime","text":"[jvm] Brief description Returns the nano time when the deadline will be reached. Content open fun deadlineNanoTime (): Long [jvm] Brief description Sets the nano time when the deadline will be reached. All operations must complete before this time. Use a deadline to set a maximum bound on the time spent on a sequence of operations. Content open fun deadlineNanoTime (deadlineNanoTime: Long ): Timeout","title":"deadlineNanoTime"},{"location":"2.x/okio/okio/-timeout/deadline/","text":"// okio / okio / Timeout / deadline deadline \u00b6 [jvm] Brief description Set a deadline of now plus duration time. Content fun deadline (duration: Long , unit: TimeUnit ): Timeout","title":"deadline   - Okio"},{"location":"2.x/okio/okio/-timeout/deadline/#deadline","text":"[jvm] Brief description Set a deadline of now plus duration time. Content fun deadline (duration: Long , unit: TimeUnit ): Timeout","title":"deadline"},{"location":"2.x/okio/okio/-timeout/has-deadline/","text":"// okio / okio / Timeout / hasDeadline hasDeadline \u00b6 [jvm] Brief description Returns true if a deadline is enabled. Content open fun hasDeadline (): Boolean","title":"hasDeadline   - Okio"},{"location":"2.x/okio/okio/-timeout/has-deadline/#hasdeadline","text":"[jvm] Brief description Returns true if a deadline is enabled. Content open fun hasDeadline (): Boolean","title":"hasDeadline"},{"location":"2.x/okio/okio/-timeout/intersect-with/","text":"// okio / okio / Timeout / intersectWith intersectWith \u00b6 [jvm] Brief description Applies the minimum intersection between this timeout and other, run block, then finally rollback this timeout\u2019s values. Content inline fun intersectWith (other: Timeout , block: () -> Unit )","title":"intersectWith   - Okio"},{"location":"2.x/okio/okio/-timeout/intersect-with/#intersectwith","text":"[jvm] Brief description Applies the minimum intersection between this timeout and other, run block, then finally rollback this timeout\u2019s values. Content inline fun intersectWith (other: Timeout , block: () -> Unit )","title":"intersectWith"},{"location":"2.x/okio/okio/-timeout/throw-if-reached/","text":"// okio / okio / Timeout / throwIfReached throwIfReached \u00b6 [jvm] Brief description Throws an InterruptedIOException if the deadline has been reached or if the current thread has been interrupted. This method doesn\u2019t detect timeouts; that should be implemented to asynchronously abort an in-progress operation. Content open fun throwIfReached ()","title":"throwIfReached   - Okio"},{"location":"2.x/okio/okio/-timeout/throw-if-reached/#throwifreached","text":"[jvm] Brief description Throws an InterruptedIOException if the deadline has been reached or if the current thread has been interrupted. This method doesn\u2019t detect timeouts; that should be implemented to asynchronously abort an in-progress operation. Content open fun throwIfReached ()","title":"throwIfReached"},{"location":"2.x/okio/okio/-timeout/timeout-nanos/","text":"// okio / okio / Timeout / timeoutNanos timeoutNanos \u00b6 [jvm] Brief description Returns the timeout in nanoseconds, or 0 for no timeout. Content open fun timeoutNanos (): Long","title":"timeoutNanos   - Okio"},{"location":"2.x/okio/okio/-timeout/timeout-nanos/#timeoutnanos","text":"[jvm] Brief description Returns the timeout in nanoseconds, or 0 for no timeout. Content open fun timeoutNanos (): Long","title":"timeoutNanos"},{"location":"2.x/okio/okio/-timeout/timeout/","text":"// okio / okio / Timeout / timeout timeout \u00b6 [jvm] Brief description Wait at most timeout time before aborting an operation. Using a per-operation timeout means that as long as forward progress is being made, no sequence of operations will fail.If timeout == 0, operations will run indefinitely. (Operating system timeouts may still apply.) Content open fun timeout (timeout: Long , unit: TimeUnit ): Timeout","title":"timeout   - Okio"},{"location":"2.x/okio/okio/-timeout/timeout/#timeout","text":"[jvm] Brief description Wait at most timeout time before aborting an operation. Using a per-operation timeout means that as long as forward progress is being made, no sequence of operations will fail.If timeout == 0, operations will run indefinitely. (Operating system timeouts may still apply.) Content open fun timeout (timeout: Long , unit: TimeUnit ): Timeout","title":"timeout"},{"location":"2.x/okio/okio/-timeout/wait-until-notified/","text":"// okio / okio / Timeout / waitUntilNotified waitUntilNotified \u00b6 [jvm] Brief description Waits on monitor until it is notified. Throws InterruptedIOException if either the thread is interrupted or if this timeout elapses before monitor is notified. The caller must be synchronized on monitor.Here\u2019s a sample class that uses waitUntilNotified() to await a specific state. Note that the call is made within a loop to avoid unnecessary waiting and to mitigate spurious notifications.class Dice { Random random = new Random(); int latestTotal; public synchronized void roll() { latestTotal = 2 + random.nextInt(6) + random.nextInt(6); System.out.println(\u201cRolled \u201d + latestTotal); notifyAll(); } public void rollAtFixedRate(int period, TimeUnit timeUnit) { Executors.newScheduledThreadPool(0).scheduleAtFixedRate(new Runnable() { public void run() { roll(); } }, 0, period, timeUnit); } public synchronized void awaitTotal(Timeout timeout, int total) throws InterruptedIOException { while (latestTotal != total) { timeout.waitUntilNotified(this); } } } Content fun waitUntilNotified (monitor: Any )","title":"waitUntilNotified   - Okio"},{"location":"2.x/okio/okio/-timeout/wait-until-notified/#waituntilnotified","text":"[jvm] Brief description Waits on monitor until it is notified. Throws InterruptedIOException if either the thread is interrupted or if this timeout elapses before monitor is notified. The caller must be synchronized on monitor.Here\u2019s a sample class that uses waitUntilNotified() to await a specific state. Note that the call is made within a loop to avoid unnecessary waiting and to mitigate spurious notifications.class Dice { Random random = new Random(); int latestTotal; public synchronized void roll() { latestTotal = 2 + random.nextInt(6) + random.nextInt(6); System.out.println(\u201cRolled \u201d + latestTotal); notifyAll(); } public void rollAtFixedRate(int period, TimeUnit timeUnit) { Executors.newScheduledThreadPool(0).scheduleAtFixedRate(new Runnable() { public void run() { roll(); } }, 0, period, timeUnit); } public synchronized void awaitTotal(Timeout timeout, int total) throws InterruptedIOException { while (latestTotal != total) { timeout.waitUntilNotified(this); } } } Content fun waitUntilNotified (monitor: Any )","title":"waitUntilNotified"},{"location":"2.x/okio/okio/-timeout/-companion/","text":"// okio / okio / Timeout / Companion Companion \u00b6 [js, jvm, native] object Companion Functions \u00b6 Name Summary equals [js, jvm, native] Content [js, jvm, native] open operator override fun equals (other: Any ?): Boolean hashCode [js, jvm, native] Content [js, jvm, native] open override fun hashCode (): Int minTimeout [jvm] Content fun minTimeout (aNanos: Long , bNanos: Long ): Long toString [js, jvm, native] Content [js, jvm, native] open override fun toString (): String Properties \u00b6 Name Summary NONE [js, native] val NONE : Timeout [jvm] @ JvmField () val NONE : Timeout","title":"Companion   - Okio"},{"location":"2.x/okio/okio/-timeout/-companion/#companion","text":"[js, jvm, native] object Companion","title":"Companion"},{"location":"2.x/okio/okio/-timeout/-companion/#functions","text":"Name Summary equals [js, jvm, native] Content [js, jvm, native] open operator override fun equals (other: Any ?): Boolean hashCode [js, jvm, native] Content [js, jvm, native] open override fun hashCode (): Int minTimeout [jvm] Content fun minTimeout (aNanos: Long , bNanos: Long ): Long toString [js, jvm, native] Content [js, jvm, native] open override fun toString (): String","title":"Functions"},{"location":"2.x/okio/okio/-timeout/-companion/#properties","text":"Name Summary NONE [js, native] val NONE : Timeout [jvm] @ JvmField () val NONE : Timeout","title":"Properties"},{"location":"2.x/okio/okio/-timeout/-companion/min-timeout/","text":"// okio / okio / Timeout / Companion / minTimeout minTimeout \u00b6 [jvm] Content fun minTimeout (aNanos: Long , bNanos: Long ): Long","title":"minTimeout   - Okio"},{"location":"2.x/okio/okio/-timeout/-companion/min-timeout/#mintimeout","text":"[jvm] Content fun minTimeout (aNanos: Long , bNanos: Long ): Long","title":"minTimeout"}]}